
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AttendanceDay
 * 
 */
export type AttendanceDay = $Result.DefaultSelection<Prisma.$AttendanceDayPayload>
/**
 * Model AttendanceEvent
 * 
 */
export type AttendanceEvent = $Result.DefaultSelection<Prisma.$AttendanceEventPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserBranchAccess
 * 
 */
export type UserBranchAccess = $Result.DefaultSelection<Prisma.$UserBranchAccessPayload>
/**
 * Model UserLocation
 * 
 */
export type UserLocation = $Result.DefaultSelection<Prisma.$UserLocationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model DefectiveLog
 * 
 */
export type DefectiveLog = $Result.DefaultSelection<Prisma.$DefectiveLogPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionItem
 * 
 */
export type TransactionItem = $Result.DefaultSelection<Prisma.$TransactionItemPayload>
/**
 * Model ProductTransfer
 * 
 */
export type ProductTransfer = $Result.DefaultSelection<Prisma.$ProductTransferPayload>
/**
 * Model PaymentSchedule
 * 
 */
export type PaymentSchedule = $Result.DefaultSelection<Prisma.$PaymentSchedulePayload>
/**
 * Model PaymentRepayment
 * 
 */
export type PaymentRepayment = $Result.DefaultSelection<Prisma.$PaymentRepaymentPayload>
/**
 * Model DailyRepayment
 * 
 */
export type DailyRepayment = $Result.DefaultSelection<Prisma.$DailyRepaymentPayload>
/**
 * Model CreditRepayment
 * 
 */
export type CreditRepayment = $Result.DefaultSelection<Prisma.$CreditRepaymentPayload>
/**
 * Model CashierReport
 * 
 */
export type CashierReport = $Result.DefaultSelection<Prisma.$CashierReportPayload>
/**
 * Model CurrencyExchangeRate
 * 
 */
export type CurrencyExchangeRate = $Result.DefaultSelection<Prisma.$CurrencyExchangeRatePayload>
/**
 * Model Bonus
 * 
 */
export type Bonus = $Result.DefaultSelection<Prisma.$BonusPayload>
/**
 * Model TransactionBonusProduct
 * 
 */
export type TransactionBonusProduct = $Result.DefaultSelection<Prisma.$TransactionBonusProductPayload>
/**
 * Model WorkSchedule
 * 
 */
export type WorkSchedule = $Result.DefaultSelection<Prisma.$WorkSchedulePayload>
/**
 * Model barcodeCounter
 * 
 */
export type barcodeCounter = $Result.DefaultSelection<Prisma.$barcodeCounterPayload>
/**
 * Model FaceTemplate
 * 
 */
export type FaceTemplate = $Result.DefaultSelection<Prisma.$FaceTemplatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AttendanceEventType: {
  CHECK_IN: 'CHECK_IN',
  CHECK_OUT: 'CHECK_OUT',
  MANUAL_ADJUST: 'MANUAL_ADJUST'
};

export type AttendanceEventType = (typeof AttendanceEventType)[keyof typeof AttendanceEventType]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  LEFT_EARLY: 'LEFT_EARLY'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const TransactionType: {
  SALE: 'SALE',
  STOCK_ADJUSTMENT: 'STOCK_ADJUSTMENT',
  TRANSFER: 'TRANSFER',
  PURCHASE: 'PURCHASE',
  RETURN: 'RETURN',
  WRITE_OFF: 'WRITE_OFF',
  DELIVERY: 'DELIVERY'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PaymentType: {
  CASH: 'CASH',
  CARD: 'CARD',
  TERMINAL: 'TERMINAL',
  CREDIT: 'CREDIT',
  INSTALLMENT: 'INSTALLMENT'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  CASHIER: 'CASHIER',
  WAREHOUSE: 'WAREHOUSE',
  AUDITOR: 'AUDITOR',
  MARKETING: 'MARKETING',
  OPERATOR: 'OPERATOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const BranchType: {
  SKLAD: 'SKLAD',
  SAVDO_MARKAZ: 'SAVDO_MARKAZ',
  TELEFON_MARKAZI: 'TELEFON_MARKAZI'
};

export type BranchType = (typeof BranchType)[keyof typeof BranchType]


export const TransferStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const ProductStatus: {
  IN_WAREHOUSE: 'IN_WAREHOUSE',
  IN_STORE: 'IN_STORE',
  SOLD: 'SOLD',
  DEFECTIVE: 'DEFECTIVE',
  RETURNED: 'RETURNED',
  CARRIER: 'CARRIER',
  FIXED: 'FIXED',
  EXCHANGED: 'EXCHANGED'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const ProductSizeType: {
  NONE: 'NONE',
  AREA_SQM: 'AREA_SQM',
  CLOTHING_ALPHA: 'CLOTHING_ALPHA',
  CLOTHING_NUMERIC: 'CLOTHING_NUMERIC',
  FREE_TEXT: 'FREE_TEXT'
};

export type ProductSizeType = (typeof ProductSizeType)[keyof typeof ProductSizeType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  DELETED: 'DELETED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const BranchStatus: {
  ACTIVE: 'ACTIVE',
  DELETED: 'DELETED'
};

export type BranchStatus = (typeof BranchStatus)[keyof typeof BranchStatus]

}

export type AttendanceEventType = $Enums.AttendanceEventType

export const AttendanceEventType: typeof $Enums.AttendanceEventType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type BranchType = $Enums.BranchType

export const BranchType: typeof $Enums.BranchType

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type ProductSizeType = $Enums.ProductSizeType

export const ProductSizeType: typeof $Enums.ProductSizeType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type BranchStatus = $Enums.BranchStatus

export const BranchStatus: typeof $Enums.BranchStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AttendanceDays
 * const attendanceDays = await prisma.attendanceDay.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AttendanceDays
   * const attendanceDays = await prisma.attendanceDay.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.attendanceDay`: Exposes CRUD operations for the **AttendanceDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceDays
    * const attendanceDays = await prisma.attendanceDay.findMany()
    * ```
    */
  get attendanceDay(): Prisma.AttendanceDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceEvent`: Exposes CRUD operations for the **AttendanceEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceEvents
    * const attendanceEvents = await prisma.attendanceEvent.findMany()
    * ```
    */
  get attendanceEvent(): Prisma.AttendanceEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBranchAccess`: Exposes CRUD operations for the **UserBranchAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBranchAccesses
    * const userBranchAccesses = await prisma.userBranchAccess.findMany()
    * ```
    */
  get userBranchAccess(): Prisma.UserBranchAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLocation`: Exposes CRUD operations for the **UserLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLocations
    * const userLocations = await prisma.userLocation.findMany()
    * ```
    */
  get userLocation(): Prisma.UserLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defectiveLog`: Exposes CRUD operations for the **DefectiveLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefectiveLogs
    * const defectiveLogs = await prisma.defectiveLog.findMany()
    * ```
    */
  get defectiveLog(): Prisma.DefectiveLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionItem`: Exposes CRUD operations for the **TransactionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionItems
    * const transactionItems = await prisma.transactionItem.findMany()
    * ```
    */
  get transactionItem(): Prisma.TransactionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productTransfer`: Exposes CRUD operations for the **ProductTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTransfers
    * const productTransfers = await prisma.productTransfer.findMany()
    * ```
    */
  get productTransfer(): Prisma.ProductTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentSchedule`: Exposes CRUD operations for the **PaymentSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentSchedules
    * const paymentSchedules = await prisma.paymentSchedule.findMany()
    * ```
    */
  get paymentSchedule(): Prisma.PaymentScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentRepayment`: Exposes CRUD operations for the **PaymentRepayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentRepayments
    * const paymentRepayments = await prisma.paymentRepayment.findMany()
    * ```
    */
  get paymentRepayment(): Prisma.PaymentRepaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyRepayment`: Exposes CRUD operations for the **DailyRepayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRepayments
    * const dailyRepayments = await prisma.dailyRepayment.findMany()
    * ```
    */
  get dailyRepayment(): Prisma.DailyRepaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditRepayment`: Exposes CRUD operations for the **CreditRepayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditRepayments
    * const creditRepayments = await prisma.creditRepayment.findMany()
    * ```
    */
  get creditRepayment(): Prisma.CreditRepaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashierReport`: Exposes CRUD operations for the **CashierReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashierReports
    * const cashierReports = await prisma.cashierReport.findMany()
    * ```
    */
  get cashierReport(): Prisma.CashierReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currencyExchangeRate`: Exposes CRUD operations for the **CurrencyExchangeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrencyExchangeRates
    * const currencyExchangeRates = await prisma.currencyExchangeRate.findMany()
    * ```
    */
  get currencyExchangeRate(): Prisma.CurrencyExchangeRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bonus`: Exposes CRUD operations for the **Bonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bonuses
    * const bonuses = await prisma.bonus.findMany()
    * ```
    */
  get bonus(): Prisma.BonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionBonusProduct`: Exposes CRUD operations for the **TransactionBonusProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionBonusProducts
    * const transactionBonusProducts = await prisma.transactionBonusProduct.findMany()
    * ```
    */
  get transactionBonusProduct(): Prisma.TransactionBonusProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workSchedule`: Exposes CRUD operations for the **WorkSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkSchedules
    * const workSchedules = await prisma.workSchedule.findMany()
    * ```
    */
  get workSchedule(): Prisma.WorkScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barcodeCounter`: Exposes CRUD operations for the **barcodeCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarcodeCounters
    * const barcodeCounters = await prisma.barcodeCounter.findMany()
    * ```
    */
  get barcodeCounter(): Prisma.barcodeCounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faceTemplate`: Exposes CRUD operations for the **FaceTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FaceTemplates
    * const faceTemplates = await prisma.faceTemplate.findMany()
    * ```
    */
  get faceTemplate(): Prisma.FaceTemplateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AttendanceDay: 'AttendanceDay',
    AttendanceEvent: 'AttendanceEvent',
    Branch: 'Branch',
    User: 'User',
    UserBranchAccess: 'UserBranchAccess',
    UserLocation: 'UserLocation',
    Category: 'Category',
    Product: 'Product',
    DefectiveLog: 'DefectiveLog',
    Customer: 'Customer',
    Transaction: 'Transaction',
    TransactionItem: 'TransactionItem',
    ProductTransfer: 'ProductTransfer',
    PaymentSchedule: 'PaymentSchedule',
    PaymentRepayment: 'PaymentRepayment',
    DailyRepayment: 'DailyRepayment',
    CreditRepayment: 'CreditRepayment',
    CashierReport: 'CashierReport',
    CurrencyExchangeRate: 'CurrencyExchangeRate',
    Bonus: 'Bonus',
    TransactionBonusProduct: 'TransactionBonusProduct',
    WorkSchedule: 'WorkSchedule',
    barcodeCounter: 'barcodeCounter',
    FaceTemplate: 'FaceTemplate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "attendanceDay" | "attendanceEvent" | "branch" | "user" | "userBranchAccess" | "userLocation" | "category" | "product" | "defectiveLog" | "customer" | "transaction" | "transactionItem" | "productTransfer" | "paymentSchedule" | "paymentRepayment" | "dailyRepayment" | "creditRepayment" | "cashierReport" | "currencyExchangeRate" | "bonus" | "transactionBonusProduct" | "workSchedule" | "barcodeCounter" | "faceTemplate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AttendanceDay: {
        payload: Prisma.$AttendanceDayPayload<ExtArgs>
        fields: Prisma.AttendanceDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          findFirst: {
            args: Prisma.AttendanceDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          findMany: {
            args: Prisma.AttendanceDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          create: {
            args: Prisma.AttendanceDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          createMany: {
            args: Prisma.AttendanceDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          delete: {
            args: Prisma.AttendanceDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          update: {
            args: Prisma.AttendanceDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          aggregate: {
            args: Prisma.AttendanceDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceDay>
          }
          groupBy: {
            args: Prisma.AttendanceDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceDayCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDayCountAggregateOutputType> | number
          }
        }
      }
      AttendanceEvent: {
        payload: Prisma.$AttendanceEventPayload<ExtArgs>
        fields: Prisma.AttendanceEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findFirst: {
            args: Prisma.AttendanceEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findMany: {
            args: Prisma.AttendanceEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          create: {
            args: Prisma.AttendanceEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          createMany: {
            args: Prisma.AttendanceEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          delete: {
            args: Prisma.AttendanceEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          update: {
            args: Prisma.AttendanceEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          aggregate: {
            args: Prisma.AttendanceEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceEvent>
          }
          groupBy: {
            args: Prisma.AttendanceEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceEventCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserBranchAccess: {
        payload: Prisma.$UserBranchAccessPayload<ExtArgs>
        fields: Prisma.UserBranchAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBranchAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBranchAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          findFirst: {
            args: Prisma.UserBranchAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBranchAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          findMany: {
            args: Prisma.UserBranchAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>[]
          }
          create: {
            args: Prisma.UserBranchAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          createMany: {
            args: Prisma.UserBranchAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBranchAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>[]
          }
          delete: {
            args: Prisma.UserBranchAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          update: {
            args: Prisma.UserBranchAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          deleteMany: {
            args: Prisma.UserBranchAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBranchAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBranchAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>[]
          }
          upsert: {
            args: Prisma.UserBranchAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBranchAccessPayload>
          }
          aggregate: {
            args: Prisma.UserBranchAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBranchAccess>
          }
          groupBy: {
            args: Prisma.UserBranchAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBranchAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBranchAccessCountArgs<ExtArgs>
            result: $Utils.Optional<UserBranchAccessCountAggregateOutputType> | number
          }
        }
      }
      UserLocation: {
        payload: Prisma.$UserLocationPayload<ExtArgs>
        fields: Prisma.UserLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          findFirst: {
            args: Prisma.UserLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          findMany: {
            args: Prisma.UserLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>[]
          }
          create: {
            args: Prisma.UserLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          createMany: {
            args: Prisma.UserLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>[]
          }
          delete: {
            args: Prisma.UserLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          update: {
            args: Prisma.UserLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          deleteMany: {
            args: Prisma.UserLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>[]
          }
          upsert: {
            args: Prisma.UserLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          aggregate: {
            args: Prisma.UserLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLocation>
          }
          groupBy: {
            args: Prisma.UserLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLocationCountArgs<ExtArgs>
            result: $Utils.Optional<UserLocationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      DefectiveLog: {
        payload: Prisma.$DefectiveLogPayload<ExtArgs>
        fields: Prisma.DefectiveLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefectiveLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefectiveLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          findFirst: {
            args: Prisma.DefectiveLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefectiveLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          findMany: {
            args: Prisma.DefectiveLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>[]
          }
          create: {
            args: Prisma.DefectiveLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          createMany: {
            args: Prisma.DefectiveLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefectiveLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>[]
          }
          delete: {
            args: Prisma.DefectiveLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          update: {
            args: Prisma.DefectiveLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          deleteMany: {
            args: Prisma.DefectiveLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefectiveLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DefectiveLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>[]
          }
          upsert: {
            args: Prisma.DefectiveLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectiveLogPayload>
          }
          aggregate: {
            args: Prisma.DefectiveLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefectiveLog>
          }
          groupBy: {
            args: Prisma.DefectiveLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefectiveLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefectiveLogCountArgs<ExtArgs>
            result: $Utils.Optional<DefectiveLogCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionItem: {
        payload: Prisma.$TransactionItemPayload<ExtArgs>
        fields: Prisma.TransactionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findFirst: {
            args: Prisma.TransactionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findMany: {
            args: Prisma.TransactionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          create: {
            args: Prisma.TransactionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          createMany: {
            args: Prisma.TransactionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          delete: {
            args: Prisma.TransactionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          update: {
            args: Prisma.TransactionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          deleteMany: {
            args: Prisma.TransactionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          upsert: {
            args: Prisma.TransactionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          aggregate: {
            args: Prisma.TransactionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionItem>
          }
          groupBy: {
            args: Prisma.TransactionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemCountAggregateOutputType> | number
          }
        }
      }
      ProductTransfer: {
        payload: Prisma.$ProductTransferPayload<ExtArgs>
        fields: Prisma.ProductTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          findFirst: {
            args: Prisma.ProductTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          findMany: {
            args: Prisma.ProductTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>[]
          }
          create: {
            args: Prisma.ProductTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          createMany: {
            args: Prisma.ProductTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>[]
          }
          delete: {
            args: Prisma.ProductTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          update: {
            args: Prisma.ProductTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          deleteMany: {
            args: Prisma.ProductTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>[]
          }
          upsert: {
            args: Prisma.ProductTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransferPayload>
          }
          aggregate: {
            args: Prisma.ProductTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTransfer>
          }
          groupBy: {
            args: Prisma.ProductTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTransferCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTransferCountAggregateOutputType> | number
          }
        }
      }
      PaymentSchedule: {
        payload: Prisma.$PaymentSchedulePayload<ExtArgs>
        fields: Prisma.PaymentScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          findFirst: {
            args: Prisma.PaymentScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          findMany: {
            args: Prisma.PaymentScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>[]
          }
          create: {
            args: Prisma.PaymentScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          createMany: {
            args: Prisma.PaymentScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>[]
          }
          delete: {
            args: Prisma.PaymentScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          update: {
            args: Prisma.PaymentScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          deleteMany: {
            args: Prisma.PaymentScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>[]
          }
          upsert: {
            args: Prisma.PaymentScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSchedulePayload>
          }
          aggregate: {
            args: Prisma.PaymentScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentSchedule>
          }
          groupBy: {
            args: Prisma.PaymentScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentScheduleCountAggregateOutputType> | number
          }
        }
      }
      PaymentRepayment: {
        payload: Prisma.$PaymentRepaymentPayload<ExtArgs>
        fields: Prisma.PaymentRepaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentRepaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentRepaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentRepaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentRepaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentRepaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentRepaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentRepaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentRepaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentRepaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          update: {
            args: Prisma.PaymentRepaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentRepaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentRepaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentRepaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentRepaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRepaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentRepaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentRepayment>
          }
          groupBy: {
            args: Prisma.PaymentRepaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentRepaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentRepaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentRepaymentCountAggregateOutputType> | number
          }
        }
      }
      DailyRepayment: {
        payload: Prisma.$DailyRepaymentPayload<ExtArgs>
        fields: Prisma.DailyRepaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRepaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRepaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          findFirst: {
            args: Prisma.DailyRepaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRepaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          findMany: {
            args: Prisma.DailyRepaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>[]
          }
          create: {
            args: Prisma.DailyRepaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          createMany: {
            args: Prisma.DailyRepaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRepaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>[]
          }
          delete: {
            args: Prisma.DailyRepaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          update: {
            args: Prisma.DailyRepaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          deleteMany: {
            args: Prisma.DailyRepaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRepaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyRepaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>[]
          }
          upsert: {
            args: Prisma.DailyRepaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRepaymentPayload>
          }
          aggregate: {
            args: Prisma.DailyRepaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRepayment>
          }
          groupBy: {
            args: Prisma.DailyRepaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRepaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRepaymentCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRepaymentCountAggregateOutputType> | number
          }
        }
      }
      CreditRepayment: {
        payload: Prisma.$CreditRepaymentPayload<ExtArgs>
        fields: Prisma.CreditRepaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditRepaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditRepaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          findFirst: {
            args: Prisma.CreditRepaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditRepaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          findMany: {
            args: Prisma.CreditRepaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>[]
          }
          create: {
            args: Prisma.CreditRepaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          createMany: {
            args: Prisma.CreditRepaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditRepaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>[]
          }
          delete: {
            args: Prisma.CreditRepaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          update: {
            args: Prisma.CreditRepaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          deleteMany: {
            args: Prisma.CreditRepaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditRepaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditRepaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>[]
          }
          upsert: {
            args: Prisma.CreditRepaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditRepaymentPayload>
          }
          aggregate: {
            args: Prisma.CreditRepaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditRepayment>
          }
          groupBy: {
            args: Prisma.CreditRepaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditRepaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditRepaymentCountArgs<ExtArgs>
            result: $Utils.Optional<CreditRepaymentCountAggregateOutputType> | number
          }
        }
      }
      CashierReport: {
        payload: Prisma.$CashierReportPayload<ExtArgs>
        fields: Prisma.CashierReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashierReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashierReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          findFirst: {
            args: Prisma.CashierReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashierReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          findMany: {
            args: Prisma.CashierReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>[]
          }
          create: {
            args: Prisma.CashierReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          createMany: {
            args: Prisma.CashierReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashierReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>[]
          }
          delete: {
            args: Prisma.CashierReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          update: {
            args: Prisma.CashierReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          deleteMany: {
            args: Prisma.CashierReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashierReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashierReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>[]
          }
          upsert: {
            args: Prisma.CashierReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierReportPayload>
          }
          aggregate: {
            args: Prisma.CashierReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashierReport>
          }
          groupBy: {
            args: Prisma.CashierReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashierReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashierReportCountArgs<ExtArgs>
            result: $Utils.Optional<CashierReportCountAggregateOutputType> | number
          }
        }
      }
      CurrencyExchangeRate: {
        payload: Prisma.$CurrencyExchangeRatePayload<ExtArgs>
        fields: Prisma.CurrencyExchangeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyExchangeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyExchangeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          findFirst: {
            args: Prisma.CurrencyExchangeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyExchangeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          findMany: {
            args: Prisma.CurrencyExchangeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>[]
          }
          create: {
            args: Prisma.CurrencyExchangeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          createMany: {
            args: Prisma.CurrencyExchangeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyExchangeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>[]
          }
          delete: {
            args: Prisma.CurrencyExchangeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          update: {
            args: Prisma.CurrencyExchangeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          deleteMany: {
            args: Prisma.CurrencyExchangeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyExchangeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyExchangeRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>[]
          }
          upsert: {
            args: Prisma.CurrencyExchangeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyExchangeRatePayload>
          }
          aggregate: {
            args: Prisma.CurrencyExchangeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrencyExchangeRate>
          }
          groupBy: {
            args: Prisma.CurrencyExchangeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyExchangeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyExchangeRateCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyExchangeRateCountAggregateOutputType> | number
          }
        }
      }
      Bonus: {
        payload: Prisma.$BonusPayload<ExtArgs>
        fields: Prisma.BonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findFirst: {
            args: Prisma.BonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findMany: {
            args: Prisma.BonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          create: {
            args: Prisma.BonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          createMany: {
            args: Prisma.BonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          delete: {
            args: Prisma.BonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          update: {
            args: Prisma.BonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          deleteMany: {
            args: Prisma.BonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          upsert: {
            args: Prisma.BonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          aggregate: {
            args: Prisma.BonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonus>
          }
          groupBy: {
            args: Prisma.BonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BonusCountArgs<ExtArgs>
            result: $Utils.Optional<BonusCountAggregateOutputType> | number
          }
        }
      }
      TransactionBonusProduct: {
        payload: Prisma.$TransactionBonusProductPayload<ExtArgs>
        fields: Prisma.TransactionBonusProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionBonusProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionBonusProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          findFirst: {
            args: Prisma.TransactionBonusProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionBonusProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          findMany: {
            args: Prisma.TransactionBonusProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>[]
          }
          create: {
            args: Prisma.TransactionBonusProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          createMany: {
            args: Prisma.TransactionBonusProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionBonusProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>[]
          }
          delete: {
            args: Prisma.TransactionBonusProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          update: {
            args: Prisma.TransactionBonusProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          deleteMany: {
            args: Prisma.TransactionBonusProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionBonusProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionBonusProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>[]
          }
          upsert: {
            args: Prisma.TransactionBonusProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionBonusProductPayload>
          }
          aggregate: {
            args: Prisma.TransactionBonusProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionBonusProduct>
          }
          groupBy: {
            args: Prisma.TransactionBonusProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionBonusProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionBonusProductCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionBonusProductCountAggregateOutputType> | number
          }
        }
      }
      WorkSchedule: {
        payload: Prisma.$WorkSchedulePayload<ExtArgs>
        fields: Prisma.WorkScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          findFirst: {
            args: Prisma.WorkScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          findMany: {
            args: Prisma.WorkScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
          }
          create: {
            args: Prisma.WorkScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          createMany: {
            args: Prisma.WorkScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
          }
          delete: {
            args: Prisma.WorkScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          update: {
            args: Prisma.WorkScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          deleteMany: {
            args: Prisma.WorkScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
          }
          upsert: {
            args: Prisma.WorkScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
          }
          aggregate: {
            args: Prisma.WorkScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkSchedule>
          }
          groupBy: {
            args: Prisma.WorkScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkScheduleCountAggregateOutputType> | number
          }
        }
      }
      barcodeCounter: {
        payload: Prisma.$barcodeCounterPayload<ExtArgs>
        fields: Prisma.barcodeCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.barcodeCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.barcodeCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          findFirst: {
            args: Prisma.barcodeCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.barcodeCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          findMany: {
            args: Prisma.barcodeCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>[]
          }
          create: {
            args: Prisma.barcodeCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          createMany: {
            args: Prisma.barcodeCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.barcodeCounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>[]
          }
          delete: {
            args: Prisma.barcodeCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          update: {
            args: Prisma.barcodeCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          deleteMany: {
            args: Prisma.barcodeCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.barcodeCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.barcodeCounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>[]
          }
          upsert: {
            args: Prisma.barcodeCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodeCounterPayload>
          }
          aggregate: {
            args: Prisma.BarcodeCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarcodeCounter>
          }
          groupBy: {
            args: Prisma.barcodeCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarcodeCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.barcodeCounterCountArgs<ExtArgs>
            result: $Utils.Optional<BarcodeCounterCountAggregateOutputType> | number
          }
        }
      }
      FaceTemplate: {
        payload: Prisma.$FaceTemplatePayload<ExtArgs>
        fields: Prisma.FaceTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FaceTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FaceTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          findFirst: {
            args: Prisma.FaceTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FaceTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          findMany: {
            args: Prisma.FaceTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>[]
          }
          create: {
            args: Prisma.FaceTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          createMany: {
            args: Prisma.FaceTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FaceTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>[]
          }
          delete: {
            args: Prisma.FaceTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          update: {
            args: Prisma.FaceTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FaceTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FaceTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FaceTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>[]
          }
          upsert: {
            args: Prisma.FaceTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaceTemplatePayload>
          }
          aggregate: {
            args: Prisma.FaceTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaceTemplate>
          }
          groupBy: {
            args: Prisma.FaceTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaceTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FaceTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<FaceTemplateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    attendanceDay?: AttendanceDayOmit
    attendanceEvent?: AttendanceEventOmit
    branch?: BranchOmit
    user?: UserOmit
    userBranchAccess?: UserBranchAccessOmit
    userLocation?: UserLocationOmit
    category?: CategoryOmit
    product?: ProductOmit
    defectiveLog?: DefectiveLogOmit
    customer?: CustomerOmit
    transaction?: TransactionOmit
    transactionItem?: TransactionItemOmit
    productTransfer?: ProductTransferOmit
    paymentSchedule?: PaymentScheduleOmit
    paymentRepayment?: PaymentRepaymentOmit
    dailyRepayment?: DailyRepaymentOmit
    creditRepayment?: CreditRepaymentOmit
    cashierReport?: CashierReportOmit
    currencyExchangeRate?: CurrencyExchangeRateOmit
    bonus?: BonusOmit
    transactionBonusProduct?: TransactionBonusProductOmit
    workSchedule?: WorkScheduleOmit
    barcodeCounter?: barcodeCounterOmit
    faceTemplate?: FaceTemplateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AttendanceDayCountOutputType
   */

  export type AttendanceDayCountOutputType = {
    events: number
  }

  export type AttendanceDayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | AttendanceDayCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * AttendanceDayCountOutputType without action
   */
  export type AttendanceDayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDayCountOutputType
     */
    select?: AttendanceDayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendanceDayCountOutputType without action
   */
  export type AttendanceDayCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    products: number
    transactions: number
    toTransactions: number
    users: number
    allowedUsers: number
    categories: number
    fromTransfers: number
    toTransfers: number
    defectiveLogs: number
    exchangeRates: number
    cashierReports: number
    DailyRepayment: number
    CreditRepayment: number
    bonuses: number
    attendanceDays: number
    attendanceEvents: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BranchCountOutputTypeCountProductsArgs
    transactions?: boolean | BranchCountOutputTypeCountTransactionsArgs
    toTransactions?: boolean | BranchCountOutputTypeCountToTransactionsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    allowedUsers?: boolean | BranchCountOutputTypeCountAllowedUsersArgs
    categories?: boolean | BranchCountOutputTypeCountCategoriesArgs
    fromTransfers?: boolean | BranchCountOutputTypeCountFromTransfersArgs
    toTransfers?: boolean | BranchCountOutputTypeCountToTransfersArgs
    defectiveLogs?: boolean | BranchCountOutputTypeCountDefectiveLogsArgs
    exchangeRates?: boolean | BranchCountOutputTypeCountExchangeRatesArgs
    cashierReports?: boolean | BranchCountOutputTypeCountCashierReportsArgs
    DailyRepayment?: boolean | BranchCountOutputTypeCountDailyRepaymentArgs
    CreditRepayment?: boolean | BranchCountOutputTypeCountCreditRepaymentArgs
    bonuses?: boolean | BranchCountOutputTypeCountBonusesArgs
    attendanceDays?: boolean | BranchCountOutputTypeCountAttendanceDaysArgs
    attendanceEvents?: boolean | BranchCountOutputTypeCountAttendanceEventsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountToTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAllowedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBranchAccessWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountToTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDefectiveLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectiveLogWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountExchangeRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyExchangeRateWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCashierReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierReportWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDailyRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRepaymentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCreditRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditRepaymentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAttendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDayWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    allowedBranches: number
    createdTransactions: number
    soldTransactions: number
    initiatedTransfers: number
    approvedTransfers: number
    userLocations: number
    defectiveLogs: number
    PaymentSchedule: number
    PaymentRepayment: number
    dailyRepayments: number
    creditRepayments: number
    cashierReports: number
    exchangeRates: number
    bonuses: number
    createdBonuses: number
    attendanceDays: number
    attendanceEvents: number
    faceTemplates: number
    Transaction: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allowedBranches?: boolean | UserCountOutputTypeCountAllowedBranchesArgs
    createdTransactions?: boolean | UserCountOutputTypeCountCreatedTransactionsArgs
    soldTransactions?: boolean | UserCountOutputTypeCountSoldTransactionsArgs
    initiatedTransfers?: boolean | UserCountOutputTypeCountInitiatedTransfersArgs
    approvedTransfers?: boolean | UserCountOutputTypeCountApprovedTransfersArgs
    userLocations?: boolean | UserCountOutputTypeCountUserLocationsArgs
    defectiveLogs?: boolean | UserCountOutputTypeCountDefectiveLogsArgs
    PaymentSchedule?: boolean | UserCountOutputTypeCountPaymentScheduleArgs
    PaymentRepayment?: boolean | UserCountOutputTypeCountPaymentRepaymentArgs
    dailyRepayments?: boolean | UserCountOutputTypeCountDailyRepaymentsArgs
    creditRepayments?: boolean | UserCountOutputTypeCountCreditRepaymentsArgs
    cashierReports?: boolean | UserCountOutputTypeCountCashierReportsArgs
    exchangeRates?: boolean | UserCountOutputTypeCountExchangeRatesArgs
    bonuses?: boolean | UserCountOutputTypeCountBonusesArgs
    createdBonuses?: boolean | UserCountOutputTypeCountCreatedBonusesArgs
    attendanceDays?: boolean | UserCountOutputTypeCountAttendanceDaysArgs
    attendanceEvents?: boolean | UserCountOutputTypeCountAttendanceEventsArgs
    faceTemplates?: boolean | UserCountOutputTypeCountFaceTemplatesArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAllowedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBranchAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoldTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiatedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDefectiveLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectiveLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRepaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRepaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditRepaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashierReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExchangeRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyExchangeRateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFaceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaceTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    transactions: number
    DefectiveLog: number
    ProductTransfer: number
    bonusProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ProductCountOutputTypeCountTransactionsArgs
    DefectiveLog?: boolean | ProductCountOutputTypeCountDefectiveLogArgs
    ProductTransfer?: boolean | ProductCountOutputTypeCountProductTransferArgs
    bonusProducts?: boolean | ProductCountOutputTypeCountBonusProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountDefectiveLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectiveLogWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBonusProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionBonusProductWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    items: number
    paymentSchedules: number
    PaymentRepayment: number
    dailyRepayments: number
    creditRepayments: number
    bonusProducts: number
    bonuses: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransactionCountOutputTypeCountItemsArgs
    paymentSchedules?: boolean | TransactionCountOutputTypeCountPaymentSchedulesArgs
    PaymentRepayment?: boolean | TransactionCountOutputTypeCountPaymentRepaymentArgs
    dailyRepayments?: boolean | TransactionCountOutputTypeCountDailyRepaymentsArgs
    creditRepayments?: boolean | TransactionCountOutputTypeCountCreditRepaymentsArgs
    bonusProducts?: boolean | TransactionCountOutputTypeCountBonusProductsArgs
    bonuses?: boolean | TransactionCountOutputTypeCountBonusesArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountPaymentSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentScheduleWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountPaymentRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRepaymentWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountDailyRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRepaymentWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountCreditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditRepaymentWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountBonusProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionBonusProductWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
  }


  /**
   * Count Type PaymentScheduleCountOutputType
   */

  export type PaymentScheduleCountOutputType = {
    repayments: number
    creditRepayments: number
  }

  export type PaymentScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    repayments?: boolean | PaymentScheduleCountOutputTypeCountRepaymentsArgs
    creditRepayments?: boolean | PaymentScheduleCountOutputTypeCountCreditRepaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentScheduleCountOutputType without action
   */
  export type PaymentScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentScheduleCountOutputType
     */
    select?: PaymentScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentScheduleCountOutputType without action
   */
  export type PaymentScheduleCountOutputTypeCountRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRepaymentWhereInput
  }

  /**
   * PaymentScheduleCountOutputType without action
   */
  export type PaymentScheduleCountOutputTypeCountCreditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditRepaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AttendanceDay
   */

  export type AggregateAttendanceDay = {
    _count: AttendanceDayCountAggregateOutputType | null
    _avg: AttendanceDayAvgAggregateOutputType | null
    _sum: AttendanceDaySumAggregateOutputType | null
    _min: AttendanceDayMinAggregateOutputType | null
    _max: AttendanceDayMaxAggregateOutputType | null
  }

  export type AttendanceDayAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    totalMinutes: number | null
  }

  export type AttendanceDaySumAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    totalMinutes: number | null
  }

  export type AttendanceDayMinAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    totalMinutes: number | null
    status: $Enums.AttendanceStatus | null
    deviceId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceDayMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    totalMinutes: number | null
    status: $Enums.AttendanceStatus | null
    deviceId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceDayCountAggregateOutputType = {
    id: number
    userId: number
    branchId: number
    date: number
    checkInAt: number
    checkOutAt: number
    totalMinutes: number
    status: number
    deviceId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceDayAvgAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    totalMinutes?: true
  }

  export type AttendanceDaySumAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    totalMinutes?: true
  }

  export type AttendanceDayMinAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    totalMinutes?: true
    status?: true
    deviceId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceDayMaxAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    totalMinutes?: true
    status?: true
    deviceId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceDayCountAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    totalMinutes?: true
    status?: true
    deviceId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDay to aggregate.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceDays
    **/
    _count?: true | AttendanceDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceDayMaxAggregateInputType
  }

  export type GetAttendanceDayAggregateType<T extends AttendanceDayAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceDay[P]>
      : GetScalarType<T[P], AggregateAttendanceDay[P]>
  }




  export type AttendanceDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDayWhereInput
    orderBy?: AttendanceDayOrderByWithAggregationInput | AttendanceDayOrderByWithAggregationInput[]
    by: AttendanceDayScalarFieldEnum[] | AttendanceDayScalarFieldEnum
    having?: AttendanceDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceDayCountAggregateInputType | true
    _avg?: AttendanceDayAvgAggregateInputType
    _sum?: AttendanceDaySumAggregateInputType
    _min?: AttendanceDayMinAggregateInputType
    _max?: AttendanceDayMaxAggregateInputType
  }

  export type AttendanceDayGroupByOutputType = {
    id: number
    userId: number
    branchId: number | null
    date: Date
    checkInAt: Date | null
    checkOutAt: Date | null
    totalMinutes: number | null
    status: $Enums.AttendanceStatus | null
    deviceId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceDayCountAggregateOutputType | null
    _avg: AttendanceDayAvgAggregateOutputType | null
    _sum: AttendanceDaySumAggregateOutputType | null
    _min: AttendanceDayMinAggregateOutputType | null
    _max: AttendanceDayMaxAggregateOutputType | null
  }

  type GetAttendanceDayGroupByPayload<T extends AttendanceDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceDayGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceDayGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    totalMinutes?: boolean
    status?: boolean
    deviceId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
    events?: boolean | AttendanceDay$eventsArgs<ExtArgs>
    _count?: boolean | AttendanceDayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    totalMinutes?: boolean
    status?: boolean
    deviceId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    totalMinutes?: boolean
    status?: boolean
    deviceId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectScalar = {
    id?: boolean
    userId?: boolean
    branchId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    totalMinutes?: boolean
    status?: boolean
    deviceId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "branchId" | "date" | "checkInAt" | "checkOutAt" | "totalMinutes" | "status" | "deviceId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceDay"]>
  export type AttendanceDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
    events?: boolean | AttendanceDay$eventsArgs<ExtArgs>
    _count?: boolean | AttendanceDayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttendanceDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
  }
  export type AttendanceDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceDay$branchArgs<ExtArgs>
  }

  export type $AttendanceDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceDay"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      events: Prisma.$AttendanceEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      branchId: number | null
      date: Date
      checkInAt: Date | null
      checkOutAt: Date | null
      totalMinutes: number | null
      status: $Enums.AttendanceStatus | null
      deviceId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceDay"]>
    composites: {}
  }

  type AttendanceDayGetPayload<S extends boolean | null | undefined | AttendanceDayDefaultArgs> = $Result.GetResult<Prisma.$AttendanceDayPayload, S>

  type AttendanceDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceDayCountAggregateInputType | true
    }

  export interface AttendanceDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceDay'], meta: { name: 'AttendanceDay' } }
    /**
     * Find zero or one AttendanceDay that matches the filter.
     * @param {AttendanceDayFindUniqueArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceDayFindUniqueArgs>(args: SelectSubset<T, AttendanceDayFindUniqueArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceDayFindUniqueOrThrowArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceDayFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindFirstArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceDayFindFirstArgs>(args?: SelectSubset<T, AttendanceDayFindFirstArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindFirstOrThrowArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceDayFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceDays
     * const attendanceDays = await prisma.attendanceDay.findMany()
     * 
     * // Get first 10 AttendanceDays
     * const attendanceDays = await prisma.attendanceDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceDayWithIdOnly = await prisma.attendanceDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceDayFindManyArgs>(args?: SelectSubset<T, AttendanceDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceDay.
     * @param {AttendanceDayCreateArgs} args - Arguments to create a AttendanceDay.
     * @example
     * // Create one AttendanceDay
     * const AttendanceDay = await prisma.attendanceDay.create({
     *   data: {
     *     // ... data to create a AttendanceDay
     *   }
     * })
     * 
     */
    create<T extends AttendanceDayCreateArgs>(args: SelectSubset<T, AttendanceDayCreateArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceDays.
     * @param {AttendanceDayCreateManyArgs} args - Arguments to create many AttendanceDays.
     * @example
     * // Create many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceDayCreateManyArgs>(args?: SelectSubset<T, AttendanceDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceDays and returns the data saved in the database.
     * @param {AttendanceDayCreateManyAndReturnArgs} args - Arguments to create many AttendanceDays.
     * @example
     * // Create many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceDays and only return the `id`
     * const attendanceDayWithIdOnly = await prisma.attendanceDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceDayCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceDay.
     * @param {AttendanceDayDeleteArgs} args - Arguments to delete one AttendanceDay.
     * @example
     * // Delete one AttendanceDay
     * const AttendanceDay = await prisma.attendanceDay.delete({
     *   where: {
     *     // ... filter to delete one AttendanceDay
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDayDeleteArgs>(args: SelectSubset<T, AttendanceDayDeleteArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceDay.
     * @param {AttendanceDayUpdateArgs} args - Arguments to update one AttendanceDay.
     * @example
     * // Update one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceDayUpdateArgs>(args: SelectSubset<T, AttendanceDayUpdateArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceDays.
     * @param {AttendanceDayDeleteManyArgs} args - Arguments to filter AttendanceDays to delete.
     * @example
     * // Delete a few AttendanceDays
     * const { count } = await prisma.attendanceDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDayDeleteManyArgs>(args?: SelectSubset<T, AttendanceDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceDayUpdateManyArgs>(args: SelectSubset<T, AttendanceDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDays and returns the data updated in the database.
     * @param {AttendanceDayUpdateManyAndReturnArgs} args - Arguments to update many AttendanceDays.
     * @example
     * // Update many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceDays and only return the `id`
     * const attendanceDayWithIdOnly = await prisma.attendanceDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceDayUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceDay.
     * @param {AttendanceDayUpsertArgs} args - Arguments to update or create a AttendanceDay.
     * @example
     * // Update or create a AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.upsert({
     *   create: {
     *     // ... data to create a AttendanceDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceDay we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceDayUpsertArgs>(args: SelectSubset<T, AttendanceDayUpsertArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayCountArgs} args - Arguments to filter AttendanceDays to count.
     * @example
     * // Count the number of AttendanceDays
     * const count = await prisma.attendanceDay.count({
     *   where: {
     *     // ... the filter for the AttendanceDays we want to count
     *   }
     * })
    **/
    count<T extends AttendanceDayCountArgs>(
      args?: Subset<T, AttendanceDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceDayAggregateArgs>(args: Subset<T, AttendanceDayAggregateArgs>): Prisma.PrismaPromise<GetAttendanceDayAggregateType<T>>

    /**
     * Group by AttendanceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceDayGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceDay model
   */
  readonly fields: AttendanceDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends AttendanceDay$branchArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDay$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends AttendanceDay$eventsArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDay$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceDay model
   */
  interface AttendanceDayFieldRefs {
    readonly id: FieldRef<"AttendanceDay", 'Int'>
    readonly userId: FieldRef<"AttendanceDay", 'Int'>
    readonly branchId: FieldRef<"AttendanceDay", 'Int'>
    readonly date: FieldRef<"AttendanceDay", 'DateTime'>
    readonly checkInAt: FieldRef<"AttendanceDay", 'DateTime'>
    readonly checkOutAt: FieldRef<"AttendanceDay", 'DateTime'>
    readonly totalMinutes: FieldRef<"AttendanceDay", 'Int'>
    readonly status: FieldRef<"AttendanceDay", 'AttendanceStatus'>
    readonly deviceId: FieldRef<"AttendanceDay", 'String'>
    readonly notes: FieldRef<"AttendanceDay", 'String'>
    readonly createdAt: FieldRef<"AttendanceDay", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceDay findUnique
   */
  export type AttendanceDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay findUniqueOrThrow
   */
  export type AttendanceDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay findFirst
   */
  export type AttendanceDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDays.
     */
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay findFirstOrThrow
   */
  export type AttendanceDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDays.
     */
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay findMany
   */
  export type AttendanceDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDays to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay create
   */
  export type AttendanceDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceDay.
     */
    data: XOR<AttendanceDayCreateInput, AttendanceDayUncheckedCreateInput>
  }

  /**
   * AttendanceDay createMany
   */
  export type AttendanceDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceDays.
     */
    data: AttendanceDayCreateManyInput | AttendanceDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceDay createManyAndReturn
   */
  export type AttendanceDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceDays.
     */
    data: AttendanceDayCreateManyInput | AttendanceDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDay update
   */
  export type AttendanceDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceDay.
     */
    data: XOR<AttendanceDayUpdateInput, AttendanceDayUncheckedUpdateInput>
    /**
     * Choose, which AttendanceDay to update.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay updateMany
   */
  export type AttendanceDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceDays.
     */
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDays to update
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to update.
     */
    limit?: number
  }

  /**
   * AttendanceDay updateManyAndReturn
   */
  export type AttendanceDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceDays.
     */
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDays to update
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDay upsert
   */
  export type AttendanceDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceDay to update in case it exists.
     */
    where: AttendanceDayWhereUniqueInput
    /**
     * In case the AttendanceDay found by the `where` argument doesn't exist, create a new AttendanceDay with this data.
     */
    create: XOR<AttendanceDayCreateInput, AttendanceDayUncheckedCreateInput>
    /**
     * In case the AttendanceDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceDayUpdateInput, AttendanceDayUncheckedUpdateInput>
  }

  /**
   * AttendanceDay delete
   */
  export type AttendanceDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter which AttendanceDay to delete.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay deleteMany
   */
  export type AttendanceDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDays to delete
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to delete.
     */
    limit?: number
  }

  /**
   * AttendanceDay.branch
   */
  export type AttendanceDay$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * AttendanceDay.events
   */
  export type AttendanceDay$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceDay without action
   */
  export type AttendanceDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceEvent
   */

  export type AggregateAttendanceEvent = {
    _count: AttendanceEventCountAggregateOutputType | null
    _avg: AttendanceEventAvgAggregateOutputType | null
    _sum: AttendanceEventSumAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  export type AttendanceEventAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    dayId: number | null
    similarity: number | null
  }

  export type AttendanceEventSumAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    dayId: number | null
    similarity: number | null
  }

  export type AttendanceEventMinAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    dayId: number | null
    eventType: $Enums.AttendanceEventType | null
    occurredAt: Date | null
    deviceId: string | null
    similarity: number | null
    createdAt: Date | null
  }

  export type AttendanceEventMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    dayId: number | null
    eventType: $Enums.AttendanceEventType | null
    occurredAt: Date | null
    deviceId: string | null
    similarity: number | null
    createdAt: Date | null
  }

  export type AttendanceEventCountAggregateOutputType = {
    id: number
    userId: number
    branchId: number
    dayId: number
    eventType: number
    occurredAt: number
    deviceId: number
    similarity: number
    payload: number
    createdAt: number
    _all: number
  }


  export type AttendanceEventAvgAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    dayId?: true
    similarity?: true
  }

  export type AttendanceEventSumAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    dayId?: true
    similarity?: true
  }

  export type AttendanceEventMinAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    dayId?: true
    eventType?: true
    occurredAt?: true
    deviceId?: true
    similarity?: true
    createdAt?: true
  }

  export type AttendanceEventMaxAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    dayId?: true
    eventType?: true
    occurredAt?: true
    deviceId?: true
    similarity?: true
    createdAt?: true
  }

  export type AttendanceEventCountAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    dayId?: true
    eventType?: true
    occurredAt?: true
    deviceId?: true
    similarity?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvent to aggregate.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceEvents
    **/
    _count?: true | AttendanceEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type GetAttendanceEventAggregateType<T extends AttendanceEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceEvent[P]>
      : GetScalarType<T[P], AggregateAttendanceEvent[P]>
  }




  export type AttendanceEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithAggregationInput | AttendanceEventOrderByWithAggregationInput[]
    by: AttendanceEventScalarFieldEnum[] | AttendanceEventScalarFieldEnum
    having?: AttendanceEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceEventCountAggregateInputType | true
    _avg?: AttendanceEventAvgAggregateInputType
    _sum?: AttendanceEventSumAggregateInputType
    _min?: AttendanceEventMinAggregateInputType
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type AttendanceEventGroupByOutputType = {
    id: number
    userId: number
    branchId: number | null
    dayId: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt: Date
    deviceId: string | null
    similarity: number | null
    payload: JsonValue | null
    createdAt: Date
    _count: AttendanceEventCountAggregateOutputType | null
    _avg: AttendanceEventAvgAggregateOutputType | null
    _sum: AttendanceEventSumAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  type GetAttendanceEventGroupByPayload<T extends AttendanceEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    dayId?: boolean
    eventType?: boolean
    occurredAt?: boolean
    deviceId?: boolean
    similarity?: boolean
    payload?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    dayId?: boolean
    eventType?: boolean
    occurredAt?: boolean
    deviceId?: boolean
    similarity?: boolean
    payload?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    dayId?: boolean
    eventType?: boolean
    occurredAt?: boolean
    deviceId?: boolean
    similarity?: boolean
    payload?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectScalar = {
    id?: boolean
    userId?: boolean
    branchId?: boolean
    dayId?: boolean
    eventType?: boolean
    occurredAt?: boolean
    deviceId?: boolean
    similarity?: boolean
    payload?: boolean
    createdAt?: boolean
  }

  export type AttendanceEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "branchId" | "dayId" | "eventType" | "occurredAt" | "deviceId" | "similarity" | "payload" | "createdAt", ExtArgs["result"]["attendanceEvent"]>
  export type AttendanceEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }
  export type AttendanceEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }
  export type AttendanceEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AttendanceEvent$branchArgs<ExtArgs>
    day?: boolean | AttendanceEvent$dayArgs<ExtArgs>
  }

  export type $AttendanceEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      day: Prisma.$AttendanceDayPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      branchId: number | null
      dayId: number | null
      eventType: $Enums.AttendanceEventType
      occurredAt: Date
      deviceId: string | null
      similarity: number | null
      payload: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["attendanceEvent"]>
    composites: {}
  }

  type AttendanceEventGetPayload<S extends boolean | null | undefined | AttendanceEventDefaultArgs> = $Result.GetResult<Prisma.$AttendanceEventPayload, S>

  type AttendanceEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceEventCountAggregateInputType | true
    }

  export interface AttendanceEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceEvent'], meta: { name: 'AttendanceEvent' } }
    /**
     * Find zero or one AttendanceEvent that matches the filter.
     * @param {AttendanceEventFindUniqueArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceEventFindUniqueArgs>(args: SelectSubset<T, AttendanceEventFindUniqueArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceEventFindUniqueOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceEventFindFirstArgs>(args?: SelectSubset<T, AttendanceEventFindFirstArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany()
     * 
     * // Get first 10 AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceEventFindManyArgs>(args?: SelectSubset<T, AttendanceEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceEvent.
     * @param {AttendanceEventCreateArgs} args - Arguments to create a AttendanceEvent.
     * @example
     * // Create one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.create({
     *   data: {
     *     // ... data to create a AttendanceEvent
     *   }
     * })
     * 
     */
    create<T extends AttendanceEventCreateArgs>(args: SelectSubset<T, AttendanceEventCreateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceEvents.
     * @param {AttendanceEventCreateManyArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceEventCreateManyArgs>(args?: SelectSubset<T, AttendanceEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceEvents and returns the data saved in the database.
     * @param {AttendanceEventCreateManyAndReturnArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceEvent.
     * @param {AttendanceEventDeleteArgs} args - Arguments to delete one AttendanceEvent.
     * @example
     * // Delete one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.delete({
     *   where: {
     *     // ... filter to delete one AttendanceEvent
     *   }
     * })
     * 
     */
    delete<T extends AttendanceEventDeleteArgs>(args: SelectSubset<T, AttendanceEventDeleteArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceEvent.
     * @param {AttendanceEventUpdateArgs} args - Arguments to update one AttendanceEvent.
     * @example
     * // Update one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceEventUpdateArgs>(args: SelectSubset<T, AttendanceEventUpdateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceEvents.
     * @param {AttendanceEventDeleteManyArgs} args - Arguments to filter AttendanceEvents to delete.
     * @example
     * // Delete a few AttendanceEvents
     * const { count } = await prisma.attendanceEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceEventDeleteManyArgs>(args?: SelectSubset<T, AttendanceEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceEventUpdateManyArgs>(args: SelectSubset<T, AttendanceEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents and returns the data updated in the database.
     * @param {AttendanceEventUpdateManyAndReturnArgs} args - Arguments to update many AttendanceEvents.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceEvent.
     * @param {AttendanceEventUpsertArgs} args - Arguments to update or create a AttendanceEvent.
     * @example
     * // Update or create a AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.upsert({
     *   create: {
     *     // ... data to create a AttendanceEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceEvent we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceEventUpsertArgs>(args: SelectSubset<T, AttendanceEventUpsertArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventCountArgs} args - Arguments to filter AttendanceEvents to count.
     * @example
     * // Count the number of AttendanceEvents
     * const count = await prisma.attendanceEvent.count({
     *   where: {
     *     // ... the filter for the AttendanceEvents we want to count
     *   }
     * })
    **/
    count<T extends AttendanceEventCountArgs>(
      args?: Subset<T, AttendanceEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceEventAggregateArgs>(args: Subset<T, AttendanceEventAggregateArgs>): Prisma.PrismaPromise<GetAttendanceEventAggregateType<T>>

    /**
     * Group by AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceEventGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceEvent model
   */
  readonly fields: AttendanceEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends AttendanceEvent$branchArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    day<T extends AttendanceEvent$dayArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$dayArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceEvent model
   */
  interface AttendanceEventFieldRefs {
    readonly id: FieldRef<"AttendanceEvent", 'Int'>
    readonly userId: FieldRef<"AttendanceEvent", 'Int'>
    readonly branchId: FieldRef<"AttendanceEvent", 'Int'>
    readonly dayId: FieldRef<"AttendanceEvent", 'Int'>
    readonly eventType: FieldRef<"AttendanceEvent", 'AttendanceEventType'>
    readonly occurredAt: FieldRef<"AttendanceEvent", 'DateTime'>
    readonly deviceId: FieldRef<"AttendanceEvent", 'String'>
    readonly similarity: FieldRef<"AttendanceEvent", 'Float'>
    readonly payload: FieldRef<"AttendanceEvent", 'Json'>
    readonly createdAt: FieldRef<"AttendanceEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceEvent findUnique
   */
  export type AttendanceEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findUniqueOrThrow
   */
  export type AttendanceEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findFirst
   */
  export type AttendanceEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findFirstOrThrow
   */
  export type AttendanceEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findMany
   */
  export type AttendanceEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvents to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent create
   */
  export type AttendanceEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceEvent.
     */
    data: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
  }

  /**
   * AttendanceEvent createMany
   */
  export type AttendanceEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceEvent createManyAndReturn
   */
  export type AttendanceEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent update
   */
  export type AttendanceEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceEvent.
     */
    data: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
    /**
     * Choose, which AttendanceEvent to update.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent updateMany
   */
  export type AttendanceEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
  }

  /**
   * AttendanceEvent updateManyAndReturn
   */
  export type AttendanceEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent upsert
   */
  export type AttendanceEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceEvent to update in case it exists.
     */
    where: AttendanceEventWhereUniqueInput
    /**
     * In case the AttendanceEvent found by the `where` argument doesn't exist, create a new AttendanceEvent with this data.
     */
    create: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
    /**
     * In case the AttendanceEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
  }

  /**
   * AttendanceEvent delete
   */
  export type AttendanceEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter which AttendanceEvent to delete.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent deleteMany
   */
  export type AttendanceEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvents to delete
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to delete.
     */
    limit?: number
  }

  /**
   * AttendanceEvent.branch
   */
  export type AttendanceEvent$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * AttendanceEvent.day
   */
  export type AttendanceEvent$dayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    where?: AttendanceDayWhereInput
  }

  /**
   * AttendanceEvent without action
   */
  export type AttendanceEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
    cashBalance: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
    cashBalance: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    type: $Enums.BranchType | null
    cashBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    status: $Enums.BranchStatus | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    type: $Enums.BranchType | null
    cashBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    status: $Enums.BranchStatus | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    type: number
    cashBalance: number
    createdAt: number
    updatedAt: number
    phoneNumber: number
    status: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
    cashBalance?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
    cashBalance?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    type?: true
    cashBalance?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    status?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    type?: true
    cashBalance?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    status?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    type?: true
    cashBalance?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    status?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    address: string | null
    type: $Enums.BranchType
    cashBalance: number
    createdAt: Date
    updatedAt: Date
    phoneNumber: string | null
    status: $Enums.BranchStatus
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    cashBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    status?: boolean
    products?: boolean | Branch$productsArgs<ExtArgs>
    transactions?: boolean | Branch$transactionsArgs<ExtArgs>
    toTransactions?: boolean | Branch$toTransactionsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    allowedUsers?: boolean | Branch$allowedUsersArgs<ExtArgs>
    categories?: boolean | Branch$categoriesArgs<ExtArgs>
    fromTransfers?: boolean | Branch$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Branch$toTransfersArgs<ExtArgs>
    defectiveLogs?: boolean | Branch$defectiveLogsArgs<ExtArgs>
    exchangeRates?: boolean | Branch$exchangeRatesArgs<ExtArgs>
    cashierReports?: boolean | Branch$cashierReportsArgs<ExtArgs>
    DailyRepayment?: boolean | Branch$DailyRepaymentArgs<ExtArgs>
    CreditRepayment?: boolean | Branch$CreditRepaymentArgs<ExtArgs>
    bonuses?: boolean | Branch$bonusesArgs<ExtArgs>
    attendanceDays?: boolean | Branch$attendanceDaysArgs<ExtArgs>
    attendanceEvents?: boolean | Branch$attendanceEventsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    cashBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    status?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    cashBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    status?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    cashBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    status?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "type" | "cashBalance" | "createdAt" | "updatedAt" | "phoneNumber" | "status", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Branch$productsArgs<ExtArgs>
    transactions?: boolean | Branch$transactionsArgs<ExtArgs>
    toTransactions?: boolean | Branch$toTransactionsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    allowedUsers?: boolean | Branch$allowedUsersArgs<ExtArgs>
    categories?: boolean | Branch$categoriesArgs<ExtArgs>
    fromTransfers?: boolean | Branch$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Branch$toTransfersArgs<ExtArgs>
    defectiveLogs?: boolean | Branch$defectiveLogsArgs<ExtArgs>
    exchangeRates?: boolean | Branch$exchangeRatesArgs<ExtArgs>
    cashierReports?: boolean | Branch$cashierReportsArgs<ExtArgs>
    DailyRepayment?: boolean | Branch$DailyRepaymentArgs<ExtArgs>
    CreditRepayment?: boolean | Branch$CreditRepaymentArgs<ExtArgs>
    bonuses?: boolean | Branch$bonusesArgs<ExtArgs>
    attendanceDays?: boolean | Branch$attendanceDaysArgs<ExtArgs>
    attendanceEvents?: boolean | Branch$attendanceEventsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      toTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      allowedUsers: Prisma.$UserBranchAccessPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      fromTransfers: Prisma.$ProductTransferPayload<ExtArgs>[]
      toTransfers: Prisma.$ProductTransferPayload<ExtArgs>[]
      defectiveLogs: Prisma.$DefectiveLogPayload<ExtArgs>[]
      exchangeRates: Prisma.$CurrencyExchangeRatePayload<ExtArgs>[]
      cashierReports: Prisma.$CashierReportPayload<ExtArgs>[]
      DailyRepayment: Prisma.$DailyRepaymentPayload<ExtArgs>[]
      CreditRepayment: Prisma.$CreditRepaymentPayload<ExtArgs>[]
      bonuses: Prisma.$BonusPayload<ExtArgs>[]
      attendanceDays: Prisma.$AttendanceDayPayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      type: $Enums.BranchType
      cashBalance: number
      createdAt: Date
      updatedAt: Date
      phoneNumber: string | null
      status: $Enums.BranchStatus
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Branch$productsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Branch$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toTransactions<T extends Branch$toTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$toTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allowedUsers<T extends Branch$allowedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$allowedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Branch$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fromTransfers<T extends Branch$fromTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$fromTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toTransfers<T extends Branch$toTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$toTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defectiveLogs<T extends Branch$defectiveLogsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$defectiveLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeRates<T extends Branch$exchangeRatesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$exchangeRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashierReports<T extends Branch$cashierReportsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$cashierReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DailyRepayment<T extends Branch$DailyRepaymentArgs<ExtArgs> = {}>(args?: Subset<T, Branch$DailyRepaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CreditRepayment<T extends Branch$CreditRepaymentArgs<ExtArgs> = {}>(args?: Subset<T, Branch$CreditRepaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonuses<T extends Branch$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceDays<T extends Branch$attendanceDaysArgs<ExtArgs> = {}>(args?: Subset<T, Branch$attendanceDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends Branch$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly type: FieldRef<"Branch", 'BranchType'>
    readonly cashBalance: FieldRef<"Branch", 'Float'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
    readonly phoneNumber: FieldRef<"Branch", 'String'>
    readonly status: FieldRef<"Branch", 'BranchStatus'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.products
   */
  export type Branch$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Branch.transactions
   */
  export type Branch$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Branch.toTransactions
   */
  export type Branch$toTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.allowedUsers
   */
  export type Branch$allowedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    where?: UserBranchAccessWhereInput
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    cursor?: UserBranchAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBranchAccessScalarFieldEnum | UserBranchAccessScalarFieldEnum[]
  }

  /**
   * Branch.categories
   */
  export type Branch$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Branch.fromTransfers
   */
  export type Branch$fromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    cursor?: ProductTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * Branch.toTransfers
   */
  export type Branch$toTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    cursor?: ProductTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * Branch.defectiveLogs
   */
  export type Branch$defectiveLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    where?: DefectiveLogWhereInput
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    cursor?: DefectiveLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * Branch.exchangeRates
   */
  export type Branch$exchangeRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    where?: CurrencyExchangeRateWhereInput
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    cursor?: CurrencyExchangeRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrencyExchangeRateScalarFieldEnum | CurrencyExchangeRateScalarFieldEnum[]
  }

  /**
   * Branch.cashierReports
   */
  export type Branch$cashierReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    where?: CashierReportWhereInput
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    cursor?: CashierReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashierReportScalarFieldEnum | CashierReportScalarFieldEnum[]
  }

  /**
   * Branch.DailyRepayment
   */
  export type Branch$DailyRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    where?: DailyRepaymentWhereInput
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    cursor?: DailyRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * Branch.CreditRepayment
   */
  export type Branch$CreditRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    where?: CreditRepaymentWhereInput
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    cursor?: CreditRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * Branch.bonuses
   */
  export type Branch$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    cursor?: BonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Branch.attendanceDays
   */
  export type Branch$attendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    where?: AttendanceDayWhereInput
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    cursor?: AttendanceDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * Branch.attendanceEvents
   */
  export type Branch$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.UserStatus | null
    workStartTime: string | null
    workEndTime: string | null
    workShift: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.UserStatus | null
    workStartTime: string | null
    workEndTime: string | null
    workShift: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phone: number
    username: number
    password: number
    role: number
    branchId: number
    createdAt: number
    updatedAt: number
    status: number
    workStartTime: number
    workEndTime: number
    workShift: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    workStartTime?: true
    workEndTime?: true
    workShift?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    workStartTime?: true
    workEndTime?: true
    workShift?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    workStartTime?: true
    workEndTime?: true
    workShift?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string | null
    lastName: string | null
    phone: string | null
    username: string
    password: string | null
    role: $Enums.UserRole
    branchId: number | null
    createdAt: Date
    updatedAt: Date
    status: $Enums.UserStatus
    workStartTime: string | null
    workEndTime: string | null
    workShift: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    workShift?: boolean
    allowedBranches?: boolean | User$allowedBranchesArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    soldTransactions?: boolean | User$soldTransactionsArgs<ExtArgs>
    initiatedTransfers?: boolean | User$initiatedTransfersArgs<ExtArgs>
    approvedTransfers?: boolean | User$approvedTransfersArgs<ExtArgs>
    userLocations?: boolean | User$userLocationsArgs<ExtArgs>
    defectiveLogs?: boolean | User$defectiveLogsArgs<ExtArgs>
    PaymentSchedule?: boolean | User$PaymentScheduleArgs<ExtArgs>
    PaymentRepayment?: boolean | User$PaymentRepaymentArgs<ExtArgs>
    dailyRepayments?: boolean | User$dailyRepaymentsArgs<ExtArgs>
    creditRepayments?: boolean | User$creditRepaymentsArgs<ExtArgs>
    cashierReports?: boolean | User$cashierReportsArgs<ExtArgs>
    exchangeRates?: boolean | User$exchangeRatesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    createdBonuses?: boolean | User$createdBonusesArgs<ExtArgs>
    attendanceDays?: boolean | User$attendanceDaysArgs<ExtArgs>
    attendanceEvents?: boolean | User$attendanceEventsArgs<ExtArgs>
    faceTemplates?: boolean | User$faceTemplatesArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    workShift?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    workShift?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    workShift?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "phone" | "username" | "password" | "role" | "branchId" | "createdAt" | "updatedAt" | "status" | "workStartTime" | "workEndTime" | "workShift", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allowedBranches?: boolean | User$allowedBranchesArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    soldTransactions?: boolean | User$soldTransactionsArgs<ExtArgs>
    initiatedTransfers?: boolean | User$initiatedTransfersArgs<ExtArgs>
    approvedTransfers?: boolean | User$approvedTransfersArgs<ExtArgs>
    userLocations?: boolean | User$userLocationsArgs<ExtArgs>
    defectiveLogs?: boolean | User$defectiveLogsArgs<ExtArgs>
    PaymentSchedule?: boolean | User$PaymentScheduleArgs<ExtArgs>
    PaymentRepayment?: boolean | User$PaymentRepaymentArgs<ExtArgs>
    dailyRepayments?: boolean | User$dailyRepaymentsArgs<ExtArgs>
    creditRepayments?: boolean | User$creditRepaymentsArgs<ExtArgs>
    cashierReports?: boolean | User$cashierReportsArgs<ExtArgs>
    exchangeRates?: boolean | User$exchangeRatesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    createdBonuses?: boolean | User$createdBonusesArgs<ExtArgs>
    attendanceDays?: boolean | User$attendanceDaysArgs<ExtArgs>
    attendanceEvents?: boolean | User$attendanceEventsArgs<ExtArgs>
    faceTemplates?: boolean | User$faceTemplatesArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      allowedBranches: Prisma.$UserBranchAccessPayload<ExtArgs>[]
      branch: Prisma.$BranchPayload<ExtArgs> | null
      createdTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      soldTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      initiatedTransfers: Prisma.$ProductTransferPayload<ExtArgs>[]
      approvedTransfers: Prisma.$ProductTransferPayload<ExtArgs>[]
      userLocations: Prisma.$UserLocationPayload<ExtArgs>[]
      defectiveLogs: Prisma.$DefectiveLogPayload<ExtArgs>[]
      PaymentSchedule: Prisma.$PaymentSchedulePayload<ExtArgs>[]
      PaymentRepayment: Prisma.$PaymentRepaymentPayload<ExtArgs>[]
      dailyRepayments: Prisma.$DailyRepaymentPayload<ExtArgs>[]
      creditRepayments: Prisma.$CreditRepaymentPayload<ExtArgs>[]
      cashierReports: Prisma.$CashierReportPayload<ExtArgs>[]
      exchangeRates: Prisma.$CurrencyExchangeRatePayload<ExtArgs>[]
      bonuses: Prisma.$BonusPayload<ExtArgs>[]
      createdBonuses: Prisma.$BonusPayload<ExtArgs>[]
      attendanceDays: Prisma.$AttendanceDayPayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      faceTemplates: Prisma.$FaceTemplatePayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string | null
      lastName: string | null
      phone: string | null
      username: string
      password: string | null
      role: $Enums.UserRole
      branchId: number | null
      createdAt: Date
      updatedAt: Date
      status: $Enums.UserStatus
      workStartTime: string | null
      workEndTime: string | null
      workShift: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    allowedBranches<T extends User$allowedBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$allowedBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdTransactions<T extends User$createdTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soldTransactions<T extends User$soldTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$soldTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    initiatedTransfers<T extends User$initiatedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$initiatedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedTransfers<T extends User$approvedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLocations<T extends User$userLocationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defectiveLogs<T extends User$defectiveLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$defectiveLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PaymentSchedule<T extends User$PaymentScheduleArgs<ExtArgs> = {}>(args?: Subset<T, User$PaymentScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PaymentRepayment<T extends User$PaymentRepaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$PaymentRepaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyRepayments<T extends User$dailyRepaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyRepaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditRepayments<T extends User$creditRepaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$creditRepaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashierReports<T extends User$cashierReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashierReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeRates<T extends User$exchangeRatesArgs<ExtArgs> = {}>(args?: Subset<T, User$exchangeRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonuses<T extends User$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBonuses<T extends User$createdBonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceDays<T extends User$attendanceDaysArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends User$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faceTemplates<T extends User$faceTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$faceTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly workStartTime: FieldRef<"User", 'String'>
    readonly workEndTime: FieldRef<"User", 'String'>
    readonly workShift: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.allowedBranches
   */
  export type User$allowedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    where?: UserBranchAccessWhereInput
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    cursor?: UserBranchAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBranchAccessScalarFieldEnum | UserBranchAccessScalarFieldEnum[]
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.createdTransactions
   */
  export type User$createdTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.soldTransactions
   */
  export type User$soldTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.initiatedTransfers
   */
  export type User$initiatedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    cursor?: ProductTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * User.approvedTransfers
   */
  export type User$approvedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    cursor?: ProductTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * User.userLocations
   */
  export type User$userLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    where?: UserLocationWhereInput
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    cursor?: UserLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * User.defectiveLogs
   */
  export type User$defectiveLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    where?: DefectiveLogWhereInput
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    cursor?: DefectiveLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * User.PaymentSchedule
   */
  export type User$PaymentScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    where?: PaymentScheduleWhereInput
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    cursor?: PaymentScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScheduleScalarFieldEnum | PaymentScheduleScalarFieldEnum[]
  }

  /**
   * User.PaymentRepayment
   */
  export type User$PaymentRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    where?: PaymentRepaymentWhereInput
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    cursor?: PaymentRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * User.dailyRepayments
   */
  export type User$dailyRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    where?: DailyRepaymentWhereInput
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    cursor?: DailyRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * User.creditRepayments
   */
  export type User$creditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    where?: CreditRepaymentWhereInput
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    cursor?: CreditRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * User.cashierReports
   */
  export type User$cashierReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    where?: CashierReportWhereInput
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    cursor?: CashierReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashierReportScalarFieldEnum | CashierReportScalarFieldEnum[]
  }

  /**
   * User.exchangeRates
   */
  export type User$exchangeRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    where?: CurrencyExchangeRateWhereInput
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    cursor?: CurrencyExchangeRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrencyExchangeRateScalarFieldEnum | CurrencyExchangeRateScalarFieldEnum[]
  }

  /**
   * User.bonuses
   */
  export type User$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    cursor?: BonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * User.createdBonuses
   */
  export type User$createdBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    cursor?: BonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * User.attendanceDays
   */
  export type User$attendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    where?: AttendanceDayWhereInput
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    cursor?: AttendanceDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * User.attendanceEvents
   */
  export type User$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * User.faceTemplates
   */
  export type User$faceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    where?: FaceTemplateWhereInput
    orderBy?: FaceTemplateOrderByWithRelationInput | FaceTemplateOrderByWithRelationInput[]
    cursor?: FaceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaceTemplateScalarFieldEnum | FaceTemplateScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserBranchAccess
   */

  export type AggregateUserBranchAccess = {
    _count: UserBranchAccessCountAggregateOutputType | null
    _avg: UserBranchAccessAvgAggregateOutputType | null
    _sum: UserBranchAccessSumAggregateOutputType | null
    _min: UserBranchAccessMinAggregateOutputType | null
    _max: UserBranchAccessMaxAggregateOutputType | null
  }

  export type UserBranchAccessAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
  }

  export type UserBranchAccessSumAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
  }

  export type UserBranchAccessMinAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBranchAccessMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBranchAccessCountAggregateOutputType = {
    id: number
    userId: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBranchAccessAvgAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
  }

  export type UserBranchAccessSumAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
  }

  export type UserBranchAccessMinAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBranchAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBranchAccessCountAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBranchAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBranchAccess to aggregate.
     */
    where?: UserBranchAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBranchAccesses to fetch.
     */
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBranchAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBranchAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBranchAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBranchAccesses
    **/
    _count?: true | UserBranchAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBranchAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBranchAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBranchAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBranchAccessMaxAggregateInputType
  }

  export type GetUserBranchAccessAggregateType<T extends UserBranchAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBranchAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBranchAccess[P]>
      : GetScalarType<T[P], AggregateUserBranchAccess[P]>
  }




  export type UserBranchAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBranchAccessWhereInput
    orderBy?: UserBranchAccessOrderByWithAggregationInput | UserBranchAccessOrderByWithAggregationInput[]
    by: UserBranchAccessScalarFieldEnum[] | UserBranchAccessScalarFieldEnum
    having?: UserBranchAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBranchAccessCountAggregateInputType | true
    _avg?: UserBranchAccessAvgAggregateInputType
    _sum?: UserBranchAccessSumAggregateInputType
    _min?: UserBranchAccessMinAggregateInputType
    _max?: UserBranchAccessMaxAggregateInputType
  }

  export type UserBranchAccessGroupByOutputType = {
    id: number
    userId: number
    branchId: number
    createdAt: Date
    updatedAt: Date
    _count: UserBranchAccessCountAggregateOutputType | null
    _avg: UserBranchAccessAvgAggregateOutputType | null
    _sum: UserBranchAccessSumAggregateOutputType | null
    _min: UserBranchAccessMinAggregateOutputType | null
    _max: UserBranchAccessMaxAggregateOutputType | null
  }

  type GetUserBranchAccessGroupByPayload<T extends UserBranchAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBranchAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBranchAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBranchAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserBranchAccessGroupByOutputType[P]>
        }
      >
    >


  export type UserBranchAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBranchAccess"]>

  export type UserBranchAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBranchAccess"]>

  export type UserBranchAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBranchAccess"]>

  export type UserBranchAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBranchAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["userBranchAccess"]>
  export type UserBranchAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type UserBranchAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type UserBranchAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $UserBranchAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBranchAccess"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      branchId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userBranchAccess"]>
    composites: {}
  }

  type UserBranchAccessGetPayload<S extends boolean | null | undefined | UserBranchAccessDefaultArgs> = $Result.GetResult<Prisma.$UserBranchAccessPayload, S>

  type UserBranchAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBranchAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBranchAccessCountAggregateInputType | true
    }

  export interface UserBranchAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBranchAccess'], meta: { name: 'UserBranchAccess' } }
    /**
     * Find zero or one UserBranchAccess that matches the filter.
     * @param {UserBranchAccessFindUniqueArgs} args - Arguments to find a UserBranchAccess
     * @example
     * // Get one UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBranchAccessFindUniqueArgs>(args: SelectSubset<T, UserBranchAccessFindUniqueArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBranchAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBranchAccessFindUniqueOrThrowArgs} args - Arguments to find a UserBranchAccess
     * @example
     * // Get one UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBranchAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBranchAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBranchAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessFindFirstArgs} args - Arguments to find a UserBranchAccess
     * @example
     * // Get one UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBranchAccessFindFirstArgs>(args?: SelectSubset<T, UserBranchAccessFindFirstArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBranchAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessFindFirstOrThrowArgs} args - Arguments to find a UserBranchAccess
     * @example
     * // Get one UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBranchAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBranchAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBranchAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBranchAccesses
     * const userBranchAccesses = await prisma.userBranchAccess.findMany()
     * 
     * // Get first 10 UserBranchAccesses
     * const userBranchAccesses = await prisma.userBranchAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBranchAccessWithIdOnly = await prisma.userBranchAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBranchAccessFindManyArgs>(args?: SelectSubset<T, UserBranchAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBranchAccess.
     * @param {UserBranchAccessCreateArgs} args - Arguments to create a UserBranchAccess.
     * @example
     * // Create one UserBranchAccess
     * const UserBranchAccess = await prisma.userBranchAccess.create({
     *   data: {
     *     // ... data to create a UserBranchAccess
     *   }
     * })
     * 
     */
    create<T extends UserBranchAccessCreateArgs>(args: SelectSubset<T, UserBranchAccessCreateArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBranchAccesses.
     * @param {UserBranchAccessCreateManyArgs} args - Arguments to create many UserBranchAccesses.
     * @example
     * // Create many UserBranchAccesses
     * const userBranchAccess = await prisma.userBranchAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBranchAccessCreateManyArgs>(args?: SelectSubset<T, UserBranchAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBranchAccesses and returns the data saved in the database.
     * @param {UserBranchAccessCreateManyAndReturnArgs} args - Arguments to create many UserBranchAccesses.
     * @example
     * // Create many UserBranchAccesses
     * const userBranchAccess = await prisma.userBranchAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBranchAccesses and only return the `id`
     * const userBranchAccessWithIdOnly = await prisma.userBranchAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBranchAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBranchAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBranchAccess.
     * @param {UserBranchAccessDeleteArgs} args - Arguments to delete one UserBranchAccess.
     * @example
     * // Delete one UserBranchAccess
     * const UserBranchAccess = await prisma.userBranchAccess.delete({
     *   where: {
     *     // ... filter to delete one UserBranchAccess
     *   }
     * })
     * 
     */
    delete<T extends UserBranchAccessDeleteArgs>(args: SelectSubset<T, UserBranchAccessDeleteArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBranchAccess.
     * @param {UserBranchAccessUpdateArgs} args - Arguments to update one UserBranchAccess.
     * @example
     * // Update one UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBranchAccessUpdateArgs>(args: SelectSubset<T, UserBranchAccessUpdateArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBranchAccesses.
     * @param {UserBranchAccessDeleteManyArgs} args - Arguments to filter UserBranchAccesses to delete.
     * @example
     * // Delete a few UserBranchAccesses
     * const { count } = await prisma.userBranchAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBranchAccessDeleteManyArgs>(args?: SelectSubset<T, UserBranchAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBranchAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBranchAccesses
     * const userBranchAccess = await prisma.userBranchAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBranchAccessUpdateManyArgs>(args: SelectSubset<T, UserBranchAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBranchAccesses and returns the data updated in the database.
     * @param {UserBranchAccessUpdateManyAndReturnArgs} args - Arguments to update many UserBranchAccesses.
     * @example
     * // Update many UserBranchAccesses
     * const userBranchAccess = await prisma.userBranchAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBranchAccesses and only return the `id`
     * const userBranchAccessWithIdOnly = await prisma.userBranchAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBranchAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBranchAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBranchAccess.
     * @param {UserBranchAccessUpsertArgs} args - Arguments to update or create a UserBranchAccess.
     * @example
     * // Update or create a UserBranchAccess
     * const userBranchAccess = await prisma.userBranchAccess.upsert({
     *   create: {
     *     // ... data to create a UserBranchAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBranchAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserBranchAccessUpsertArgs>(args: SelectSubset<T, UserBranchAccessUpsertArgs<ExtArgs>>): Prisma__UserBranchAccessClient<$Result.GetResult<Prisma.$UserBranchAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBranchAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessCountArgs} args - Arguments to filter UserBranchAccesses to count.
     * @example
     * // Count the number of UserBranchAccesses
     * const count = await prisma.userBranchAccess.count({
     *   where: {
     *     // ... the filter for the UserBranchAccesses we want to count
     *   }
     * })
    **/
    count<T extends UserBranchAccessCountArgs>(
      args?: Subset<T, UserBranchAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBranchAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBranchAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBranchAccessAggregateArgs>(args: Subset<T, UserBranchAccessAggregateArgs>): Prisma.PrismaPromise<GetUserBranchAccessAggregateType<T>>

    /**
     * Group by UserBranchAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBranchAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBranchAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBranchAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserBranchAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBranchAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBranchAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBranchAccess model
   */
  readonly fields: UserBranchAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBranchAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBranchAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBranchAccess model
   */
  interface UserBranchAccessFieldRefs {
    readonly id: FieldRef<"UserBranchAccess", 'Int'>
    readonly userId: FieldRef<"UserBranchAccess", 'Int'>
    readonly branchId: FieldRef<"UserBranchAccess", 'Int'>
    readonly createdAt: FieldRef<"UserBranchAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBranchAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBranchAccess findUnique
   */
  export type UserBranchAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserBranchAccess to fetch.
     */
    where: UserBranchAccessWhereUniqueInput
  }

  /**
   * UserBranchAccess findUniqueOrThrow
   */
  export type UserBranchAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserBranchAccess to fetch.
     */
    where: UserBranchAccessWhereUniqueInput
  }

  /**
   * UserBranchAccess findFirst
   */
  export type UserBranchAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserBranchAccess to fetch.
     */
    where?: UserBranchAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBranchAccesses to fetch.
     */
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBranchAccesses.
     */
    cursor?: UserBranchAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBranchAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBranchAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBranchAccesses.
     */
    distinct?: UserBranchAccessScalarFieldEnum | UserBranchAccessScalarFieldEnum[]
  }

  /**
   * UserBranchAccess findFirstOrThrow
   */
  export type UserBranchAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserBranchAccess to fetch.
     */
    where?: UserBranchAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBranchAccesses to fetch.
     */
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBranchAccesses.
     */
    cursor?: UserBranchAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBranchAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBranchAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBranchAccesses.
     */
    distinct?: UserBranchAccessScalarFieldEnum | UserBranchAccessScalarFieldEnum[]
  }

  /**
   * UserBranchAccess findMany
   */
  export type UserBranchAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserBranchAccesses to fetch.
     */
    where?: UserBranchAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBranchAccesses to fetch.
     */
    orderBy?: UserBranchAccessOrderByWithRelationInput | UserBranchAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBranchAccesses.
     */
    cursor?: UserBranchAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBranchAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBranchAccesses.
     */
    skip?: number
    distinct?: UserBranchAccessScalarFieldEnum | UserBranchAccessScalarFieldEnum[]
  }

  /**
   * UserBranchAccess create
   */
  export type UserBranchAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBranchAccess.
     */
    data: XOR<UserBranchAccessCreateInput, UserBranchAccessUncheckedCreateInput>
  }

  /**
   * UserBranchAccess createMany
   */
  export type UserBranchAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBranchAccesses.
     */
    data: UserBranchAccessCreateManyInput | UserBranchAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBranchAccess createManyAndReturn
   */
  export type UserBranchAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * The data used to create many UserBranchAccesses.
     */
    data: UserBranchAccessCreateManyInput | UserBranchAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBranchAccess update
   */
  export type UserBranchAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBranchAccess.
     */
    data: XOR<UserBranchAccessUpdateInput, UserBranchAccessUncheckedUpdateInput>
    /**
     * Choose, which UserBranchAccess to update.
     */
    where: UserBranchAccessWhereUniqueInput
  }

  /**
   * UserBranchAccess updateMany
   */
  export type UserBranchAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBranchAccesses.
     */
    data: XOR<UserBranchAccessUpdateManyMutationInput, UserBranchAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserBranchAccesses to update
     */
    where?: UserBranchAccessWhereInput
    /**
     * Limit how many UserBranchAccesses to update.
     */
    limit?: number
  }

  /**
   * UserBranchAccess updateManyAndReturn
   */
  export type UserBranchAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * The data used to update UserBranchAccesses.
     */
    data: XOR<UserBranchAccessUpdateManyMutationInput, UserBranchAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserBranchAccesses to update
     */
    where?: UserBranchAccessWhereInput
    /**
     * Limit how many UserBranchAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBranchAccess upsert
   */
  export type UserBranchAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBranchAccess to update in case it exists.
     */
    where: UserBranchAccessWhereUniqueInput
    /**
     * In case the UserBranchAccess found by the `where` argument doesn't exist, create a new UserBranchAccess with this data.
     */
    create: XOR<UserBranchAccessCreateInput, UserBranchAccessUncheckedCreateInput>
    /**
     * In case the UserBranchAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBranchAccessUpdateInput, UserBranchAccessUncheckedUpdateInput>
  }

  /**
   * UserBranchAccess delete
   */
  export type UserBranchAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
    /**
     * Filter which UserBranchAccess to delete.
     */
    where: UserBranchAccessWhereUniqueInput
  }

  /**
   * UserBranchAccess deleteMany
   */
  export type UserBranchAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBranchAccesses to delete
     */
    where?: UserBranchAccessWhereInput
    /**
     * Limit how many UserBranchAccesses to delete.
     */
    limit?: number
  }

  /**
   * UserBranchAccess without action
   */
  export type UserBranchAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBranchAccess
     */
    select?: UserBranchAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBranchAccess
     */
    omit?: UserBranchAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBranchAccessInclude<ExtArgs> | null
  }


  /**
   * Model UserLocation
   */

  export type AggregateUserLocation = {
    _count: UserLocationCountAggregateOutputType | null
    _avg: UserLocationAvgAggregateOutputType | null
    _sum: UserLocationSumAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  export type UserLocationAvgAggregateOutputType = {
    userId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type UserLocationSumAggregateOutputType = {
    userId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type UserLocationMinAggregateOutputType = {
    userId: number | null
    latitude: number | null
    longitude: number | null
    address: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    updatedAt: Date | null
  }

  export type UserLocationMaxAggregateOutputType = {
    userId: number | null
    latitude: number | null
    longitude: number | null
    address: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    updatedAt: Date | null
  }

  export type UserLocationCountAggregateOutputType = {
    userId: number
    latitude: number
    longitude: number
    address: number
    isOnline: number
    lastSeen: number
    updatedAt: number
    _all: number
  }


  export type UserLocationAvgAggregateInputType = {
    userId?: true
    latitude?: true
    longitude?: true
  }

  export type UserLocationSumAggregateInputType = {
    userId?: true
    latitude?: true
    longitude?: true
  }

  export type UserLocationMinAggregateInputType = {
    userId?: true
    latitude?: true
    longitude?: true
    address?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
  }

  export type UserLocationMaxAggregateInputType = {
    userId?: true
    latitude?: true
    longitude?: true
    address?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
  }

  export type UserLocationCountAggregateInputType = {
    userId?: true
    latitude?: true
    longitude?: true
    address?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
    _all?: true
  }

  export type UserLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLocation to aggregate.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLocations
    **/
    _count?: true | UserLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLocationMaxAggregateInputType
  }

  export type GetUserLocationAggregateType<T extends UserLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLocation[P]>
      : GetScalarType<T[P], AggregateUserLocation[P]>
  }




  export type UserLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLocationWhereInput
    orderBy?: UserLocationOrderByWithAggregationInput | UserLocationOrderByWithAggregationInput[]
    by: UserLocationScalarFieldEnum[] | UserLocationScalarFieldEnum
    having?: UserLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLocationCountAggregateInputType | true
    _avg?: UserLocationAvgAggregateInputType
    _sum?: UserLocationSumAggregateInputType
    _min?: UserLocationMinAggregateInputType
    _max?: UserLocationMaxAggregateInputType
  }

  export type UserLocationGroupByOutputType = {
    userId: number
    latitude: number
    longitude: number
    address: string | null
    isOnline: boolean
    lastSeen: Date
    updatedAt: Date
    _count: UserLocationCountAggregateOutputType | null
    _avg: UserLocationAvgAggregateOutputType | null
    _sum: UserLocationSumAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  type GetUserLocationGroupByPayload<T extends UserLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
            : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
        }
      >
    >


  export type UserLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLocation"]>

  export type UserLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLocation"]>

  export type UserLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLocation"]>

  export type UserLocationSelectScalar = {
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
  }

  export type UserLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "latitude" | "longitude" | "address" | "isOnline" | "lastSeen" | "updatedAt", ExtArgs["result"]["userLocation"]>
  export type UserLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLocation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      latitude: number
      longitude: number
      address: string | null
      isOnline: boolean
      lastSeen: Date
      updatedAt: Date
    }, ExtArgs["result"]["userLocation"]>
    composites: {}
  }

  type UserLocationGetPayload<S extends boolean | null | undefined | UserLocationDefaultArgs> = $Result.GetResult<Prisma.$UserLocationPayload, S>

  type UserLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLocationCountAggregateInputType | true
    }

  export interface UserLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLocation'], meta: { name: 'UserLocation' } }
    /**
     * Find zero or one UserLocation that matches the filter.
     * @param {UserLocationFindUniqueArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLocationFindUniqueArgs>(args: SelectSubset<T, UserLocationFindUniqueArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLocationFindUniqueOrThrowArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindFirstArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLocationFindFirstArgs>(args?: SelectSubset<T, UserLocationFindFirstArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindFirstOrThrowArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLocations
     * const userLocations = await prisma.userLocation.findMany()
     * 
     * // Get first 10 UserLocations
     * const userLocations = await prisma.userLocation.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLocationWithUserIdOnly = await prisma.userLocation.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserLocationFindManyArgs>(args?: SelectSubset<T, UserLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLocation.
     * @param {UserLocationCreateArgs} args - Arguments to create a UserLocation.
     * @example
     * // Create one UserLocation
     * const UserLocation = await prisma.userLocation.create({
     *   data: {
     *     // ... data to create a UserLocation
     *   }
     * })
     * 
     */
    create<T extends UserLocationCreateArgs>(args: SelectSubset<T, UserLocationCreateArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLocations.
     * @param {UserLocationCreateManyArgs} args - Arguments to create many UserLocations.
     * @example
     * // Create many UserLocations
     * const userLocation = await prisma.userLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLocationCreateManyArgs>(args?: SelectSubset<T, UserLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLocations and returns the data saved in the database.
     * @param {UserLocationCreateManyAndReturnArgs} args - Arguments to create many UserLocations.
     * @example
     * // Create many UserLocations
     * const userLocation = await prisma.userLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLocations and only return the `userId`
     * const userLocationWithUserIdOnly = await prisma.userLocation.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLocation.
     * @param {UserLocationDeleteArgs} args - Arguments to delete one UserLocation.
     * @example
     * // Delete one UserLocation
     * const UserLocation = await prisma.userLocation.delete({
     *   where: {
     *     // ... filter to delete one UserLocation
     *   }
     * })
     * 
     */
    delete<T extends UserLocationDeleteArgs>(args: SelectSubset<T, UserLocationDeleteArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLocation.
     * @param {UserLocationUpdateArgs} args - Arguments to update one UserLocation.
     * @example
     * // Update one UserLocation
     * const userLocation = await prisma.userLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLocationUpdateArgs>(args: SelectSubset<T, UserLocationUpdateArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLocations.
     * @param {UserLocationDeleteManyArgs} args - Arguments to filter UserLocations to delete.
     * @example
     * // Delete a few UserLocations
     * const { count } = await prisma.userLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLocationDeleteManyArgs>(args?: SelectSubset<T, UserLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLocations
     * const userLocation = await prisma.userLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLocationUpdateManyArgs>(args: SelectSubset<T, UserLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLocations and returns the data updated in the database.
     * @param {UserLocationUpdateManyAndReturnArgs} args - Arguments to update many UserLocations.
     * @example
     * // Update many UserLocations
     * const userLocation = await prisma.userLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLocations and only return the `userId`
     * const userLocationWithUserIdOnly = await prisma.userLocation.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLocation.
     * @param {UserLocationUpsertArgs} args - Arguments to update or create a UserLocation.
     * @example
     * // Update or create a UserLocation
     * const userLocation = await prisma.userLocation.upsert({
     *   create: {
     *     // ... data to create a UserLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLocation we want to update
     *   }
     * })
     */
    upsert<T extends UserLocationUpsertArgs>(args: SelectSubset<T, UserLocationUpsertArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationCountArgs} args - Arguments to filter UserLocations to count.
     * @example
     * // Count the number of UserLocations
     * const count = await prisma.userLocation.count({
     *   where: {
     *     // ... the filter for the UserLocations we want to count
     *   }
     * })
    **/
    count<T extends UserLocationCountArgs>(
      args?: Subset<T, UserLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLocationAggregateArgs>(args: Subset<T, UserLocationAggregateArgs>): Prisma.PrismaPromise<GetUserLocationAggregateType<T>>

    /**
     * Group by UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLocationGroupByArgs['orderBy'] }
        : { orderBy?: UserLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLocation model
   */
  readonly fields: UserLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLocation model
   */
  interface UserLocationFieldRefs {
    readonly userId: FieldRef<"UserLocation", 'Int'>
    readonly latitude: FieldRef<"UserLocation", 'Float'>
    readonly longitude: FieldRef<"UserLocation", 'Float'>
    readonly address: FieldRef<"UserLocation", 'String'>
    readonly isOnline: FieldRef<"UserLocation", 'Boolean'>
    readonly lastSeen: FieldRef<"UserLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLocation findUnique
   */
  export type UserLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation findUniqueOrThrow
   */
  export type UserLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation findFirst
   */
  export type UserLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLocations.
     */
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation findFirstOrThrow
   */
  export type UserLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLocations.
     */
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation findMany
   */
  export type UserLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocations to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation create
   */
  export type UserLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLocation.
     */
    data: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
  }

  /**
   * UserLocation createMany
   */
  export type UserLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLocations.
     */
    data: UserLocationCreateManyInput | UserLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLocation createManyAndReturn
   */
  export type UserLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * The data used to create many UserLocations.
     */
    data: UserLocationCreateManyInput | UserLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLocation update
   */
  export type UserLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLocation.
     */
    data: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
    /**
     * Choose, which UserLocation to update.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation updateMany
   */
  export type UserLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLocations.
     */
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyInput>
    /**
     * Filter which UserLocations to update
     */
    where?: UserLocationWhereInput
    /**
     * Limit how many UserLocations to update.
     */
    limit?: number
  }

  /**
   * UserLocation updateManyAndReturn
   */
  export type UserLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * The data used to update UserLocations.
     */
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyInput>
    /**
     * Filter which UserLocations to update
     */
    where?: UserLocationWhereInput
    /**
     * Limit how many UserLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLocation upsert
   */
  export type UserLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLocation to update in case it exists.
     */
    where: UserLocationWhereUniqueInput
    /**
     * In case the UserLocation found by the `where` argument doesn't exist, create a new UserLocation with this data.
     */
    create: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
    /**
     * In case the UserLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
  }

  /**
   * UserLocation delete
   */
  export type UserLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter which UserLocation to delete.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation deleteMany
   */
  export type UserLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLocations to delete
     */
    where?: UserLocationWhereInput
    /**
     * Limit how many UserLocations to delete.
     */
    limit?: number
  }

  /**
   * UserLocation without action
   */
  export type UserLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLocation
     */
    omit?: UserLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    branchId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Category$branchArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Category$branchArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Category$branchArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Category$branchArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Category$branchArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Category$branchArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      branchId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Category$branchArgs<ExtArgs> = {}>(args?: Subset<T, Category$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly branchId: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.branch
   */
  export type Category$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    quantity: number | null
    defectiveQuantity: number | null
    returnedQuantity: number | null
    exchangedQuantity: number | null
    initialQuantity: number | null
    branchId: number | null
    categoryId: number | null
    marketPrice: number | null
    bonusPercentage: number | null
    sizeNumber: number | null
    areaSqm: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    quantity: number | null
    defectiveQuantity: number | null
    returnedQuantity: number | null
    exchangedQuantity: number | null
    initialQuantity: number | null
    branchId: number | null
    categoryId: number | null
    marketPrice: number | null
    bonusPercentage: number | null
    sizeNumber: number | null
    areaSqm: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    model: string | null
    price: number | null
    quantity: number | null
    defectiveQuantity: number | null
    returnedQuantity: number | null
    exchangedQuantity: number | null
    initialQuantity: number | null
    status: $Enums.ProductStatus | null
    branchId: number | null
    categoryId: number | null
    marketPrice: number | null
    bonusPercentage: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sizeType: $Enums.ProductSizeType | null
    sizeLabel: string | null
    sizeNumber: number | null
    areaSqm: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    model: string | null
    price: number | null
    quantity: number | null
    defectiveQuantity: number | null
    returnedQuantity: number | null
    exchangedQuantity: number | null
    initialQuantity: number | null
    status: $Enums.ProductStatus | null
    branchId: number | null
    categoryId: number | null
    marketPrice: number | null
    bonusPercentage: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sizeType: $Enums.ProductSizeType | null
    sizeLabel: string | null
    sizeNumber: number | null
    areaSqm: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    model: number
    price: number
    quantity: number
    defectiveQuantity: number
    returnedQuantity: number
    exchangedQuantity: number
    initialQuantity: number
    status: number
    branchId: number
    categoryId: number
    marketPrice: number
    bonusPercentage: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    sizeType: number
    sizeLabel: number
    sizeNumber: number
    areaSqm: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    quantity?: true
    defectiveQuantity?: true
    returnedQuantity?: true
    exchangedQuantity?: true
    initialQuantity?: true
    branchId?: true
    categoryId?: true
    marketPrice?: true
    bonusPercentage?: true
    sizeNumber?: true
    areaSqm?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    quantity?: true
    defectiveQuantity?: true
    returnedQuantity?: true
    exchangedQuantity?: true
    initialQuantity?: true
    branchId?: true
    categoryId?: true
    marketPrice?: true
    bonusPercentage?: true
    sizeNumber?: true
    areaSqm?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    model?: true
    price?: true
    quantity?: true
    defectiveQuantity?: true
    returnedQuantity?: true
    exchangedQuantity?: true
    initialQuantity?: true
    status?: true
    branchId?: true
    categoryId?: true
    marketPrice?: true
    bonusPercentage?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    sizeType?: true
    sizeLabel?: true
    sizeNumber?: true
    areaSqm?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    model?: true
    price?: true
    quantity?: true
    defectiveQuantity?: true
    returnedQuantity?: true
    exchangedQuantity?: true
    initialQuantity?: true
    status?: true
    branchId?: true
    categoryId?: true
    marketPrice?: true
    bonusPercentage?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    sizeType?: true
    sizeLabel?: true
    sizeNumber?: true
    areaSqm?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    model?: true
    price?: true
    quantity?: true
    defectiveQuantity?: true
    returnedQuantity?: true
    exchangedQuantity?: true
    initialQuantity?: true
    status?: true
    branchId?: true
    categoryId?: true
    marketPrice?: true
    bonusPercentage?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    sizeType?: true
    sizeLabel?: true
    sizeNumber?: true
    areaSqm?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    barcode: string | null
    model: string | null
    price: number
    quantity: number
    defectiveQuantity: number
    returnedQuantity: number
    exchangedQuantity: number
    initialQuantity: number
    status: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice: number | null
    bonusPercentage: number | null
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sizeType: $Enums.ProductSizeType
    sizeLabel: string | null
    sizeNumber: number | null
    areaSqm: number | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    model?: boolean
    price?: boolean
    quantity?: boolean
    defectiveQuantity?: boolean
    returnedQuantity?: boolean
    exchangedQuantity?: boolean
    initialQuantity?: boolean
    status?: boolean
    branchId?: boolean
    categoryId?: boolean
    marketPrice?: boolean
    bonusPercentage?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeType?: boolean
    sizeLabel?: boolean
    sizeNumber?: boolean
    areaSqm?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    DefectiveLog?: boolean | Product$DefectiveLogArgs<ExtArgs>
    ProductTransfer?: boolean | Product$ProductTransferArgs<ExtArgs>
    bonusProducts?: boolean | Product$bonusProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    model?: boolean
    price?: boolean
    quantity?: boolean
    defectiveQuantity?: boolean
    returnedQuantity?: boolean
    exchangedQuantity?: boolean
    initialQuantity?: boolean
    status?: boolean
    branchId?: boolean
    categoryId?: boolean
    marketPrice?: boolean
    bonusPercentage?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeType?: boolean
    sizeLabel?: boolean
    sizeNumber?: boolean
    areaSqm?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    model?: boolean
    price?: boolean
    quantity?: boolean
    defectiveQuantity?: boolean
    returnedQuantity?: boolean
    exchangedQuantity?: boolean
    initialQuantity?: boolean
    status?: boolean
    branchId?: boolean
    categoryId?: boolean
    marketPrice?: boolean
    bonusPercentage?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeType?: boolean
    sizeLabel?: boolean
    sizeNumber?: boolean
    areaSqm?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    model?: boolean
    price?: boolean
    quantity?: boolean
    defectiveQuantity?: boolean
    returnedQuantity?: boolean
    exchangedQuantity?: boolean
    initialQuantity?: boolean
    status?: boolean
    branchId?: boolean
    categoryId?: boolean
    marketPrice?: boolean
    bonusPercentage?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeType?: boolean
    sizeLabel?: boolean
    sizeNumber?: boolean
    areaSqm?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "barcode" | "model" | "price" | "quantity" | "defectiveQuantity" | "returnedQuantity" | "exchangedQuantity" | "initialQuantity" | "status" | "branchId" | "categoryId" | "marketPrice" | "bonusPercentage" | "isDeleted" | "deletedAt" | "createdAt" | "updatedAt" | "sizeType" | "sizeLabel" | "sizeNumber" | "areaSqm", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    DefectiveLog?: boolean | Product$DefectiveLogArgs<ExtArgs>
    ProductTransfer?: boolean | Product$ProductTransferArgs<ExtArgs>
    bonusProducts?: boolean | Product$bonusProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      transactions: Prisma.$TransactionItemPayload<ExtArgs>[]
      DefectiveLog: Prisma.$DefectiveLogPayload<ExtArgs>[]
      ProductTransfer: Prisma.$ProductTransferPayload<ExtArgs>[]
      bonusProducts: Prisma.$TransactionBonusProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      barcode: string | null
      model: string | null
      price: number
      quantity: number
      defectiveQuantity: number
      returnedQuantity: number
      exchangedQuantity: number
      initialQuantity: number
      status: $Enums.ProductStatus
      branchId: number
      categoryId: number
      marketPrice: number | null
      bonusPercentage: number | null
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
      sizeType: $Enums.ProductSizeType
      sizeLabel: string | null
      sizeNumber: number | null
      areaSqm: number | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Product$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DefectiveLog<T extends Product$DefectiveLogArgs<ExtArgs> = {}>(args?: Subset<T, Product$DefectiveLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductTransfer<T extends Product$ProductTransferArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonusProducts<T extends Product$bonusProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$bonusProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly model: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly defectiveQuantity: FieldRef<"Product", 'Int'>
    readonly returnedQuantity: FieldRef<"Product", 'Int'>
    readonly exchangedQuantity: FieldRef<"Product", 'Int'>
    readonly initialQuantity: FieldRef<"Product", 'Int'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly branchId: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly marketPrice: FieldRef<"Product", 'Float'>
    readonly bonusPercentage: FieldRef<"Product", 'Float'>
    readonly isDeleted: FieldRef<"Product", 'Boolean'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly sizeType: FieldRef<"Product", 'ProductSizeType'>
    readonly sizeLabel: FieldRef<"Product", 'String'>
    readonly sizeNumber: FieldRef<"Product", 'Float'>
    readonly areaSqm: FieldRef<"Product", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.transactions
   */
  export type Product$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * Product.DefectiveLog
   */
  export type Product$DefectiveLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    where?: DefectiveLogWhereInput
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    cursor?: DefectiveLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * Product.ProductTransfer
   */
  export type Product$ProductTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    cursor?: ProductTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * Product.bonusProducts
   */
  export type Product$bonusProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    where?: TransactionBonusProductWhereInput
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    cursor?: TransactionBonusProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionBonusProductScalarFieldEnum | TransactionBonusProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model DefectiveLog
   */

  export type AggregateDefectiveLog = {
    _count: DefectiveLogCountAggregateOutputType | null
    _avg: DefectiveLogAvgAggregateOutputType | null
    _sum: DefectiveLogSumAggregateOutputType | null
    _min: DefectiveLogMinAggregateOutputType | null
    _max: DefectiveLogMaxAggregateOutputType | null
  }

  export type DefectiveLogAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    userId: number | null
    branchId: number | null
    cashAmount: number | null
    exchangeWithProductId: number | null
    replacementQuantity: number | null
    replacementUnitPrice: number | null
    replacementTransactionId: number | null
  }

  export type DefectiveLogSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    userId: number | null
    branchId: number | null
    cashAmount: number | null
    exchangeWithProductId: number | null
    replacementQuantity: number | null
    replacementUnitPrice: number | null
    replacementTransactionId: number | null
  }

  export type DefectiveLogMinAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    description: string | null
    userId: number | null
    branchId: number | null
    cashAmount: number | null
    actionType: string | null
    createdAt: Date | null
    exchangeWithProductId: number | null
    replacementQuantity: number | null
    replacementUnitPrice: number | null
    replacementTransactionId: number | null
  }

  export type DefectiveLogMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    description: string | null
    userId: number | null
    branchId: number | null
    cashAmount: number | null
    actionType: string | null
    createdAt: Date | null
    exchangeWithProductId: number | null
    replacementQuantity: number | null
    replacementUnitPrice: number | null
    replacementTransactionId: number | null
  }

  export type DefectiveLogCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    description: number
    userId: number
    branchId: number
    cashAmount: number
    actionType: number
    createdAt: number
    exchangeWithProductId: number
    replacementQuantity: number
    replacementUnitPrice: number
    replacementTransactionId: number
    _all: number
  }


  export type DefectiveLogAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    userId?: true
    branchId?: true
    cashAmount?: true
    exchangeWithProductId?: true
    replacementQuantity?: true
    replacementUnitPrice?: true
    replacementTransactionId?: true
  }

  export type DefectiveLogSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    userId?: true
    branchId?: true
    cashAmount?: true
    exchangeWithProductId?: true
    replacementQuantity?: true
    replacementUnitPrice?: true
    replacementTransactionId?: true
  }

  export type DefectiveLogMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    description?: true
    userId?: true
    branchId?: true
    cashAmount?: true
    actionType?: true
    createdAt?: true
    exchangeWithProductId?: true
    replacementQuantity?: true
    replacementUnitPrice?: true
    replacementTransactionId?: true
  }

  export type DefectiveLogMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    description?: true
    userId?: true
    branchId?: true
    cashAmount?: true
    actionType?: true
    createdAt?: true
    exchangeWithProductId?: true
    replacementQuantity?: true
    replacementUnitPrice?: true
    replacementTransactionId?: true
  }

  export type DefectiveLogCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    description?: true
    userId?: true
    branchId?: true
    cashAmount?: true
    actionType?: true
    createdAt?: true
    exchangeWithProductId?: true
    replacementQuantity?: true
    replacementUnitPrice?: true
    replacementTransactionId?: true
    _all?: true
  }

  export type DefectiveLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectiveLog to aggregate.
     */
    where?: DefectiveLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectiveLogs to fetch.
     */
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefectiveLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectiveLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectiveLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefectiveLogs
    **/
    _count?: true | DefectiveLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefectiveLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefectiveLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefectiveLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefectiveLogMaxAggregateInputType
  }

  export type GetDefectiveLogAggregateType<T extends DefectiveLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDefectiveLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefectiveLog[P]>
      : GetScalarType<T[P], AggregateDefectiveLog[P]>
  }




  export type DefectiveLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectiveLogWhereInput
    orderBy?: DefectiveLogOrderByWithAggregationInput | DefectiveLogOrderByWithAggregationInput[]
    by: DefectiveLogScalarFieldEnum[] | DefectiveLogScalarFieldEnum
    having?: DefectiveLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefectiveLogCountAggregateInputType | true
    _avg?: DefectiveLogAvgAggregateInputType
    _sum?: DefectiveLogSumAggregateInputType
    _min?: DefectiveLogMinAggregateInputType
    _max?: DefectiveLogMaxAggregateInputType
  }

  export type DefectiveLogGroupByOutputType = {
    id: number
    productId: number
    quantity: number
    description: string
    userId: number | null
    branchId: number | null
    cashAmount: number
    actionType: string
    createdAt: Date
    exchangeWithProductId: number | null
    replacementQuantity: number | null
    replacementUnitPrice: number | null
    replacementTransactionId: number | null
    _count: DefectiveLogCountAggregateOutputType | null
    _avg: DefectiveLogAvgAggregateOutputType | null
    _sum: DefectiveLogSumAggregateOutputType | null
    _min: DefectiveLogMinAggregateOutputType | null
    _max: DefectiveLogMaxAggregateOutputType | null
  }

  type GetDefectiveLogGroupByPayload<T extends DefectiveLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefectiveLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefectiveLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefectiveLogGroupByOutputType[P]>
            : GetScalarType<T[P], DefectiveLogGroupByOutputType[P]>
        }
      >
    >


  export type DefectiveLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    description?: boolean
    userId?: boolean
    branchId?: boolean
    cashAmount?: boolean
    actionType?: boolean
    createdAt?: boolean
    exchangeWithProductId?: boolean
    replacementQuantity?: boolean
    replacementUnitPrice?: boolean
    replacementTransactionId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["defectiveLog"]>

  export type DefectiveLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    description?: boolean
    userId?: boolean
    branchId?: boolean
    cashAmount?: boolean
    actionType?: boolean
    createdAt?: boolean
    exchangeWithProductId?: boolean
    replacementQuantity?: boolean
    replacementUnitPrice?: boolean
    replacementTransactionId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["defectiveLog"]>

  export type DefectiveLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    description?: boolean
    userId?: boolean
    branchId?: boolean
    cashAmount?: boolean
    actionType?: boolean
    createdAt?: boolean
    exchangeWithProductId?: boolean
    replacementQuantity?: boolean
    replacementUnitPrice?: boolean
    replacementTransactionId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["defectiveLog"]>

  export type DefectiveLogSelectScalar = {
    id?: boolean
    productId?: boolean
    quantity?: boolean
    description?: boolean
    userId?: boolean
    branchId?: boolean
    cashAmount?: boolean
    actionType?: boolean
    createdAt?: boolean
    exchangeWithProductId?: boolean
    replacementQuantity?: boolean
    replacementUnitPrice?: boolean
    replacementTransactionId?: boolean
  }

  export type DefectiveLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "quantity" | "description" | "userId" | "branchId" | "cashAmount" | "actionType" | "createdAt" | "exchangeWithProductId" | "replacementQuantity" | "replacementUnitPrice" | "replacementTransactionId", ExtArgs["result"]["defectiveLog"]>
  export type DefectiveLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }
  export type DefectiveLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }
  export type DefectiveLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | DefectiveLog$userArgs<ExtArgs>
    branch?: boolean | DefectiveLog$branchArgs<ExtArgs>
  }

  export type $DefectiveLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefectiveLog"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      quantity: number
      description: string
      userId: number | null
      branchId: number | null
      cashAmount: number
      actionType: string
      createdAt: Date
      exchangeWithProductId: number | null
      replacementQuantity: number | null
      replacementUnitPrice: number | null
      replacementTransactionId: number | null
    }, ExtArgs["result"]["defectiveLog"]>
    composites: {}
  }

  type DefectiveLogGetPayload<S extends boolean | null | undefined | DefectiveLogDefaultArgs> = $Result.GetResult<Prisma.$DefectiveLogPayload, S>

  type DefectiveLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefectiveLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefectiveLogCountAggregateInputType | true
    }

  export interface DefectiveLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefectiveLog'], meta: { name: 'DefectiveLog' } }
    /**
     * Find zero or one DefectiveLog that matches the filter.
     * @param {DefectiveLogFindUniqueArgs} args - Arguments to find a DefectiveLog
     * @example
     * // Get one DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefectiveLogFindUniqueArgs>(args: SelectSubset<T, DefectiveLogFindUniqueArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefectiveLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefectiveLogFindUniqueOrThrowArgs} args - Arguments to find a DefectiveLog
     * @example
     * // Get one DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefectiveLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DefectiveLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefectiveLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogFindFirstArgs} args - Arguments to find a DefectiveLog
     * @example
     * // Get one DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefectiveLogFindFirstArgs>(args?: SelectSubset<T, DefectiveLogFindFirstArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefectiveLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogFindFirstOrThrowArgs} args - Arguments to find a DefectiveLog
     * @example
     * // Get one DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefectiveLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DefectiveLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefectiveLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefectiveLogs
     * const defectiveLogs = await prisma.defectiveLog.findMany()
     * 
     * // Get first 10 DefectiveLogs
     * const defectiveLogs = await prisma.defectiveLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defectiveLogWithIdOnly = await prisma.defectiveLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefectiveLogFindManyArgs>(args?: SelectSubset<T, DefectiveLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefectiveLog.
     * @param {DefectiveLogCreateArgs} args - Arguments to create a DefectiveLog.
     * @example
     * // Create one DefectiveLog
     * const DefectiveLog = await prisma.defectiveLog.create({
     *   data: {
     *     // ... data to create a DefectiveLog
     *   }
     * })
     * 
     */
    create<T extends DefectiveLogCreateArgs>(args: SelectSubset<T, DefectiveLogCreateArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefectiveLogs.
     * @param {DefectiveLogCreateManyArgs} args - Arguments to create many DefectiveLogs.
     * @example
     * // Create many DefectiveLogs
     * const defectiveLog = await prisma.defectiveLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefectiveLogCreateManyArgs>(args?: SelectSubset<T, DefectiveLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefectiveLogs and returns the data saved in the database.
     * @param {DefectiveLogCreateManyAndReturnArgs} args - Arguments to create many DefectiveLogs.
     * @example
     * // Create many DefectiveLogs
     * const defectiveLog = await prisma.defectiveLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefectiveLogs and only return the `id`
     * const defectiveLogWithIdOnly = await prisma.defectiveLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefectiveLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DefectiveLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DefectiveLog.
     * @param {DefectiveLogDeleteArgs} args - Arguments to delete one DefectiveLog.
     * @example
     * // Delete one DefectiveLog
     * const DefectiveLog = await prisma.defectiveLog.delete({
     *   where: {
     *     // ... filter to delete one DefectiveLog
     *   }
     * })
     * 
     */
    delete<T extends DefectiveLogDeleteArgs>(args: SelectSubset<T, DefectiveLogDeleteArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefectiveLog.
     * @param {DefectiveLogUpdateArgs} args - Arguments to update one DefectiveLog.
     * @example
     * // Update one DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefectiveLogUpdateArgs>(args: SelectSubset<T, DefectiveLogUpdateArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefectiveLogs.
     * @param {DefectiveLogDeleteManyArgs} args - Arguments to filter DefectiveLogs to delete.
     * @example
     * // Delete a few DefectiveLogs
     * const { count } = await prisma.defectiveLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefectiveLogDeleteManyArgs>(args?: SelectSubset<T, DefectiveLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefectiveLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefectiveLogs
     * const defectiveLog = await prisma.defectiveLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefectiveLogUpdateManyArgs>(args: SelectSubset<T, DefectiveLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefectiveLogs and returns the data updated in the database.
     * @param {DefectiveLogUpdateManyAndReturnArgs} args - Arguments to update many DefectiveLogs.
     * @example
     * // Update many DefectiveLogs
     * const defectiveLog = await prisma.defectiveLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DefectiveLogs and only return the `id`
     * const defectiveLogWithIdOnly = await prisma.defectiveLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DefectiveLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DefectiveLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DefectiveLog.
     * @param {DefectiveLogUpsertArgs} args - Arguments to update or create a DefectiveLog.
     * @example
     * // Update or create a DefectiveLog
     * const defectiveLog = await prisma.defectiveLog.upsert({
     *   create: {
     *     // ... data to create a DefectiveLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefectiveLog we want to update
     *   }
     * })
     */
    upsert<T extends DefectiveLogUpsertArgs>(args: SelectSubset<T, DefectiveLogUpsertArgs<ExtArgs>>): Prisma__DefectiveLogClient<$Result.GetResult<Prisma.$DefectiveLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DefectiveLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogCountArgs} args - Arguments to filter DefectiveLogs to count.
     * @example
     * // Count the number of DefectiveLogs
     * const count = await prisma.defectiveLog.count({
     *   where: {
     *     // ... the filter for the DefectiveLogs we want to count
     *   }
     * })
    **/
    count<T extends DefectiveLogCountArgs>(
      args?: Subset<T, DefectiveLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefectiveLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefectiveLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefectiveLogAggregateArgs>(args: Subset<T, DefectiveLogAggregateArgs>): Prisma.PrismaPromise<GetDefectiveLogAggregateType<T>>

    /**
     * Group by DefectiveLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectiveLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefectiveLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefectiveLogGroupByArgs['orderBy'] }
        : { orderBy?: DefectiveLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefectiveLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefectiveLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefectiveLog model
   */
  readonly fields: DefectiveLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefectiveLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefectiveLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends DefectiveLog$userArgs<ExtArgs> = {}>(args?: Subset<T, DefectiveLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends DefectiveLog$branchArgs<ExtArgs> = {}>(args?: Subset<T, DefectiveLog$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefectiveLog model
   */
  interface DefectiveLogFieldRefs {
    readonly id: FieldRef<"DefectiveLog", 'Int'>
    readonly productId: FieldRef<"DefectiveLog", 'Int'>
    readonly quantity: FieldRef<"DefectiveLog", 'Int'>
    readonly description: FieldRef<"DefectiveLog", 'String'>
    readonly userId: FieldRef<"DefectiveLog", 'Int'>
    readonly branchId: FieldRef<"DefectiveLog", 'Int'>
    readonly cashAmount: FieldRef<"DefectiveLog", 'Float'>
    readonly actionType: FieldRef<"DefectiveLog", 'String'>
    readonly createdAt: FieldRef<"DefectiveLog", 'DateTime'>
    readonly exchangeWithProductId: FieldRef<"DefectiveLog", 'Int'>
    readonly replacementQuantity: FieldRef<"DefectiveLog", 'Int'>
    readonly replacementUnitPrice: FieldRef<"DefectiveLog", 'Float'>
    readonly replacementTransactionId: FieldRef<"DefectiveLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DefectiveLog findUnique
   */
  export type DefectiveLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter, which DefectiveLog to fetch.
     */
    where: DefectiveLogWhereUniqueInput
  }

  /**
   * DefectiveLog findUniqueOrThrow
   */
  export type DefectiveLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter, which DefectiveLog to fetch.
     */
    where: DefectiveLogWhereUniqueInput
  }

  /**
   * DefectiveLog findFirst
   */
  export type DefectiveLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter, which DefectiveLog to fetch.
     */
    where?: DefectiveLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectiveLogs to fetch.
     */
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectiveLogs.
     */
    cursor?: DefectiveLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectiveLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectiveLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectiveLogs.
     */
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * DefectiveLog findFirstOrThrow
   */
  export type DefectiveLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter, which DefectiveLog to fetch.
     */
    where?: DefectiveLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectiveLogs to fetch.
     */
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectiveLogs.
     */
    cursor?: DefectiveLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectiveLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectiveLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectiveLogs.
     */
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * DefectiveLog findMany
   */
  export type DefectiveLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter, which DefectiveLogs to fetch.
     */
    where?: DefectiveLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectiveLogs to fetch.
     */
    orderBy?: DefectiveLogOrderByWithRelationInput | DefectiveLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefectiveLogs.
     */
    cursor?: DefectiveLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectiveLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectiveLogs.
     */
    skip?: number
    distinct?: DefectiveLogScalarFieldEnum | DefectiveLogScalarFieldEnum[]
  }

  /**
   * DefectiveLog create
   */
  export type DefectiveLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DefectiveLog.
     */
    data: XOR<DefectiveLogCreateInput, DefectiveLogUncheckedCreateInput>
  }

  /**
   * DefectiveLog createMany
   */
  export type DefectiveLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefectiveLogs.
     */
    data: DefectiveLogCreateManyInput | DefectiveLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefectiveLog createManyAndReturn
   */
  export type DefectiveLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * The data used to create many DefectiveLogs.
     */
    data: DefectiveLogCreateManyInput | DefectiveLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefectiveLog update
   */
  export type DefectiveLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DefectiveLog.
     */
    data: XOR<DefectiveLogUpdateInput, DefectiveLogUncheckedUpdateInput>
    /**
     * Choose, which DefectiveLog to update.
     */
    where: DefectiveLogWhereUniqueInput
  }

  /**
   * DefectiveLog updateMany
   */
  export type DefectiveLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefectiveLogs.
     */
    data: XOR<DefectiveLogUpdateManyMutationInput, DefectiveLogUncheckedUpdateManyInput>
    /**
     * Filter which DefectiveLogs to update
     */
    where?: DefectiveLogWhereInput
    /**
     * Limit how many DefectiveLogs to update.
     */
    limit?: number
  }

  /**
   * DefectiveLog updateManyAndReturn
   */
  export type DefectiveLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * The data used to update DefectiveLogs.
     */
    data: XOR<DefectiveLogUpdateManyMutationInput, DefectiveLogUncheckedUpdateManyInput>
    /**
     * Filter which DefectiveLogs to update
     */
    where?: DefectiveLogWhereInput
    /**
     * Limit how many DefectiveLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefectiveLog upsert
   */
  export type DefectiveLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DefectiveLog to update in case it exists.
     */
    where: DefectiveLogWhereUniqueInput
    /**
     * In case the DefectiveLog found by the `where` argument doesn't exist, create a new DefectiveLog with this data.
     */
    create: XOR<DefectiveLogCreateInput, DefectiveLogUncheckedCreateInput>
    /**
     * In case the DefectiveLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefectiveLogUpdateInput, DefectiveLogUncheckedUpdateInput>
  }

  /**
   * DefectiveLog delete
   */
  export type DefectiveLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
    /**
     * Filter which DefectiveLog to delete.
     */
    where: DefectiveLogWhereUniqueInput
  }

  /**
   * DefectiveLog deleteMany
   */
  export type DefectiveLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectiveLogs to delete
     */
    where?: DefectiveLogWhereInput
    /**
     * Limit how many DefectiveLogs to delete.
     */
    limit?: number
  }

  /**
   * DefectiveLog.user
   */
  export type DefectiveLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DefectiveLog.branch
   */
  export type DefectiveLog$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * DefectiveLog without action
   */
  export type DefectiveLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectiveLog
     */
    select?: DefectiveLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefectiveLog
     */
    omit?: DefectiveLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectiveLogInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    email: string | null
    address: string | null
    passportSeries: string | null
    jshshir: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    email: string | null
    address: string | null
    passportSeries: string | null
    jshshir: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    fullName: number
    phone: number
    email: number
    address: number
    passportSeries: number
    jshshir: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    email?: true
    address?: true
    passportSeries?: true
    jshshir?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    email?: true
    address?: true
    passportSeries?: true
    jshshir?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    email?: true
    address?: true
    passportSeries?: true
    jshshir?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    fullName: string
    phone: string
    email: string | null
    address: string | null
    passportSeries: string | null
    jshshir: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    passportSeries?: boolean
    jshshir?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    passportSeries?: boolean
    jshshir?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    passportSeries?: boolean
    jshshir?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    passportSeries?: boolean
    jshshir?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "phone" | "email" | "address" | "passportSeries" | "jshshir" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      phone: string
      email: string | null
      address: string | null
      passportSeries: string | null
      jshshir: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly fullName: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly passportSeries: FieldRef<"Customer", 'String'>
    readonly jshshir: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    soldByUserId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    discount: number | null
    total: number | null
    finalTotal: number | null
    amountPaid: number | null
    downPayment: number | null
    remainingBalance: number | null
    updatedById: number | null
    creditRepaymentAmount: number | null
    extraProfit: number | null
    days: number | null
    months: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    soldByUserId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    discount: number | null
    total: number | null
    finalTotal: number | null
    amountPaid: number | null
    downPayment: number | null
    remainingBalance: number | null
    updatedById: number | null
    creditRepaymentAmount: number | null
    extraProfit: number | null
    days: number | null
    months: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    soldByUserId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    type: $Enums.TransactionType | null
    transactionType: string | null
    status: $Enums.TransactionStatus | null
    discount: number | null
    total: number | null
    finalTotal: number | null
    paymentType: $Enums.PaymentType | null
    upfrontPaymentType: string | null
    termUnit: string | null
    deliveryMethod: string | null
    deliveryType: string | null
    deliveryAddress: string | null
    amountPaid: number | null
    downPayment: number | null
    remainingBalance: number | null
    receiptId: string | null
    description: string | null
    updatedById: number | null
    creditRepaymentAmount: number | null
    lastRepaymentDate: Date | null
    extraProfit: number | null
    days: number | null
    months: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    soldByUserId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    type: $Enums.TransactionType | null
    transactionType: string | null
    status: $Enums.TransactionStatus | null
    discount: number | null
    total: number | null
    finalTotal: number | null
    paymentType: $Enums.PaymentType | null
    upfrontPaymentType: string | null
    termUnit: string | null
    deliveryMethod: string | null
    deliveryType: string | null
    deliveryAddress: string | null
    amountPaid: number | null
    downPayment: number | null
    remainingBalance: number | null
    receiptId: string | null
    description: string | null
    updatedById: number | null
    creditRepaymentAmount: number | null
    lastRepaymentDate: Date | null
    extraProfit: number | null
    days: number | null
    months: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    customerId: number
    userId: number
    soldByUserId: number
    fromBranchId: number
    toBranchId: number
    type: number
    transactionType: number
    status: number
    discount: number
    total: number
    finalTotal: number
    paymentType: number
    upfrontPaymentType: number
    termUnit: number
    deliveryMethod: number
    deliveryType: number
    deliveryAddress: number
    amountPaid: number
    downPayment: number
    remainingBalance: number
    receiptId: number
    description: number
    updatedById: number
    creditRepaymentAmount: number
    lastRepaymentDate: number
    extraProfit: number
    days: number
    months: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    soldByUserId?: true
    fromBranchId?: true
    toBranchId?: true
    discount?: true
    total?: true
    finalTotal?: true
    amountPaid?: true
    downPayment?: true
    remainingBalance?: true
    updatedById?: true
    creditRepaymentAmount?: true
    extraProfit?: true
    days?: true
    months?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    soldByUserId?: true
    fromBranchId?: true
    toBranchId?: true
    discount?: true
    total?: true
    finalTotal?: true
    amountPaid?: true
    downPayment?: true
    remainingBalance?: true
    updatedById?: true
    creditRepaymentAmount?: true
    extraProfit?: true
    days?: true
    months?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    soldByUserId?: true
    fromBranchId?: true
    toBranchId?: true
    type?: true
    transactionType?: true
    status?: true
    discount?: true
    total?: true
    finalTotal?: true
    paymentType?: true
    upfrontPaymentType?: true
    termUnit?: true
    deliveryMethod?: true
    deliveryType?: true
    deliveryAddress?: true
    amountPaid?: true
    downPayment?: true
    remainingBalance?: true
    receiptId?: true
    description?: true
    updatedById?: true
    creditRepaymentAmount?: true
    lastRepaymentDate?: true
    extraProfit?: true
    days?: true
    months?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    soldByUserId?: true
    fromBranchId?: true
    toBranchId?: true
    type?: true
    transactionType?: true
    status?: true
    discount?: true
    total?: true
    finalTotal?: true
    paymentType?: true
    upfrontPaymentType?: true
    termUnit?: true
    deliveryMethod?: true
    deliveryType?: true
    deliveryAddress?: true
    amountPaid?: true
    downPayment?: true
    remainingBalance?: true
    receiptId?: true
    description?: true
    updatedById?: true
    creditRepaymentAmount?: true
    lastRepaymentDate?: true
    extraProfit?: true
    days?: true
    months?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    soldByUserId?: true
    fromBranchId?: true
    toBranchId?: true
    type?: true
    transactionType?: true
    status?: true
    discount?: true
    total?: true
    finalTotal?: true
    paymentType?: true
    upfrontPaymentType?: true
    termUnit?: true
    deliveryMethod?: true
    deliveryType?: true
    deliveryAddress?: true
    amountPaid?: true
    downPayment?: true
    remainingBalance?: true
    receiptId?: true
    description?: true
    updatedById?: true
    creditRepaymentAmount?: true
    lastRepaymentDate?: true
    extraProfit?: true
    days?: true
    months?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    customerId: number | null
    userId: number | null
    soldByUserId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    type: $Enums.TransactionType
    transactionType: string | null
    status: $Enums.TransactionStatus
    discount: number
    total: number
    finalTotal: number
    paymentType: $Enums.PaymentType | null
    upfrontPaymentType: string | null
    termUnit: string | null
    deliveryMethod: string | null
    deliveryType: string | null
    deliveryAddress: string | null
    amountPaid: number | null
    downPayment: number | null
    remainingBalance: number | null
    receiptId: string | null
    description: string | null
    updatedById: number | null
    creditRepaymentAmount: number | null
    lastRepaymentDate: Date | null
    extraProfit: number | null
    days: number | null
    months: number | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    userId?: boolean
    soldByUserId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    type?: boolean
    transactionType?: boolean
    status?: boolean
    discount?: boolean
    total?: boolean
    finalTotal?: boolean
    paymentType?: boolean
    upfrontPaymentType?: boolean
    termUnit?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    deliveryAddress?: boolean
    amountPaid?: boolean
    downPayment?: boolean
    remainingBalance?: boolean
    receiptId?: boolean
    description?: boolean
    updatedById?: boolean
    creditRepaymentAmount?: boolean
    lastRepaymentDate?: boolean
    extraProfit?: boolean
    days?: boolean
    months?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
    items?: boolean | Transaction$itemsArgs<ExtArgs>
    paymentSchedules?: boolean | Transaction$paymentSchedulesArgs<ExtArgs>
    PaymentRepayment?: boolean | Transaction$PaymentRepaymentArgs<ExtArgs>
    dailyRepayments?: boolean | Transaction$dailyRepaymentsArgs<ExtArgs>
    creditRepayments?: boolean | Transaction$creditRepaymentsArgs<ExtArgs>
    bonusProducts?: boolean | Transaction$bonusProductsArgs<ExtArgs>
    bonuses?: boolean | Transaction$bonusesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    userId?: boolean
    soldByUserId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    type?: boolean
    transactionType?: boolean
    status?: boolean
    discount?: boolean
    total?: boolean
    finalTotal?: boolean
    paymentType?: boolean
    upfrontPaymentType?: boolean
    termUnit?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    deliveryAddress?: boolean
    amountPaid?: boolean
    downPayment?: boolean
    remainingBalance?: boolean
    receiptId?: boolean
    description?: boolean
    updatedById?: boolean
    creditRepaymentAmount?: boolean
    lastRepaymentDate?: boolean
    extraProfit?: boolean
    days?: boolean
    months?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    userId?: boolean
    soldByUserId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    type?: boolean
    transactionType?: boolean
    status?: boolean
    discount?: boolean
    total?: boolean
    finalTotal?: boolean
    paymentType?: boolean
    upfrontPaymentType?: boolean
    termUnit?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    deliveryAddress?: boolean
    amountPaid?: boolean
    downPayment?: boolean
    remainingBalance?: boolean
    receiptId?: boolean
    description?: boolean
    updatedById?: boolean
    creditRepaymentAmount?: boolean
    lastRepaymentDate?: boolean
    extraProfit?: boolean
    days?: boolean
    months?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    customerId?: boolean
    userId?: boolean
    soldByUserId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    type?: boolean
    transactionType?: boolean
    status?: boolean
    discount?: boolean
    total?: boolean
    finalTotal?: boolean
    paymentType?: boolean
    upfrontPaymentType?: boolean
    termUnit?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    deliveryAddress?: boolean
    amountPaid?: boolean
    downPayment?: boolean
    remainingBalance?: boolean
    receiptId?: boolean
    description?: boolean
    updatedById?: boolean
    creditRepaymentAmount?: boolean
    lastRepaymentDate?: boolean
    extraProfit?: boolean
    days?: boolean
    months?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "userId" | "soldByUserId" | "fromBranchId" | "toBranchId" | "type" | "transactionType" | "status" | "discount" | "total" | "finalTotal" | "paymentType" | "upfrontPaymentType" | "termUnit" | "deliveryMethod" | "deliveryType" | "deliveryAddress" | "amountPaid" | "downPayment" | "remainingBalance" | "receiptId" | "description" | "updatedById" | "creditRepaymentAmount" | "lastRepaymentDate" | "extraProfit" | "days" | "months" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
    items?: boolean | Transaction$itemsArgs<ExtArgs>
    paymentSchedules?: boolean | Transaction$paymentSchedulesArgs<ExtArgs>
    PaymentRepayment?: boolean | Transaction$PaymentRepaymentArgs<ExtArgs>
    dailyRepayments?: boolean | Transaction$dailyRepaymentsArgs<ExtArgs>
    creditRepayments?: boolean | Transaction$creditRepaymentsArgs<ExtArgs>
    bonusProducts?: boolean | Transaction$bonusProductsArgs<ExtArgs>
    bonuses?: boolean | Transaction$bonusesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    user?: boolean | Transaction$userArgs<ExtArgs>
    soldBy?: boolean | Transaction$soldByArgs<ExtArgs>
    fromBranch?: boolean | Transaction$fromBranchArgs<ExtArgs>
    toBranch?: boolean | Transaction$toBranchArgs<ExtArgs>
    updatedBy?: boolean | Transaction$updatedByArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      soldBy: Prisma.$UserPayload<ExtArgs> | null
      fromBranch: Prisma.$BranchPayload<ExtArgs> | null
      toBranch: Prisma.$BranchPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$TransactionItemPayload<ExtArgs>[]
      paymentSchedules: Prisma.$PaymentSchedulePayload<ExtArgs>[]
      PaymentRepayment: Prisma.$PaymentRepaymentPayload<ExtArgs>[]
      dailyRepayments: Prisma.$DailyRepaymentPayload<ExtArgs>[]
      creditRepayments: Prisma.$CreditRepaymentPayload<ExtArgs>[]
      bonusProducts: Prisma.$TransactionBonusProductPayload<ExtArgs>[]
      bonuses: Prisma.$BonusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number | null
      userId: number | null
      soldByUserId: number | null
      fromBranchId: number | null
      toBranchId: number | null
      type: $Enums.TransactionType
      transactionType: string | null
      status: $Enums.TransactionStatus
      discount: number
      total: number
      finalTotal: number
      paymentType: $Enums.PaymentType | null
      upfrontPaymentType: string | null
      termUnit: string | null
      deliveryMethod: string | null
      deliveryType: string | null
      deliveryAddress: string | null
      amountPaid: number | null
      downPayment: number | null
      remainingBalance: number | null
      receiptId: string | null
      description: string | null
      updatedById: number | null
      creditRepaymentAmount: number | null
      lastRepaymentDate: Date | null
      extraProfit: number | null
      days: number | null
      months: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Transaction$customerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Transaction$userArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    soldBy<T extends Transaction$soldByArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$soldByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fromBranch<T extends Transaction$fromBranchArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$fromBranchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toBranch<T extends Transaction$toBranchArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$toBranchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Transaction$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Transaction$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentSchedules<T extends Transaction$paymentSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PaymentRepayment<T extends Transaction$PaymentRepaymentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$PaymentRepaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyRepayments<T extends Transaction$dailyRepaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$dailyRepaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditRepayments<T extends Transaction$creditRepaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$creditRepaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonusProducts<T extends Transaction$bonusProductsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$bonusProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonuses<T extends Transaction$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly customerId: FieldRef<"Transaction", 'Int'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly soldByUserId: FieldRef<"Transaction", 'Int'>
    readonly fromBranchId: FieldRef<"Transaction", 'Int'>
    readonly toBranchId: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly transactionType: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly discount: FieldRef<"Transaction", 'Float'>
    readonly total: FieldRef<"Transaction", 'Float'>
    readonly finalTotal: FieldRef<"Transaction", 'Float'>
    readonly paymentType: FieldRef<"Transaction", 'PaymentType'>
    readonly upfrontPaymentType: FieldRef<"Transaction", 'String'>
    readonly termUnit: FieldRef<"Transaction", 'String'>
    readonly deliveryMethod: FieldRef<"Transaction", 'String'>
    readonly deliveryType: FieldRef<"Transaction", 'String'>
    readonly deliveryAddress: FieldRef<"Transaction", 'String'>
    readonly amountPaid: FieldRef<"Transaction", 'Float'>
    readonly downPayment: FieldRef<"Transaction", 'Float'>
    readonly remainingBalance: FieldRef<"Transaction", 'Float'>
    readonly receiptId: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly updatedById: FieldRef<"Transaction", 'Int'>
    readonly creditRepaymentAmount: FieldRef<"Transaction", 'Float'>
    readonly lastRepaymentDate: FieldRef<"Transaction", 'DateTime'>
    readonly extraProfit: FieldRef<"Transaction", 'Float'>
    readonly days: FieldRef<"Transaction", 'Int'>
    readonly months: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.customer
   */
  export type Transaction$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Transaction.user
   */
  export type Transaction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.soldBy
   */
  export type Transaction$soldByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.fromBranch
   */
  export type Transaction$fromBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Transaction.toBranch
   */
  export type Transaction$toBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Transaction.updatedBy
   */
  export type Transaction$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.items
   */
  export type Transaction$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * Transaction.paymentSchedules
   */
  export type Transaction$paymentSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    where?: PaymentScheduleWhereInput
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    cursor?: PaymentScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScheduleScalarFieldEnum | PaymentScheduleScalarFieldEnum[]
  }

  /**
   * Transaction.PaymentRepayment
   */
  export type Transaction$PaymentRepaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    where?: PaymentRepaymentWhereInput
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    cursor?: PaymentRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * Transaction.dailyRepayments
   */
  export type Transaction$dailyRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    where?: DailyRepaymentWhereInput
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    cursor?: DailyRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * Transaction.creditRepayments
   */
  export type Transaction$creditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    where?: CreditRepaymentWhereInput
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    cursor?: CreditRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * Transaction.bonusProducts
   */
  export type Transaction$bonusProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    where?: TransactionBonusProductWhereInput
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    cursor?: TransactionBonusProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionBonusProductScalarFieldEnum | TransactionBonusProductScalarFieldEnum[]
  }

  /**
   * Transaction.bonuses
   */
  export type Transaction$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    cursor?: BonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionItem
   */

  export type AggregateTransactionItem = {
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  export type TransactionItemAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    price: number | null
    sellingPrice: number | null
    originalPrice: number | null
    total: number | null
    creditMonth: number | null
    creditPercent: number | null
    monthlyPayment: number | null
  }

  export type TransactionItemSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    price: number | null
    sellingPrice: number | null
    originalPrice: number | null
    total: number | null
    creditMonth: number | null
    creditPercent: number | null
    monthlyPayment: number | null
  }

  export type TransactionItemMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    price: number | null
    sellingPrice: number | null
    originalPrice: number | null
    total: number | null
    creditMonth: number | null
    creditPercent: number | null
    monthlyPayment: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionItemMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    price: number | null
    sellingPrice: number | null
    originalPrice: number | null
    total: number | null
    creditMonth: number | null
    creditPercent: number | null
    monthlyPayment: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionItemCountAggregateOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    price: number
    sellingPrice: number
    originalPrice: number
    total: number
    creditMonth: number
    creditPercent: number
    monthlyPayment: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionItemAvgAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    price?: true
    sellingPrice?: true
    originalPrice?: true
    total?: true
    creditMonth?: true
    creditPercent?: true
    monthlyPayment?: true
  }

  export type TransactionItemSumAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    price?: true
    sellingPrice?: true
    originalPrice?: true
    total?: true
    creditMonth?: true
    creditPercent?: true
    monthlyPayment?: true
  }

  export type TransactionItemMinAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    price?: true
    sellingPrice?: true
    originalPrice?: true
    total?: true
    creditMonth?: true
    creditPercent?: true
    monthlyPayment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionItemMaxAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    price?: true
    sellingPrice?: true
    originalPrice?: true
    total?: true
    creditMonth?: true
    creditPercent?: true
    monthlyPayment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionItemCountAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    price?: true
    sellingPrice?: true
    originalPrice?: true
    total?: true
    creditMonth?: true
    creditPercent?: true
    monthlyPayment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItem to aggregate.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionItems
    **/
    _count?: true | TransactionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionItemMaxAggregateInputType
  }

  export type GetTransactionItemAggregateType<T extends TransactionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionItem[P]>
      : GetScalarType<T[P], AggregateTransactionItem[P]>
  }




  export type TransactionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithAggregationInput | TransactionItemOrderByWithAggregationInput[]
    by: TransactionItemScalarFieldEnum[] | TransactionItemScalarFieldEnum
    having?: TransactionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionItemCountAggregateInputType | true
    _avg?: TransactionItemAvgAggregateInputType
    _sum?: TransactionItemSumAggregateInputType
    _min?: TransactionItemMinAggregateInputType
    _max?: TransactionItemMaxAggregateInputType
  }

  export type TransactionItemGroupByOutputType = {
    id: number
    transactionId: number
    productId: number | null
    quantity: number
    price: number
    sellingPrice: number | null
    originalPrice: number | null
    total: number
    creditMonth: number | null
    creditPercent: number | null
    monthlyPayment: number | null
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  type GetTransactionItemGroupByPayload<T extends TransactionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
        }
      >
    >


  export type TransactionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    sellingPrice?: boolean
    originalPrice?: boolean
    total?: boolean
    creditMonth?: boolean
    creditPercent?: boolean
    monthlyPayment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    sellingPrice?: boolean
    originalPrice?: boolean
    total?: boolean
    creditMonth?: boolean
    creditPercent?: boolean
    monthlyPayment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    sellingPrice?: boolean
    originalPrice?: boolean
    total?: boolean
    creditMonth?: boolean
    creditPercent?: boolean
    monthlyPayment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectScalar = {
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    sellingPrice?: boolean
    originalPrice?: boolean
    total?: boolean
    creditMonth?: boolean
    creditPercent?: boolean
    monthlyPayment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "productId" | "quantity" | "price" | "sellingPrice" | "originalPrice" | "total" | "creditMonth" | "creditPercent" | "monthlyPayment" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionItem"]>
  export type TransactionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }
  export type TransactionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }
  export type TransactionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | TransactionItem$productArgs<ExtArgs>
  }

  export type $TransactionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionItem"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      productId: number | null
      quantity: number
      price: number
      sellingPrice: number | null
      originalPrice: number | null
      total: number
      creditMonth: number | null
      creditPercent: number | null
      monthlyPayment: number | null
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionItem"]>
    composites: {}
  }

  type TransactionItemGetPayload<S extends boolean | null | undefined | TransactionItemDefaultArgs> = $Result.GetResult<Prisma.$TransactionItemPayload, S>

  type TransactionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionItemCountAggregateInputType | true
    }

  export interface TransactionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionItem'], meta: { name: 'TransactionItem' } }
    /**
     * Find zero or one TransactionItem that matches the filter.
     * @param {TransactionItemFindUniqueArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionItemFindUniqueArgs>(args: SelectSubset<T, TransactionItemFindUniqueArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionItemFindUniqueOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionItemFindFirstArgs>(args?: SelectSubset<T, TransactionItemFindFirstArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany()
     * 
     * // Get first 10 TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionItemFindManyArgs>(args?: SelectSubset<T, TransactionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionItem.
     * @param {TransactionItemCreateArgs} args - Arguments to create a TransactionItem.
     * @example
     * // Create one TransactionItem
     * const TransactionItem = await prisma.transactionItem.create({
     *   data: {
     *     // ... data to create a TransactionItem
     *   }
     * })
     * 
     */
    create<T extends TransactionItemCreateArgs>(args: SelectSubset<T, TransactionItemCreateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionItems.
     * @param {TransactionItemCreateManyArgs} args - Arguments to create many TransactionItems.
     * @example
     * // Create many TransactionItems
     * const transactionItem = await prisma.transactionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionItemCreateManyArgs>(args?: SelectSubset<T, TransactionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionItems and returns the data saved in the database.
     * @param {TransactionItemCreateManyAndReturnArgs} args - Arguments to create many TransactionItems.
     * @example
     * // Create many TransactionItems
     * const transactionItem = await prisma.transactionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionItems and only return the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionItem.
     * @param {TransactionItemDeleteArgs} args - Arguments to delete one TransactionItem.
     * @example
     * // Delete one TransactionItem
     * const TransactionItem = await prisma.transactionItem.delete({
     *   where: {
     *     // ... filter to delete one TransactionItem
     *   }
     * })
     * 
     */
    delete<T extends TransactionItemDeleteArgs>(args: SelectSubset<T, TransactionItemDeleteArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionItem.
     * @param {TransactionItemUpdateArgs} args - Arguments to update one TransactionItem.
     * @example
     * // Update one TransactionItem
     * const transactionItem = await prisma.transactionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionItemUpdateArgs>(args: SelectSubset<T, TransactionItemUpdateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionItems.
     * @param {TransactionItemDeleteManyArgs} args - Arguments to filter TransactionItems to delete.
     * @example
     * // Delete a few TransactionItems
     * const { count } = await prisma.transactionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionItemDeleteManyArgs>(args?: SelectSubset<T, TransactionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionItems
     * const transactionItem = await prisma.transactionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionItemUpdateManyArgs>(args: SelectSubset<T, TransactionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionItems and returns the data updated in the database.
     * @param {TransactionItemUpdateManyAndReturnArgs} args - Arguments to update many TransactionItems.
     * @example
     * // Update many TransactionItems
     * const transactionItem = await prisma.transactionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionItems and only return the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionItem.
     * @param {TransactionItemUpsertArgs} args - Arguments to update or create a TransactionItem.
     * @example
     * // Update or create a TransactionItem
     * const transactionItem = await prisma.transactionItem.upsert({
     *   create: {
     *     // ... data to create a TransactionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionItem we want to update
     *   }
     * })
     */
    upsert<T extends TransactionItemUpsertArgs>(args: SelectSubset<T, TransactionItemUpsertArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemCountArgs} args - Arguments to filter TransactionItems to count.
     * @example
     * // Count the number of TransactionItems
     * const count = await prisma.transactionItem.count({
     *   where: {
     *     // ... the filter for the TransactionItems we want to count
     *   }
     * })
    **/
    count<T extends TransactionItemCountArgs>(
      args?: Subset<T, TransactionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionItemAggregateArgs>(args: Subset<T, TransactionItemAggregateArgs>): Prisma.PrismaPromise<GetTransactionItemAggregateType<T>>

    /**
     * Group by TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionItemGroupByArgs['orderBy'] }
        : { orderBy?: TransactionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionItem model
   */
  readonly fields: TransactionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends TransactionItem$productArgs<ExtArgs> = {}>(args?: Subset<T, TransactionItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionItem model
   */
  interface TransactionItemFieldRefs {
    readonly id: FieldRef<"TransactionItem", 'Int'>
    readonly transactionId: FieldRef<"TransactionItem", 'Int'>
    readonly productId: FieldRef<"TransactionItem", 'Int'>
    readonly quantity: FieldRef<"TransactionItem", 'Int'>
    readonly price: FieldRef<"TransactionItem", 'Float'>
    readonly sellingPrice: FieldRef<"TransactionItem", 'Float'>
    readonly originalPrice: FieldRef<"TransactionItem", 'Float'>
    readonly total: FieldRef<"TransactionItem", 'Float'>
    readonly creditMonth: FieldRef<"TransactionItem", 'Int'>
    readonly creditPercent: FieldRef<"TransactionItem", 'Float'>
    readonly monthlyPayment: FieldRef<"TransactionItem", 'Float'>
    readonly status: FieldRef<"TransactionItem", 'String'>
    readonly createdAt: FieldRef<"TransactionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionItem findUnique
   */
  export type TransactionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findUniqueOrThrow
   */
  export type TransactionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findFirst
   */
  export type TransactionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findFirstOrThrow
   */
  export type TransactionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findMany
   */
  export type TransactionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItems to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem create
   */
  export type TransactionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionItem.
     */
    data: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
  }

  /**
   * TransactionItem createMany
   */
  export type TransactionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionItems.
     */
    data: TransactionItemCreateManyInput | TransactionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionItem createManyAndReturn
   */
  export type TransactionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionItems.
     */
    data: TransactionItemCreateManyInput | TransactionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionItem update
   */
  export type TransactionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionItem.
     */
    data: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
    /**
     * Choose, which TransactionItem to update.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem updateMany
   */
  export type TransactionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionItems.
     */
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyInput>
    /**
     * Filter which TransactionItems to update
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to update.
     */
    limit?: number
  }

  /**
   * TransactionItem updateManyAndReturn
   */
  export type TransactionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * The data used to update TransactionItems.
     */
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyInput>
    /**
     * Filter which TransactionItems to update
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionItem upsert
   */
  export type TransactionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionItem to update in case it exists.
     */
    where: TransactionItemWhereUniqueInput
    /**
     * In case the TransactionItem found by the `where` argument doesn't exist, create a new TransactionItem with this data.
     */
    create: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
    /**
     * In case the TransactionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
  }

  /**
   * TransactionItem delete
   */
  export type TransactionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter which TransactionItem to delete.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem deleteMany
   */
  export type TransactionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItems to delete
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to delete.
     */
    limit?: number
  }

  /**
   * TransactionItem.product
   */
  export type TransactionItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * TransactionItem without action
   */
  export type TransactionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductTransfer
   */

  export type AggregateProductTransfer = {
    _count: ProductTransferCountAggregateOutputType | null
    _avg: ProductTransferAvgAggregateOutputType | null
    _sum: ProductTransferSumAggregateOutputType | null
    _min: ProductTransferMinAggregateOutputType | null
    _max: ProductTransferMaxAggregateOutputType | null
  }

  export type ProductTransferAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    quantity: number | null
    initiatedById: number | null
    approvedById: number | null
  }

  export type ProductTransferSumAggregateOutputType = {
    id: number | null
    productId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    quantity: number | null
    initiatedById: number | null
    approvedById: number | null
  }

  export type ProductTransferMinAggregateOutputType = {
    id: number | null
    productId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    quantity: number | null
    status: $Enums.TransferStatus | null
    initiatedById: number | null
    approvedById: number | null
    transferDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductTransferMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    fromBranchId: number | null
    toBranchId: number | null
    quantity: number | null
    status: $Enums.TransferStatus | null
    initiatedById: number | null
    approvedById: number | null
    transferDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductTransferCountAggregateOutputType = {
    id: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status: number
    initiatedById: number
    approvedById: number
    transferDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductTransferAvgAggregateInputType = {
    id?: true
    productId?: true
    fromBranchId?: true
    toBranchId?: true
    quantity?: true
    initiatedById?: true
    approvedById?: true
  }

  export type ProductTransferSumAggregateInputType = {
    id?: true
    productId?: true
    fromBranchId?: true
    toBranchId?: true
    quantity?: true
    initiatedById?: true
    approvedById?: true
  }

  export type ProductTransferMinAggregateInputType = {
    id?: true
    productId?: true
    fromBranchId?: true
    toBranchId?: true
    quantity?: true
    status?: true
    initiatedById?: true
    approvedById?: true
    transferDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductTransferMaxAggregateInputType = {
    id?: true
    productId?: true
    fromBranchId?: true
    toBranchId?: true
    quantity?: true
    status?: true
    initiatedById?: true
    approvedById?: true
    transferDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductTransferCountAggregateInputType = {
    id?: true
    productId?: true
    fromBranchId?: true
    toBranchId?: true
    quantity?: true
    status?: true
    initiatedById?: true
    approvedById?: true
    transferDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTransfer to aggregate.
     */
    where?: ProductTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransfers to fetch.
     */
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTransfers
    **/
    _count?: true | ProductTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTransferMaxAggregateInputType
  }

  export type GetProductTransferAggregateType<T extends ProductTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTransfer[P]>
      : GetScalarType<T[P], AggregateProductTransfer[P]>
  }




  export type ProductTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransferWhereInput
    orderBy?: ProductTransferOrderByWithAggregationInput | ProductTransferOrderByWithAggregationInput[]
    by: ProductTransferScalarFieldEnum[] | ProductTransferScalarFieldEnum
    having?: ProductTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTransferCountAggregateInputType | true
    _avg?: ProductTransferAvgAggregateInputType
    _sum?: ProductTransferSumAggregateInputType
    _min?: ProductTransferMinAggregateInputType
    _max?: ProductTransferMaxAggregateInputType
  }

  export type ProductTransferGroupByOutputType = {
    id: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status: $Enums.TransferStatus
    initiatedById: number
    approvedById: number | null
    transferDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ProductTransferCountAggregateOutputType | null
    _avg: ProductTransferAvgAggregateOutputType | null
    _sum: ProductTransferSumAggregateOutputType | null
    _min: ProductTransferMinAggregateOutputType | null
    _max: ProductTransferMaxAggregateOutputType | null
  }

  type GetProductTransferGroupByPayload<T extends ProductTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTransferGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTransferGroupByOutputType[P]>
        }
      >
    >


  export type ProductTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    quantity?: boolean
    status?: boolean
    initiatedById?: boolean
    approvedById?: boolean
    transferDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["productTransfer"]>

  export type ProductTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    quantity?: boolean
    status?: boolean
    initiatedById?: boolean
    approvedById?: boolean
    transferDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["productTransfer"]>

  export type ProductTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    quantity?: boolean
    status?: boolean
    initiatedById?: boolean
    approvedById?: boolean
    transferDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["productTransfer"]>

  export type ProductTransferSelectScalar = {
    id?: boolean
    productId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    quantity?: boolean
    status?: boolean
    initiatedById?: boolean
    approvedById?: boolean
    transferDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "fromBranchId" | "toBranchId" | "quantity" | "status" | "initiatedById" | "approvedById" | "transferDate" | "createdAt" | "updatedAt", ExtArgs["result"]["productTransfer"]>
  export type ProductTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }
  export type ProductTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }
  export type ProductTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ProductTransfer$approvedByArgs<ExtArgs>
  }

  export type $ProductTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductTransfer"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      fromBranch: Prisma.$BranchPayload<ExtArgs>
      toBranch: Prisma.$BranchPayload<ExtArgs>
      initiatedBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      fromBranchId: number
      toBranchId: number
      quantity: number
      status: $Enums.TransferStatus
      initiatedById: number
      approvedById: number | null
      transferDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productTransfer"]>
    composites: {}
  }

  type ProductTransferGetPayload<S extends boolean | null | undefined | ProductTransferDefaultArgs> = $Result.GetResult<Prisma.$ProductTransferPayload, S>

  type ProductTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductTransferCountAggregateInputType | true
    }

  export interface ProductTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTransfer'], meta: { name: 'ProductTransfer' } }
    /**
     * Find zero or one ProductTransfer that matches the filter.
     * @param {ProductTransferFindUniqueArgs} args - Arguments to find a ProductTransfer
     * @example
     * // Get one ProductTransfer
     * const productTransfer = await prisma.productTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTransferFindUniqueArgs>(args: SelectSubset<T, ProductTransferFindUniqueArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTransferFindUniqueOrThrowArgs} args - Arguments to find a ProductTransfer
     * @example
     * // Get one ProductTransfer
     * const productTransfer = await prisma.productTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferFindFirstArgs} args - Arguments to find a ProductTransfer
     * @example
     * // Get one ProductTransfer
     * const productTransfer = await prisma.productTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTransferFindFirstArgs>(args?: SelectSubset<T, ProductTransferFindFirstArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferFindFirstOrThrowArgs} args - Arguments to find a ProductTransfer
     * @example
     * // Get one ProductTransfer
     * const productTransfer = await prisma.productTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTransfers
     * const productTransfers = await prisma.productTransfer.findMany()
     * 
     * // Get first 10 ProductTransfers
     * const productTransfers = await prisma.productTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTransferWithIdOnly = await prisma.productTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductTransferFindManyArgs>(args?: SelectSubset<T, ProductTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductTransfer.
     * @param {ProductTransferCreateArgs} args - Arguments to create a ProductTransfer.
     * @example
     * // Create one ProductTransfer
     * const ProductTransfer = await prisma.productTransfer.create({
     *   data: {
     *     // ... data to create a ProductTransfer
     *   }
     * })
     * 
     */
    create<T extends ProductTransferCreateArgs>(args: SelectSubset<T, ProductTransferCreateArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductTransfers.
     * @param {ProductTransferCreateManyArgs} args - Arguments to create many ProductTransfers.
     * @example
     * // Create many ProductTransfers
     * const productTransfer = await prisma.productTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTransferCreateManyArgs>(args?: SelectSubset<T, ProductTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTransfers and returns the data saved in the database.
     * @param {ProductTransferCreateManyAndReturnArgs} args - Arguments to create many ProductTransfers.
     * @example
     * // Create many ProductTransfers
     * const productTransfer = await prisma.productTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTransfers and only return the `id`
     * const productTransferWithIdOnly = await prisma.productTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductTransfer.
     * @param {ProductTransferDeleteArgs} args - Arguments to delete one ProductTransfer.
     * @example
     * // Delete one ProductTransfer
     * const ProductTransfer = await prisma.productTransfer.delete({
     *   where: {
     *     // ... filter to delete one ProductTransfer
     *   }
     * })
     * 
     */
    delete<T extends ProductTransferDeleteArgs>(args: SelectSubset<T, ProductTransferDeleteArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductTransfer.
     * @param {ProductTransferUpdateArgs} args - Arguments to update one ProductTransfer.
     * @example
     * // Update one ProductTransfer
     * const productTransfer = await prisma.productTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTransferUpdateArgs>(args: SelectSubset<T, ProductTransferUpdateArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductTransfers.
     * @param {ProductTransferDeleteManyArgs} args - Arguments to filter ProductTransfers to delete.
     * @example
     * // Delete a few ProductTransfers
     * const { count } = await prisma.productTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTransferDeleteManyArgs>(args?: SelectSubset<T, ProductTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTransfers
     * const productTransfer = await prisma.productTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTransferUpdateManyArgs>(args: SelectSubset<T, ProductTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTransfers and returns the data updated in the database.
     * @param {ProductTransferUpdateManyAndReturnArgs} args - Arguments to update many ProductTransfers.
     * @example
     * // Update many ProductTransfers
     * const productTransfer = await prisma.productTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductTransfers and only return the `id`
     * const productTransferWithIdOnly = await prisma.productTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductTransfer.
     * @param {ProductTransferUpsertArgs} args - Arguments to update or create a ProductTransfer.
     * @example
     * // Update or create a ProductTransfer
     * const productTransfer = await prisma.productTransfer.upsert({
     *   create: {
     *     // ... data to create a ProductTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTransfer we want to update
     *   }
     * })
     */
    upsert<T extends ProductTransferUpsertArgs>(args: SelectSubset<T, ProductTransferUpsertArgs<ExtArgs>>): Prisma__ProductTransferClient<$Result.GetResult<Prisma.$ProductTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferCountArgs} args - Arguments to filter ProductTransfers to count.
     * @example
     * // Count the number of ProductTransfers
     * const count = await prisma.productTransfer.count({
     *   where: {
     *     // ... the filter for the ProductTransfers we want to count
     *   }
     * })
    **/
    count<T extends ProductTransferCountArgs>(
      args?: Subset<T, ProductTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTransferAggregateArgs>(args: Subset<T, ProductTransferAggregateArgs>): Prisma.PrismaPromise<GetProductTransferAggregateType<T>>

    /**
     * Group by ProductTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTransferGroupByArgs['orderBy'] }
        : { orderBy?: ProductTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTransfer model
   */
  readonly fields: ProductTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    initiatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends ProductTransfer$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, ProductTransfer$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductTransfer model
   */
  interface ProductTransferFieldRefs {
    readonly id: FieldRef<"ProductTransfer", 'Int'>
    readonly productId: FieldRef<"ProductTransfer", 'Int'>
    readonly fromBranchId: FieldRef<"ProductTransfer", 'Int'>
    readonly toBranchId: FieldRef<"ProductTransfer", 'Int'>
    readonly quantity: FieldRef<"ProductTransfer", 'Int'>
    readonly status: FieldRef<"ProductTransfer", 'TransferStatus'>
    readonly initiatedById: FieldRef<"ProductTransfer", 'Int'>
    readonly approvedById: FieldRef<"ProductTransfer", 'Int'>
    readonly transferDate: FieldRef<"ProductTransfer", 'DateTime'>
    readonly createdAt: FieldRef<"ProductTransfer", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductTransfer findUnique
   */
  export type ProductTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransfer to fetch.
     */
    where: ProductTransferWhereUniqueInput
  }

  /**
   * ProductTransfer findUniqueOrThrow
   */
  export type ProductTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransfer to fetch.
     */
    where: ProductTransferWhereUniqueInput
  }

  /**
   * ProductTransfer findFirst
   */
  export type ProductTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransfer to fetch.
     */
    where?: ProductTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransfers to fetch.
     */
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTransfers.
     */
    cursor?: ProductTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTransfers.
     */
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * ProductTransfer findFirstOrThrow
   */
  export type ProductTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransfer to fetch.
     */
    where?: ProductTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransfers to fetch.
     */
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTransfers.
     */
    cursor?: ProductTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTransfers.
     */
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * ProductTransfer findMany
   */
  export type ProductTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransfers to fetch.
     */
    where?: ProductTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransfers to fetch.
     */
    orderBy?: ProductTransferOrderByWithRelationInput | ProductTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTransfers.
     */
    cursor?: ProductTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransfers.
     */
    skip?: number
    distinct?: ProductTransferScalarFieldEnum | ProductTransferScalarFieldEnum[]
  }

  /**
   * ProductTransfer create
   */
  export type ProductTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTransfer.
     */
    data: XOR<ProductTransferCreateInput, ProductTransferUncheckedCreateInput>
  }

  /**
   * ProductTransfer createMany
   */
  export type ProductTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTransfers.
     */
    data: ProductTransferCreateManyInput | ProductTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTransfer createManyAndReturn
   */
  export type ProductTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTransfers.
     */
    data: ProductTransferCreateManyInput | ProductTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTransfer update
   */
  export type ProductTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTransfer.
     */
    data: XOR<ProductTransferUpdateInput, ProductTransferUncheckedUpdateInput>
    /**
     * Choose, which ProductTransfer to update.
     */
    where: ProductTransferWhereUniqueInput
  }

  /**
   * ProductTransfer updateMany
   */
  export type ProductTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTransfers.
     */
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyInput>
    /**
     * Filter which ProductTransfers to update
     */
    where?: ProductTransferWhereInput
    /**
     * Limit how many ProductTransfers to update.
     */
    limit?: number
  }

  /**
   * ProductTransfer updateManyAndReturn
   */
  export type ProductTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * The data used to update ProductTransfers.
     */
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyInput>
    /**
     * Filter which ProductTransfers to update
     */
    where?: ProductTransferWhereInput
    /**
     * Limit how many ProductTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTransfer upsert
   */
  export type ProductTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTransfer to update in case it exists.
     */
    where: ProductTransferWhereUniqueInput
    /**
     * In case the ProductTransfer found by the `where` argument doesn't exist, create a new ProductTransfer with this data.
     */
    create: XOR<ProductTransferCreateInput, ProductTransferUncheckedCreateInput>
    /**
     * In case the ProductTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTransferUpdateInput, ProductTransferUncheckedUpdateInput>
  }

  /**
   * ProductTransfer delete
   */
  export type ProductTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
    /**
     * Filter which ProductTransfer to delete.
     */
    where: ProductTransferWhereUniqueInput
  }

  /**
   * ProductTransfer deleteMany
   */
  export type ProductTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTransfers to delete
     */
    where?: ProductTransferWhereInput
    /**
     * Limit how many ProductTransfers to delete.
     */
    limit?: number
  }

  /**
   * ProductTransfer.approvedBy
   */
  export type ProductTransfer$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductTransfer without action
   */
  export type ProductTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransfer
     */
    select?: ProductTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransfer
     */
    omit?: ProductTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransferInclude<ExtArgs> | null
  }


  /**
   * Model PaymentSchedule
   */

  export type AggregatePaymentSchedule = {
    _count: PaymentScheduleCountAggregateOutputType | null
    _avg: PaymentScheduleAvgAggregateOutputType | null
    _sum: PaymentScheduleSumAggregateOutputType | null
    _min: PaymentScheduleMinAggregateOutputType | null
    _max: PaymentScheduleMaxAggregateOutputType | null
  }

  export type PaymentScheduleAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    month: number | null
    payment: number | null
    remainingBalance: number | null
    paidAmount: number | null
    paidByUserId: number | null
    creditRepaymentAmount: number | null
    daysCount: number | null
    totalDays: number | null
    remainingDays: number | null
    totalMonths: number | null
    remainingMonths: number | null
  }

  export type PaymentScheduleSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    month: number | null
    payment: number | null
    remainingBalance: number | null
    paidAmount: number | null
    paidByUserId: number | null
    creditRepaymentAmount: number | null
    daysCount: number | null
    totalDays: number | null
    remainingDays: number | null
    totalMonths: number | null
    remainingMonths: number | null
  }

  export type PaymentScheduleMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    month: number | null
    payment: number | null
    remainingBalance: number | null
    isPaid: boolean | null
    paidAmount: number | null
    paidAt: Date | null
    paidChannel: string | null
    paidByUserId: number | null
    createdAt: Date | null
    creditRepaymentAmount: number | null
    repaymentDate: Date | null
    rating: string | null
    dueDate: Date | null
    isDailyInstallment: boolean | null
    daysCount: number | null
    installmentType: string | null
    totalDays: number | null
    remainingDays: number | null
    totalMonths: number | null
    remainingMonths: number | null
  }

  export type PaymentScheduleMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    month: number | null
    payment: number | null
    remainingBalance: number | null
    isPaid: boolean | null
    paidAmount: number | null
    paidAt: Date | null
    paidChannel: string | null
    paidByUserId: number | null
    createdAt: Date | null
    creditRepaymentAmount: number | null
    repaymentDate: Date | null
    rating: string | null
    dueDate: Date | null
    isDailyInstallment: boolean | null
    daysCount: number | null
    installmentType: string | null
    totalDays: number | null
    remainingDays: number | null
    totalMonths: number | null
    remainingMonths: number | null
  }

  export type PaymentScheduleCountAggregateOutputType = {
    id: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid: number
    paidAmount: number
    paidAt: number
    paidChannel: number
    paidByUserId: number
    createdAt: number
    creditRepaymentAmount: number
    repaymentDate: number
    rating: number
    dueDate: number
    isDailyInstallment: number
    daysCount: number
    installmentType: number
    totalDays: number
    remainingDays: number
    totalMonths: number
    remainingMonths: number
    _all: number
  }


  export type PaymentScheduleAvgAggregateInputType = {
    id?: true
    transactionId?: true
    month?: true
    payment?: true
    remainingBalance?: true
    paidAmount?: true
    paidByUserId?: true
    creditRepaymentAmount?: true
    daysCount?: true
    totalDays?: true
    remainingDays?: true
    totalMonths?: true
    remainingMonths?: true
  }

  export type PaymentScheduleSumAggregateInputType = {
    id?: true
    transactionId?: true
    month?: true
    payment?: true
    remainingBalance?: true
    paidAmount?: true
    paidByUserId?: true
    creditRepaymentAmount?: true
    daysCount?: true
    totalDays?: true
    remainingDays?: true
    totalMonths?: true
    remainingMonths?: true
  }

  export type PaymentScheduleMinAggregateInputType = {
    id?: true
    transactionId?: true
    month?: true
    payment?: true
    remainingBalance?: true
    isPaid?: true
    paidAmount?: true
    paidAt?: true
    paidChannel?: true
    paidByUserId?: true
    createdAt?: true
    creditRepaymentAmount?: true
    repaymentDate?: true
    rating?: true
    dueDate?: true
    isDailyInstallment?: true
    daysCount?: true
    installmentType?: true
    totalDays?: true
    remainingDays?: true
    totalMonths?: true
    remainingMonths?: true
  }

  export type PaymentScheduleMaxAggregateInputType = {
    id?: true
    transactionId?: true
    month?: true
    payment?: true
    remainingBalance?: true
    isPaid?: true
    paidAmount?: true
    paidAt?: true
    paidChannel?: true
    paidByUserId?: true
    createdAt?: true
    creditRepaymentAmount?: true
    repaymentDate?: true
    rating?: true
    dueDate?: true
    isDailyInstallment?: true
    daysCount?: true
    installmentType?: true
    totalDays?: true
    remainingDays?: true
    totalMonths?: true
    remainingMonths?: true
  }

  export type PaymentScheduleCountAggregateInputType = {
    id?: true
    transactionId?: true
    month?: true
    payment?: true
    remainingBalance?: true
    isPaid?: true
    paidAmount?: true
    paidAt?: true
    paidChannel?: true
    paidByUserId?: true
    createdAt?: true
    creditRepaymentAmount?: true
    repaymentDate?: true
    rating?: true
    dueDate?: true
    isDailyInstallment?: true
    daysCount?: true
    installmentType?: true
    totalDays?: true
    remainingDays?: true
    totalMonths?: true
    remainingMonths?: true
    _all?: true
  }

  export type PaymentScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentSchedule to aggregate.
     */
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     */
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentSchedules
    **/
    _count?: true | PaymentScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentScheduleMaxAggregateInputType
  }

  export type GetPaymentScheduleAggregateType<T extends PaymentScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentSchedule[P]>
      : GetScalarType<T[P], AggregatePaymentSchedule[P]>
  }




  export type PaymentScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentScheduleWhereInput
    orderBy?: PaymentScheduleOrderByWithAggregationInput | PaymentScheduleOrderByWithAggregationInput[]
    by: PaymentScheduleScalarFieldEnum[] | PaymentScheduleScalarFieldEnum
    having?: PaymentScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentScheduleCountAggregateInputType | true
    _avg?: PaymentScheduleAvgAggregateInputType
    _sum?: PaymentScheduleSumAggregateInputType
    _min?: PaymentScheduleMinAggregateInputType
    _max?: PaymentScheduleMaxAggregateInputType
  }

  export type PaymentScheduleGroupByOutputType = {
    id: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid: boolean
    paidAmount: number
    paidAt: Date | null
    paidChannel: string | null
    paidByUserId: number | null
    createdAt: Date
    creditRepaymentAmount: number | null
    repaymentDate: Date | null
    rating: string | null
    dueDate: Date | null
    isDailyInstallment: boolean
    daysCount: number | null
    installmentType: string | null
    totalDays: number | null
    remainingDays: number | null
    totalMonths: number | null
    remainingMonths: number | null
    _count: PaymentScheduleCountAggregateOutputType | null
    _avg: PaymentScheduleAvgAggregateOutputType | null
    _sum: PaymentScheduleSumAggregateOutputType | null
    _min: PaymentScheduleMinAggregateOutputType | null
    _max: PaymentScheduleMaxAggregateOutputType | null
  }

  type GetPaymentScheduleGroupByPayload<T extends PaymentScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentScheduleGroupByOutputType[P]>
        }
      >
    >


  export type PaymentScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    month?: boolean
    payment?: boolean
    remainingBalance?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    paidChannel?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    creditRepaymentAmount?: boolean
    repaymentDate?: boolean
    rating?: boolean
    dueDate?: boolean
    isDailyInstallment?: boolean
    daysCount?: boolean
    installmentType?: boolean
    totalDays?: boolean
    remainingDays?: boolean
    totalMonths?: boolean
    remainingMonths?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
    repayments?: boolean | PaymentSchedule$repaymentsArgs<ExtArgs>
    creditRepayments?: boolean | PaymentSchedule$creditRepaymentsArgs<ExtArgs>
    _count?: boolean | PaymentScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentSchedule"]>

  export type PaymentScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    month?: boolean
    payment?: boolean
    remainingBalance?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    paidChannel?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    creditRepaymentAmount?: boolean
    repaymentDate?: boolean
    rating?: boolean
    dueDate?: boolean
    isDailyInstallment?: boolean
    daysCount?: boolean
    installmentType?: boolean
    totalDays?: boolean
    remainingDays?: boolean
    totalMonths?: boolean
    remainingMonths?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentSchedule"]>

  export type PaymentScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    month?: boolean
    payment?: boolean
    remainingBalance?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    paidChannel?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    creditRepaymentAmount?: boolean
    repaymentDate?: boolean
    rating?: boolean
    dueDate?: boolean
    isDailyInstallment?: boolean
    daysCount?: boolean
    installmentType?: boolean
    totalDays?: boolean
    remainingDays?: boolean
    totalMonths?: boolean
    remainingMonths?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentSchedule"]>

  export type PaymentScheduleSelectScalar = {
    id?: boolean
    transactionId?: boolean
    month?: boolean
    payment?: boolean
    remainingBalance?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    paidChannel?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    creditRepaymentAmount?: boolean
    repaymentDate?: boolean
    rating?: boolean
    dueDate?: boolean
    isDailyInstallment?: boolean
    daysCount?: boolean
    installmentType?: boolean
    totalDays?: boolean
    remainingDays?: boolean
    totalMonths?: boolean
    remainingMonths?: boolean
  }

  export type PaymentScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "month" | "payment" | "remainingBalance" | "isPaid" | "paidAmount" | "paidAt" | "paidChannel" | "paidByUserId" | "createdAt" | "creditRepaymentAmount" | "repaymentDate" | "rating" | "dueDate" | "isDailyInstallment" | "daysCount" | "installmentType" | "totalDays" | "remainingDays" | "totalMonths" | "remainingMonths", ExtArgs["result"]["paymentSchedule"]>
  export type PaymentScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
    repayments?: boolean | PaymentSchedule$repaymentsArgs<ExtArgs>
    creditRepayments?: boolean | PaymentSchedule$creditRepaymentsArgs<ExtArgs>
    _count?: boolean | PaymentScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
  }
  export type PaymentScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentSchedule$paidByArgs<ExtArgs>
  }

  export type $PaymentSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentSchedule"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      paidBy: Prisma.$UserPayload<ExtArgs> | null
      repayments: Prisma.$PaymentRepaymentPayload<ExtArgs>[]
      creditRepayments: Prisma.$CreditRepaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      month: number
      payment: number
      remainingBalance: number
      isPaid: boolean
      paidAmount: number
      paidAt: Date | null
      paidChannel: string | null
      paidByUserId: number | null
      createdAt: Date
      creditRepaymentAmount: number | null
      repaymentDate: Date | null
      rating: string | null
      dueDate: Date | null
      isDailyInstallment: boolean
      daysCount: number | null
      installmentType: string | null
      totalDays: number | null
      remainingDays: number | null
      totalMonths: number | null
      remainingMonths: number | null
    }, ExtArgs["result"]["paymentSchedule"]>
    composites: {}
  }

  type PaymentScheduleGetPayload<S extends boolean | null | undefined | PaymentScheduleDefaultArgs> = $Result.GetResult<Prisma.$PaymentSchedulePayload, S>

  type PaymentScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentScheduleCountAggregateInputType | true
    }

  export interface PaymentScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentSchedule'], meta: { name: 'PaymentSchedule' } }
    /**
     * Find zero or one PaymentSchedule that matches the filter.
     * @param {PaymentScheduleFindUniqueArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentScheduleFindUniqueArgs>(args: SelectSubset<T, PaymentScheduleFindUniqueArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentScheduleFindUniqueOrThrowArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleFindFirstArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentScheduleFindFirstArgs>(args?: SelectSubset<T, PaymentScheduleFindFirstArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleFindFirstOrThrowArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentSchedules
     * const paymentSchedules = await prisma.paymentSchedule.findMany()
     * 
     * // Get first 10 PaymentSchedules
     * const paymentSchedules = await prisma.paymentSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentScheduleWithIdOnly = await prisma.paymentSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentScheduleFindManyArgs>(args?: SelectSubset<T, PaymentScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentSchedule.
     * @param {PaymentScheduleCreateArgs} args - Arguments to create a PaymentSchedule.
     * @example
     * // Create one PaymentSchedule
     * const PaymentSchedule = await prisma.paymentSchedule.create({
     *   data: {
     *     // ... data to create a PaymentSchedule
     *   }
     * })
     * 
     */
    create<T extends PaymentScheduleCreateArgs>(args: SelectSubset<T, PaymentScheduleCreateArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentSchedules.
     * @param {PaymentScheduleCreateManyArgs} args - Arguments to create many PaymentSchedules.
     * @example
     * // Create many PaymentSchedules
     * const paymentSchedule = await prisma.paymentSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentScheduleCreateManyArgs>(args?: SelectSubset<T, PaymentScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentSchedules and returns the data saved in the database.
     * @param {PaymentScheduleCreateManyAndReturnArgs} args - Arguments to create many PaymentSchedules.
     * @example
     * // Create many PaymentSchedules
     * const paymentSchedule = await prisma.paymentSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentSchedules and only return the `id`
     * const paymentScheduleWithIdOnly = await prisma.paymentSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentSchedule.
     * @param {PaymentScheduleDeleteArgs} args - Arguments to delete one PaymentSchedule.
     * @example
     * // Delete one PaymentSchedule
     * const PaymentSchedule = await prisma.paymentSchedule.delete({
     *   where: {
     *     // ... filter to delete one PaymentSchedule
     *   }
     * })
     * 
     */
    delete<T extends PaymentScheduleDeleteArgs>(args: SelectSubset<T, PaymentScheduleDeleteArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentSchedule.
     * @param {PaymentScheduleUpdateArgs} args - Arguments to update one PaymentSchedule.
     * @example
     * // Update one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentScheduleUpdateArgs>(args: SelectSubset<T, PaymentScheduleUpdateArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentSchedules.
     * @param {PaymentScheduleDeleteManyArgs} args - Arguments to filter PaymentSchedules to delete.
     * @example
     * // Delete a few PaymentSchedules
     * const { count } = await prisma.paymentSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentScheduleDeleteManyArgs>(args?: SelectSubset<T, PaymentScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentSchedules
     * const paymentSchedule = await prisma.paymentSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentScheduleUpdateManyArgs>(args: SelectSubset<T, PaymentScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSchedules and returns the data updated in the database.
     * @param {PaymentScheduleUpdateManyAndReturnArgs} args - Arguments to update many PaymentSchedules.
     * @example
     * // Update many PaymentSchedules
     * const paymentSchedule = await prisma.paymentSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentSchedules and only return the `id`
     * const paymentScheduleWithIdOnly = await prisma.paymentSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentSchedule.
     * @param {PaymentScheduleUpsertArgs} args - Arguments to update or create a PaymentSchedule.
     * @example
     * // Update or create a PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.upsert({
     *   create: {
     *     // ... data to create a PaymentSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentSchedule we want to update
     *   }
     * })
     */
    upsert<T extends PaymentScheduleUpsertArgs>(args: SelectSubset<T, PaymentScheduleUpsertArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleCountArgs} args - Arguments to filter PaymentSchedules to count.
     * @example
     * // Count the number of PaymentSchedules
     * const count = await prisma.paymentSchedule.count({
     *   where: {
     *     // ... the filter for the PaymentSchedules we want to count
     *   }
     * })
    **/
    count<T extends PaymentScheduleCountArgs>(
      args?: Subset<T, PaymentScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentScheduleAggregateArgs>(args: Subset<T, PaymentScheduleAggregateArgs>): Prisma.PrismaPromise<GetPaymentScheduleAggregateType<T>>

    /**
     * Group by PaymentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentScheduleGroupByArgs['orderBy'] }
        : { orderBy?: PaymentScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentSchedule model
   */
  readonly fields: PaymentScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paidBy<T extends PaymentSchedule$paidByArgs<ExtArgs> = {}>(args?: Subset<T, PaymentSchedule$paidByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    repayments<T extends PaymentSchedule$repaymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentSchedule$repaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditRepayments<T extends PaymentSchedule$creditRepaymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentSchedule$creditRepaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentSchedule model
   */
  interface PaymentScheduleFieldRefs {
    readonly id: FieldRef<"PaymentSchedule", 'Int'>
    readonly transactionId: FieldRef<"PaymentSchedule", 'Int'>
    readonly month: FieldRef<"PaymentSchedule", 'Int'>
    readonly payment: FieldRef<"PaymentSchedule", 'Float'>
    readonly remainingBalance: FieldRef<"PaymentSchedule", 'Float'>
    readonly isPaid: FieldRef<"PaymentSchedule", 'Boolean'>
    readonly paidAmount: FieldRef<"PaymentSchedule", 'Float'>
    readonly paidAt: FieldRef<"PaymentSchedule", 'DateTime'>
    readonly paidChannel: FieldRef<"PaymentSchedule", 'String'>
    readonly paidByUserId: FieldRef<"PaymentSchedule", 'Int'>
    readonly createdAt: FieldRef<"PaymentSchedule", 'DateTime'>
    readonly creditRepaymentAmount: FieldRef<"PaymentSchedule", 'Float'>
    readonly repaymentDate: FieldRef<"PaymentSchedule", 'DateTime'>
    readonly rating: FieldRef<"PaymentSchedule", 'String'>
    readonly dueDate: FieldRef<"PaymentSchedule", 'DateTime'>
    readonly isDailyInstallment: FieldRef<"PaymentSchedule", 'Boolean'>
    readonly daysCount: FieldRef<"PaymentSchedule", 'Int'>
    readonly installmentType: FieldRef<"PaymentSchedule", 'String'>
    readonly totalDays: FieldRef<"PaymentSchedule", 'Int'>
    readonly remainingDays: FieldRef<"PaymentSchedule", 'Int'>
    readonly totalMonths: FieldRef<"PaymentSchedule", 'Int'>
    readonly remainingMonths: FieldRef<"PaymentSchedule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PaymentSchedule findUnique
   */
  export type PaymentScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PaymentSchedule to fetch.
     */
    where: PaymentScheduleWhereUniqueInput
  }

  /**
   * PaymentSchedule findUniqueOrThrow
   */
  export type PaymentScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PaymentSchedule to fetch.
     */
    where: PaymentScheduleWhereUniqueInput
  }

  /**
   * PaymentSchedule findFirst
   */
  export type PaymentScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PaymentSchedule to fetch.
     */
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     */
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSchedules.
     */
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSchedules.
     */
    distinct?: PaymentScheduleScalarFieldEnum | PaymentScheduleScalarFieldEnum[]
  }

  /**
   * PaymentSchedule findFirstOrThrow
   */
  export type PaymentScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PaymentSchedule to fetch.
     */
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     */
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSchedules.
     */
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSchedules.
     */
    distinct?: PaymentScheduleScalarFieldEnum | PaymentScheduleScalarFieldEnum[]
  }

  /**
   * PaymentSchedule findMany
   */
  export type PaymentScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PaymentSchedules to fetch.
     */
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     */
    orderBy?: PaymentScheduleOrderByWithRelationInput | PaymentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentSchedules.
     */
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     */
    skip?: number
    distinct?: PaymentScheduleScalarFieldEnum | PaymentScheduleScalarFieldEnum[]
  }

  /**
   * PaymentSchedule create
   */
  export type PaymentScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentSchedule.
     */
    data: XOR<PaymentScheduleCreateInput, PaymentScheduleUncheckedCreateInput>
  }

  /**
   * PaymentSchedule createMany
   */
  export type PaymentScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentSchedules.
     */
    data: PaymentScheduleCreateManyInput | PaymentScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentSchedule createManyAndReturn
   */
  export type PaymentScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentSchedules.
     */
    data: PaymentScheduleCreateManyInput | PaymentScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentSchedule update
   */
  export type PaymentScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentSchedule.
     */
    data: XOR<PaymentScheduleUpdateInput, PaymentScheduleUncheckedUpdateInput>
    /**
     * Choose, which PaymentSchedule to update.
     */
    where: PaymentScheduleWhereUniqueInput
  }

  /**
   * PaymentSchedule updateMany
   */
  export type PaymentScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentSchedules.
     */
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentSchedules to update
     */
    where?: PaymentScheduleWhereInput
    /**
     * Limit how many PaymentSchedules to update.
     */
    limit?: number
  }

  /**
   * PaymentSchedule updateManyAndReturn
   */
  export type PaymentScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * The data used to update PaymentSchedules.
     */
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentSchedules to update
     */
    where?: PaymentScheduleWhereInput
    /**
     * Limit how many PaymentSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentSchedule upsert
   */
  export type PaymentScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentSchedule to update in case it exists.
     */
    where: PaymentScheduleWhereUniqueInput
    /**
     * In case the PaymentSchedule found by the `where` argument doesn't exist, create a new PaymentSchedule with this data.
     */
    create: XOR<PaymentScheduleCreateInput, PaymentScheduleUncheckedCreateInput>
    /**
     * In case the PaymentSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentScheduleUpdateInput, PaymentScheduleUncheckedUpdateInput>
  }

  /**
   * PaymentSchedule delete
   */
  export type PaymentScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    /**
     * Filter which PaymentSchedule to delete.
     */
    where: PaymentScheduleWhereUniqueInput
  }

  /**
   * PaymentSchedule deleteMany
   */
  export type PaymentScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentSchedules to delete
     */
    where?: PaymentScheduleWhereInput
    /**
     * Limit how many PaymentSchedules to delete.
     */
    limit?: number
  }

  /**
   * PaymentSchedule.paidBy
   */
  export type PaymentSchedule$paidByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentSchedule.repayments
   */
  export type PaymentSchedule$repaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    where?: PaymentRepaymentWhereInput
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    cursor?: PaymentRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * PaymentSchedule.creditRepayments
   */
  export type PaymentSchedule$creditRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    where?: CreditRepaymentWhereInput
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    cursor?: CreditRepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * PaymentSchedule without action
   */
  export type PaymentScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PaymentRepayment
   */

  export type AggregatePaymentRepayment = {
    _count: PaymentRepaymentCountAggregateOutputType | null
    _avg: PaymentRepaymentAvgAggregateOutputType | null
    _sum: PaymentRepaymentSumAggregateOutputType | null
    _min: PaymentRepaymentMinAggregateOutputType | null
    _max: PaymentRepaymentMaxAggregateOutputType | null
  }

  export type PaymentRepaymentAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    paidByUserId: number | null
  }

  export type PaymentRepaymentSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    paidByUserId: number | null
  }

  export type PaymentRepaymentMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    channel: string | null
    paidAt: Date | null
    paidByUserId: number | null
    createdAt: Date | null
  }

  export type PaymentRepaymentMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    channel: string | null
    paidAt: Date | null
    paidByUserId: number | null
    createdAt: Date | null
  }

  export type PaymentRepaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    scheduleId: number
    amount: number
    channel: number
    paidAt: number
    paidByUserId: number
    createdAt: number
    _all: number
  }


  export type PaymentRepaymentAvgAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    paidByUserId?: true
  }

  export type PaymentRepaymentSumAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    paidByUserId?: true
  }

  export type PaymentRepaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    createdAt?: true
  }

  export type PaymentRepaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    createdAt?: true
  }

  export type PaymentRepaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentRepaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRepayment to aggregate.
     */
    where?: PaymentRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRepayments to fetch.
     */
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentRepayments
    **/
    _count?: true | PaymentRepaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentRepaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentRepaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentRepaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentRepaymentMaxAggregateInputType
  }

  export type GetPaymentRepaymentAggregateType<T extends PaymentRepaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentRepayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentRepayment[P]>
      : GetScalarType<T[P], AggregatePaymentRepayment[P]>
  }




  export type PaymentRepaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRepaymentWhereInput
    orderBy?: PaymentRepaymentOrderByWithAggregationInput | PaymentRepaymentOrderByWithAggregationInput[]
    by: PaymentRepaymentScalarFieldEnum[] | PaymentRepaymentScalarFieldEnum
    having?: PaymentRepaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentRepaymentCountAggregateInputType | true
    _avg?: PaymentRepaymentAvgAggregateInputType
    _sum?: PaymentRepaymentSumAggregateInputType
    _min?: PaymentRepaymentMinAggregateInputType
    _max?: PaymentRepaymentMaxAggregateInputType
  }

  export type PaymentRepaymentGroupByOutputType = {
    id: number
    transactionId: number
    scheduleId: number
    amount: number
    channel: string
    paidAt: Date
    paidByUserId: number | null
    createdAt: Date
    _count: PaymentRepaymentCountAggregateOutputType | null
    _avg: PaymentRepaymentAvgAggregateOutputType | null
    _sum: PaymentRepaymentSumAggregateOutputType | null
    _min: PaymentRepaymentMinAggregateOutputType | null
    _max: PaymentRepaymentMaxAggregateOutputType | null
  }

  type GetPaymentRepaymentGroupByPayload<T extends PaymentRepaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentRepaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentRepaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentRepaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentRepaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentRepaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRepayment"]>

  export type PaymentRepaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRepayment"]>

  export type PaymentRepaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRepayment"]>

  export type PaymentRepaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
  }

  export type PaymentRepaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "scheduleId" | "amount" | "channel" | "paidAt" | "paidByUserId" | "createdAt", ExtArgs["result"]["paymentRepayment"]>
  export type PaymentRepaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }
  export type PaymentRepaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }
  export type PaymentRepaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | PaymentScheduleDefaultArgs<ExtArgs>
    paidBy?: boolean | PaymentRepayment$paidByArgs<ExtArgs>
  }

  export type $PaymentRepaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentRepayment"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      schedule: Prisma.$PaymentSchedulePayload<ExtArgs>
      paidBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      scheduleId: number
      amount: number
      channel: string
      paidAt: Date
      paidByUserId: number | null
      createdAt: Date
    }, ExtArgs["result"]["paymentRepayment"]>
    composites: {}
  }

  type PaymentRepaymentGetPayload<S extends boolean | null | undefined | PaymentRepaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentRepaymentPayload, S>

  type PaymentRepaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentRepaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentRepaymentCountAggregateInputType | true
    }

  export interface PaymentRepaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentRepayment'], meta: { name: 'PaymentRepayment' } }
    /**
     * Find zero or one PaymentRepayment that matches the filter.
     * @param {PaymentRepaymentFindUniqueArgs} args - Arguments to find a PaymentRepayment
     * @example
     * // Get one PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentRepaymentFindUniqueArgs>(args: SelectSubset<T, PaymentRepaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentRepayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentRepaymentFindUniqueOrThrowArgs} args - Arguments to find a PaymentRepayment
     * @example
     * // Get one PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentRepaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentRepaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRepayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentFindFirstArgs} args - Arguments to find a PaymentRepayment
     * @example
     * // Get one PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentRepaymentFindFirstArgs>(args?: SelectSubset<T, PaymentRepaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRepayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentFindFirstOrThrowArgs} args - Arguments to find a PaymentRepayment
     * @example
     * // Get one PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentRepaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentRepaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentRepayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentRepayments
     * const paymentRepayments = await prisma.paymentRepayment.findMany()
     * 
     * // Get first 10 PaymentRepayments
     * const paymentRepayments = await prisma.paymentRepayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentRepaymentWithIdOnly = await prisma.paymentRepayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentRepaymentFindManyArgs>(args?: SelectSubset<T, PaymentRepaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentRepayment.
     * @param {PaymentRepaymentCreateArgs} args - Arguments to create a PaymentRepayment.
     * @example
     * // Create one PaymentRepayment
     * const PaymentRepayment = await prisma.paymentRepayment.create({
     *   data: {
     *     // ... data to create a PaymentRepayment
     *   }
     * })
     * 
     */
    create<T extends PaymentRepaymentCreateArgs>(args: SelectSubset<T, PaymentRepaymentCreateArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentRepayments.
     * @param {PaymentRepaymentCreateManyArgs} args - Arguments to create many PaymentRepayments.
     * @example
     * // Create many PaymentRepayments
     * const paymentRepayment = await prisma.paymentRepayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentRepaymentCreateManyArgs>(args?: SelectSubset<T, PaymentRepaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentRepayments and returns the data saved in the database.
     * @param {PaymentRepaymentCreateManyAndReturnArgs} args - Arguments to create many PaymentRepayments.
     * @example
     * // Create many PaymentRepayments
     * const paymentRepayment = await prisma.paymentRepayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentRepayments and only return the `id`
     * const paymentRepaymentWithIdOnly = await prisma.paymentRepayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentRepaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentRepaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentRepayment.
     * @param {PaymentRepaymentDeleteArgs} args - Arguments to delete one PaymentRepayment.
     * @example
     * // Delete one PaymentRepayment
     * const PaymentRepayment = await prisma.paymentRepayment.delete({
     *   where: {
     *     // ... filter to delete one PaymentRepayment
     *   }
     * })
     * 
     */
    delete<T extends PaymentRepaymentDeleteArgs>(args: SelectSubset<T, PaymentRepaymentDeleteArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentRepayment.
     * @param {PaymentRepaymentUpdateArgs} args - Arguments to update one PaymentRepayment.
     * @example
     * // Update one PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentRepaymentUpdateArgs>(args: SelectSubset<T, PaymentRepaymentUpdateArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentRepayments.
     * @param {PaymentRepaymentDeleteManyArgs} args - Arguments to filter PaymentRepayments to delete.
     * @example
     * // Delete a few PaymentRepayments
     * const { count } = await prisma.paymentRepayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentRepaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentRepaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentRepayments
     * const paymentRepayment = await prisma.paymentRepayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentRepaymentUpdateManyArgs>(args: SelectSubset<T, PaymentRepaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRepayments and returns the data updated in the database.
     * @param {PaymentRepaymentUpdateManyAndReturnArgs} args - Arguments to update many PaymentRepayments.
     * @example
     * // Update many PaymentRepayments
     * const paymentRepayment = await prisma.paymentRepayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentRepayments and only return the `id`
     * const paymentRepaymentWithIdOnly = await prisma.paymentRepayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentRepaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentRepaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentRepayment.
     * @param {PaymentRepaymentUpsertArgs} args - Arguments to update or create a PaymentRepayment.
     * @example
     * // Update or create a PaymentRepayment
     * const paymentRepayment = await prisma.paymentRepayment.upsert({
     *   create: {
     *     // ... data to create a PaymentRepayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentRepayment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentRepaymentUpsertArgs>(args: SelectSubset<T, PaymentRepaymentUpsertArgs<ExtArgs>>): Prisma__PaymentRepaymentClient<$Result.GetResult<Prisma.$PaymentRepaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentCountArgs} args - Arguments to filter PaymentRepayments to count.
     * @example
     * // Count the number of PaymentRepayments
     * const count = await prisma.paymentRepayment.count({
     *   where: {
     *     // ... the filter for the PaymentRepayments we want to count
     *   }
     * })
    **/
    count<T extends PaymentRepaymentCountArgs>(
      args?: Subset<T, PaymentRepaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentRepaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentRepaymentAggregateArgs>(args: Subset<T, PaymentRepaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentRepaymentAggregateType<T>>

    /**
     * Group by PaymentRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRepaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentRepaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentRepaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentRepaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentRepaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentRepaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentRepayment model
   */
  readonly fields: PaymentRepaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentRepayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentRepaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends PaymentScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentScheduleDefaultArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paidBy<T extends PaymentRepayment$paidByArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRepayment$paidByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentRepayment model
   */
  interface PaymentRepaymentFieldRefs {
    readonly id: FieldRef<"PaymentRepayment", 'Int'>
    readonly transactionId: FieldRef<"PaymentRepayment", 'Int'>
    readonly scheduleId: FieldRef<"PaymentRepayment", 'Int'>
    readonly amount: FieldRef<"PaymentRepayment", 'Float'>
    readonly channel: FieldRef<"PaymentRepayment", 'String'>
    readonly paidAt: FieldRef<"PaymentRepayment", 'DateTime'>
    readonly paidByUserId: FieldRef<"PaymentRepayment", 'Int'>
    readonly createdAt: FieldRef<"PaymentRepayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentRepayment findUnique
   */
  export type PaymentRepaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRepayment to fetch.
     */
    where: PaymentRepaymentWhereUniqueInput
  }

  /**
   * PaymentRepayment findUniqueOrThrow
   */
  export type PaymentRepaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRepayment to fetch.
     */
    where: PaymentRepaymentWhereUniqueInput
  }

  /**
   * PaymentRepayment findFirst
   */
  export type PaymentRepaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRepayment to fetch.
     */
    where?: PaymentRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRepayments to fetch.
     */
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRepayments.
     */
    cursor?: PaymentRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRepayments.
     */
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * PaymentRepayment findFirstOrThrow
   */
  export type PaymentRepaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRepayment to fetch.
     */
    where?: PaymentRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRepayments to fetch.
     */
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRepayments.
     */
    cursor?: PaymentRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRepayments.
     */
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * PaymentRepayment findMany
   */
  export type PaymentRepaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRepayments to fetch.
     */
    where?: PaymentRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRepayments to fetch.
     */
    orderBy?: PaymentRepaymentOrderByWithRelationInput | PaymentRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentRepayments.
     */
    cursor?: PaymentRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRepayments.
     */
    skip?: number
    distinct?: PaymentRepaymentScalarFieldEnum | PaymentRepaymentScalarFieldEnum[]
  }

  /**
   * PaymentRepayment create
   */
  export type PaymentRepaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentRepayment.
     */
    data: XOR<PaymentRepaymentCreateInput, PaymentRepaymentUncheckedCreateInput>
  }

  /**
   * PaymentRepayment createMany
   */
  export type PaymentRepaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentRepayments.
     */
    data: PaymentRepaymentCreateManyInput | PaymentRepaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentRepayment createManyAndReturn
   */
  export type PaymentRepaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentRepayments.
     */
    data: PaymentRepaymentCreateManyInput | PaymentRepaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRepayment update
   */
  export type PaymentRepaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentRepayment.
     */
    data: XOR<PaymentRepaymentUpdateInput, PaymentRepaymentUncheckedUpdateInput>
    /**
     * Choose, which PaymentRepayment to update.
     */
    where: PaymentRepaymentWhereUniqueInput
  }

  /**
   * PaymentRepayment updateMany
   */
  export type PaymentRepaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentRepayments.
     */
    data: XOR<PaymentRepaymentUpdateManyMutationInput, PaymentRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRepayments to update
     */
    where?: PaymentRepaymentWhereInput
    /**
     * Limit how many PaymentRepayments to update.
     */
    limit?: number
  }

  /**
   * PaymentRepayment updateManyAndReturn
   */
  export type PaymentRepaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * The data used to update PaymentRepayments.
     */
    data: XOR<PaymentRepaymentUpdateManyMutationInput, PaymentRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRepayments to update
     */
    where?: PaymentRepaymentWhereInput
    /**
     * Limit how many PaymentRepayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRepayment upsert
   */
  export type PaymentRepaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentRepayment to update in case it exists.
     */
    where: PaymentRepaymentWhereUniqueInput
    /**
     * In case the PaymentRepayment found by the `where` argument doesn't exist, create a new PaymentRepayment with this data.
     */
    create: XOR<PaymentRepaymentCreateInput, PaymentRepaymentUncheckedCreateInput>
    /**
     * In case the PaymentRepayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentRepaymentUpdateInput, PaymentRepaymentUncheckedUpdateInput>
  }

  /**
   * PaymentRepayment delete
   */
  export type PaymentRepaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
    /**
     * Filter which PaymentRepayment to delete.
     */
    where: PaymentRepaymentWhereUniqueInput
  }

  /**
   * PaymentRepayment deleteMany
   */
  export type PaymentRepaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRepayments to delete
     */
    where?: PaymentRepaymentWhereInput
    /**
     * Limit how many PaymentRepayments to delete.
     */
    limit?: number
  }

  /**
   * PaymentRepayment.paidBy
   */
  export type PaymentRepayment$paidByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentRepayment without action
   */
  export type PaymentRepaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRepayment
     */
    select?: PaymentRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRepayment
     */
    omit?: PaymentRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRepaymentInclude<ExtArgs> | null
  }


  /**
   * Model DailyRepayment
   */

  export type AggregateDailyRepayment = {
    _count: DailyRepaymentCountAggregateOutputType | null
    _avg: DailyRepaymentAvgAggregateOutputType | null
    _sum: DailyRepaymentSumAggregateOutputType | null
    _min: DailyRepaymentMinAggregateOutputType | null
    _max: DailyRepaymentMaxAggregateOutputType | null
  }

  export type DailyRepaymentAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    amount: number | null
    paidByUserId: number | null
    branchId: number | null
  }

  export type DailyRepaymentSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    amount: number | null
    paidByUserId: number | null
    branchId: number | null
  }

  export type DailyRepaymentMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    amount: number | null
    channel: string | null
    paidAt: Date | null
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date | null
  }

  export type DailyRepaymentMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    amount: number | null
    channel: string | null
    paidAt: Date | null
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date | null
  }

  export type DailyRepaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    amount: number
    channel: number
    paidAt: number
    paidByUserId: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type DailyRepaymentAvgAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    paidByUserId?: true
    branchId?: true
  }

  export type DailyRepaymentSumAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    paidByUserId?: true
    branchId?: true
  }

  export type DailyRepaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
  }

  export type DailyRepaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
  }

  export type DailyRepaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    channel?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type DailyRepaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRepayment to aggregate.
     */
    where?: DailyRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRepayments to fetch.
     */
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRepayments
    **/
    _count?: true | DailyRepaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRepaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRepaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRepaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRepaymentMaxAggregateInputType
  }

  export type GetDailyRepaymentAggregateType<T extends DailyRepaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRepayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRepayment[P]>
      : GetScalarType<T[P], AggregateDailyRepayment[P]>
  }




  export type DailyRepaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRepaymentWhereInput
    orderBy?: DailyRepaymentOrderByWithAggregationInput | DailyRepaymentOrderByWithAggregationInput[]
    by: DailyRepaymentScalarFieldEnum[] | DailyRepaymentScalarFieldEnum
    having?: DailyRepaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRepaymentCountAggregateInputType | true
    _avg?: DailyRepaymentAvgAggregateInputType
    _sum?: DailyRepaymentSumAggregateInputType
    _min?: DailyRepaymentMinAggregateInputType
    _max?: DailyRepaymentMaxAggregateInputType
  }

  export type DailyRepaymentGroupByOutputType = {
    id: number
    transactionId: number
    amount: number
    channel: string
    paidAt: Date
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date
    _count: DailyRepaymentCountAggregateOutputType | null
    _avg: DailyRepaymentAvgAggregateOutputType | null
    _sum: DailyRepaymentSumAggregateOutputType | null
    _min: DailyRepaymentMinAggregateOutputType | null
    _max: DailyRepaymentMaxAggregateOutputType | null
  }

  type GetDailyRepaymentGroupByPayload<T extends DailyRepaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRepaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRepaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRepaymentGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRepaymentGroupByOutputType[P]>
        }
      >
    >


  export type DailyRepaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRepayment"]>

  export type DailyRepaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRepayment"]>

  export type DailyRepaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRepayment"]>

  export type DailyRepaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    channel?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type DailyRepaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "amount" | "channel" | "paidAt" | "paidByUserId" | "branchId" | "createdAt", ExtArgs["result"]["dailyRepayment"]>
  export type DailyRepaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }
  export type DailyRepaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }
  export type DailyRepaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paidBy?: boolean | DailyRepayment$paidByArgs<ExtArgs>
    branch?: boolean | DailyRepayment$branchArgs<ExtArgs>
  }

  export type $DailyRepaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRepayment"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      paidBy: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      amount: number
      channel: string
      paidAt: Date
      paidByUserId: number | null
      branchId: number | null
      createdAt: Date
    }, ExtArgs["result"]["dailyRepayment"]>
    composites: {}
  }

  type DailyRepaymentGetPayload<S extends boolean | null | undefined | DailyRepaymentDefaultArgs> = $Result.GetResult<Prisma.$DailyRepaymentPayload, S>

  type DailyRepaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyRepaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyRepaymentCountAggregateInputType | true
    }

  export interface DailyRepaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRepayment'], meta: { name: 'DailyRepayment' } }
    /**
     * Find zero or one DailyRepayment that matches the filter.
     * @param {DailyRepaymentFindUniqueArgs} args - Arguments to find a DailyRepayment
     * @example
     * // Get one DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRepaymentFindUniqueArgs>(args: SelectSubset<T, DailyRepaymentFindUniqueArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyRepayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyRepaymentFindUniqueOrThrowArgs} args - Arguments to find a DailyRepayment
     * @example
     * // Get one DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRepaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRepaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyRepayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentFindFirstArgs} args - Arguments to find a DailyRepayment
     * @example
     * // Get one DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRepaymentFindFirstArgs>(args?: SelectSubset<T, DailyRepaymentFindFirstArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyRepayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentFindFirstOrThrowArgs} args - Arguments to find a DailyRepayment
     * @example
     * // Get one DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRepaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRepaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyRepayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRepayments
     * const dailyRepayments = await prisma.dailyRepayment.findMany()
     * 
     * // Get first 10 DailyRepayments
     * const dailyRepayments = await prisma.dailyRepayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRepaymentWithIdOnly = await prisma.dailyRepayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRepaymentFindManyArgs>(args?: SelectSubset<T, DailyRepaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyRepayment.
     * @param {DailyRepaymentCreateArgs} args - Arguments to create a DailyRepayment.
     * @example
     * // Create one DailyRepayment
     * const DailyRepayment = await prisma.dailyRepayment.create({
     *   data: {
     *     // ... data to create a DailyRepayment
     *   }
     * })
     * 
     */
    create<T extends DailyRepaymentCreateArgs>(args: SelectSubset<T, DailyRepaymentCreateArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyRepayments.
     * @param {DailyRepaymentCreateManyArgs} args - Arguments to create many DailyRepayments.
     * @example
     * // Create many DailyRepayments
     * const dailyRepayment = await prisma.dailyRepayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRepaymentCreateManyArgs>(args?: SelectSubset<T, DailyRepaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRepayments and returns the data saved in the database.
     * @param {DailyRepaymentCreateManyAndReturnArgs} args - Arguments to create many DailyRepayments.
     * @example
     * // Create many DailyRepayments
     * const dailyRepayment = await prisma.dailyRepayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRepayments and only return the `id`
     * const dailyRepaymentWithIdOnly = await prisma.dailyRepayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRepaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRepaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyRepayment.
     * @param {DailyRepaymentDeleteArgs} args - Arguments to delete one DailyRepayment.
     * @example
     * // Delete one DailyRepayment
     * const DailyRepayment = await prisma.dailyRepayment.delete({
     *   where: {
     *     // ... filter to delete one DailyRepayment
     *   }
     * })
     * 
     */
    delete<T extends DailyRepaymentDeleteArgs>(args: SelectSubset<T, DailyRepaymentDeleteArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyRepayment.
     * @param {DailyRepaymentUpdateArgs} args - Arguments to update one DailyRepayment.
     * @example
     * // Update one DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRepaymentUpdateArgs>(args: SelectSubset<T, DailyRepaymentUpdateArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyRepayments.
     * @param {DailyRepaymentDeleteManyArgs} args - Arguments to filter DailyRepayments to delete.
     * @example
     * // Delete a few DailyRepayments
     * const { count } = await prisma.dailyRepayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRepaymentDeleteManyArgs>(args?: SelectSubset<T, DailyRepaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRepayments
     * const dailyRepayment = await prisma.dailyRepayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRepaymentUpdateManyArgs>(args: SelectSubset<T, DailyRepaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRepayments and returns the data updated in the database.
     * @param {DailyRepaymentUpdateManyAndReturnArgs} args - Arguments to update many DailyRepayments.
     * @example
     * // Update many DailyRepayments
     * const dailyRepayment = await prisma.dailyRepayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyRepayments and only return the `id`
     * const dailyRepaymentWithIdOnly = await prisma.dailyRepayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyRepaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyRepaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyRepayment.
     * @param {DailyRepaymentUpsertArgs} args - Arguments to update or create a DailyRepayment.
     * @example
     * // Update or create a DailyRepayment
     * const dailyRepayment = await prisma.dailyRepayment.upsert({
     *   create: {
     *     // ... data to create a DailyRepayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRepayment we want to update
     *   }
     * })
     */
    upsert<T extends DailyRepaymentUpsertArgs>(args: SelectSubset<T, DailyRepaymentUpsertArgs<ExtArgs>>): Prisma__DailyRepaymentClient<$Result.GetResult<Prisma.$DailyRepaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentCountArgs} args - Arguments to filter DailyRepayments to count.
     * @example
     * // Count the number of DailyRepayments
     * const count = await prisma.dailyRepayment.count({
     *   where: {
     *     // ... the filter for the DailyRepayments we want to count
     *   }
     * })
    **/
    count<T extends DailyRepaymentCountArgs>(
      args?: Subset<T, DailyRepaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRepaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRepaymentAggregateArgs>(args: Subset<T, DailyRepaymentAggregateArgs>): Prisma.PrismaPromise<GetDailyRepaymentAggregateType<T>>

    /**
     * Group by DailyRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRepaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRepaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRepaymentGroupByArgs['orderBy'] }
        : { orderBy?: DailyRepaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRepaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRepaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRepayment model
   */
  readonly fields: DailyRepaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRepayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRepaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paidBy<T extends DailyRepayment$paidByArgs<ExtArgs> = {}>(args?: Subset<T, DailyRepayment$paidByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends DailyRepayment$branchArgs<ExtArgs> = {}>(args?: Subset<T, DailyRepayment$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRepayment model
   */
  interface DailyRepaymentFieldRefs {
    readonly id: FieldRef<"DailyRepayment", 'Int'>
    readonly transactionId: FieldRef<"DailyRepayment", 'Int'>
    readonly amount: FieldRef<"DailyRepayment", 'Float'>
    readonly channel: FieldRef<"DailyRepayment", 'String'>
    readonly paidAt: FieldRef<"DailyRepayment", 'DateTime'>
    readonly paidByUserId: FieldRef<"DailyRepayment", 'Int'>
    readonly branchId: FieldRef<"DailyRepayment", 'Int'>
    readonly createdAt: FieldRef<"DailyRepayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyRepayment findUnique
   */
  export type DailyRepaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which DailyRepayment to fetch.
     */
    where: DailyRepaymentWhereUniqueInput
  }

  /**
   * DailyRepayment findUniqueOrThrow
   */
  export type DailyRepaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which DailyRepayment to fetch.
     */
    where: DailyRepaymentWhereUniqueInput
  }

  /**
   * DailyRepayment findFirst
   */
  export type DailyRepaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which DailyRepayment to fetch.
     */
    where?: DailyRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRepayments to fetch.
     */
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRepayments.
     */
    cursor?: DailyRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRepayments.
     */
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * DailyRepayment findFirstOrThrow
   */
  export type DailyRepaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which DailyRepayment to fetch.
     */
    where?: DailyRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRepayments to fetch.
     */
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRepayments.
     */
    cursor?: DailyRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRepayments.
     */
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * DailyRepayment findMany
   */
  export type DailyRepaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which DailyRepayments to fetch.
     */
    where?: DailyRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRepayments to fetch.
     */
    orderBy?: DailyRepaymentOrderByWithRelationInput | DailyRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRepayments.
     */
    cursor?: DailyRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRepayments.
     */
    skip?: number
    distinct?: DailyRepaymentScalarFieldEnum | DailyRepaymentScalarFieldEnum[]
  }

  /**
   * DailyRepayment create
   */
  export type DailyRepaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRepayment.
     */
    data: XOR<DailyRepaymentCreateInput, DailyRepaymentUncheckedCreateInput>
  }

  /**
   * DailyRepayment createMany
   */
  export type DailyRepaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRepayments.
     */
    data: DailyRepaymentCreateManyInput | DailyRepaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRepayment createManyAndReturn
   */
  export type DailyRepaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * The data used to create many DailyRepayments.
     */
    data: DailyRepaymentCreateManyInput | DailyRepaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRepayment update
   */
  export type DailyRepaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRepayment.
     */
    data: XOR<DailyRepaymentUpdateInput, DailyRepaymentUncheckedUpdateInput>
    /**
     * Choose, which DailyRepayment to update.
     */
    where: DailyRepaymentWhereUniqueInput
  }

  /**
   * DailyRepayment updateMany
   */
  export type DailyRepaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRepayments.
     */
    data: XOR<DailyRepaymentUpdateManyMutationInput, DailyRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which DailyRepayments to update
     */
    where?: DailyRepaymentWhereInput
    /**
     * Limit how many DailyRepayments to update.
     */
    limit?: number
  }

  /**
   * DailyRepayment updateManyAndReturn
   */
  export type DailyRepaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * The data used to update DailyRepayments.
     */
    data: XOR<DailyRepaymentUpdateManyMutationInput, DailyRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which DailyRepayments to update
     */
    where?: DailyRepaymentWhereInput
    /**
     * Limit how many DailyRepayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRepayment upsert
   */
  export type DailyRepaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRepayment to update in case it exists.
     */
    where: DailyRepaymentWhereUniqueInput
    /**
     * In case the DailyRepayment found by the `where` argument doesn't exist, create a new DailyRepayment with this data.
     */
    create: XOR<DailyRepaymentCreateInput, DailyRepaymentUncheckedCreateInput>
    /**
     * In case the DailyRepayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRepaymentUpdateInput, DailyRepaymentUncheckedUpdateInput>
  }

  /**
   * DailyRepayment delete
   */
  export type DailyRepaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
    /**
     * Filter which DailyRepayment to delete.
     */
    where: DailyRepaymentWhereUniqueInput
  }

  /**
   * DailyRepayment deleteMany
   */
  export type DailyRepaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRepayments to delete
     */
    where?: DailyRepaymentWhereInput
    /**
     * Limit how many DailyRepayments to delete.
     */
    limit?: number
  }

  /**
   * DailyRepayment.paidBy
   */
  export type DailyRepayment$paidByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DailyRepayment.branch
   */
  export type DailyRepayment$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * DailyRepayment without action
   */
  export type DailyRepaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRepayment
     */
    select?: DailyRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRepayment
     */
    omit?: DailyRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRepaymentInclude<ExtArgs> | null
  }


  /**
   * Model CreditRepayment
   */

  export type AggregateCreditRepayment = {
    _count: CreditRepaymentCountAggregateOutputType | null
    _avg: CreditRepaymentAvgAggregateOutputType | null
    _sum: CreditRepaymentSumAggregateOutputType | null
    _min: CreditRepaymentMinAggregateOutputType | null
    _max: CreditRepaymentMaxAggregateOutputType | null
  }

  export type CreditRepaymentAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    monthNumber: number | null
    paidByUserId: number | null
    branchId: number | null
  }

  export type CreditRepaymentSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    monthNumber: number | null
    paidByUserId: number | null
    branchId: number | null
  }

  export type CreditRepaymentMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    channel: string | null
    month: string | null
    monthNumber: number | null
    paidAt: Date | null
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date | null
  }

  export type CreditRepaymentMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    scheduleId: number | null
    amount: number | null
    channel: string | null
    month: string | null
    monthNumber: number | null
    paidAt: Date | null
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date | null
  }

  export type CreditRepaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    scheduleId: number
    amount: number
    channel: number
    month: number
    monthNumber: number
    paidAt: number
    paidByUserId: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type CreditRepaymentAvgAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    monthNumber?: true
    paidByUserId?: true
    branchId?: true
  }

  export type CreditRepaymentSumAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    monthNumber?: true
    paidByUserId?: true
    branchId?: true
  }

  export type CreditRepaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    month?: true
    monthNumber?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
  }

  export type CreditRepaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    month?: true
    monthNumber?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
  }

  export type CreditRepaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    scheduleId?: true
    amount?: true
    channel?: true
    month?: true
    monthNumber?: true
    paidAt?: true
    paidByUserId?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type CreditRepaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditRepayment to aggregate.
     */
    where?: CreditRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRepayments to fetch.
     */
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditRepayments
    **/
    _count?: true | CreditRepaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditRepaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditRepaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditRepaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditRepaymentMaxAggregateInputType
  }

  export type GetCreditRepaymentAggregateType<T extends CreditRepaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditRepayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditRepayment[P]>
      : GetScalarType<T[P], AggregateCreditRepayment[P]>
  }




  export type CreditRepaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditRepaymentWhereInput
    orderBy?: CreditRepaymentOrderByWithAggregationInput | CreditRepaymentOrderByWithAggregationInput[]
    by: CreditRepaymentScalarFieldEnum[] | CreditRepaymentScalarFieldEnum
    having?: CreditRepaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditRepaymentCountAggregateInputType | true
    _avg?: CreditRepaymentAvgAggregateInputType
    _sum?: CreditRepaymentSumAggregateInputType
    _min?: CreditRepaymentMinAggregateInputType
    _max?: CreditRepaymentMaxAggregateInputType
  }

  export type CreditRepaymentGroupByOutputType = {
    id: number
    transactionId: number
    scheduleId: number | null
    amount: number
    channel: string
    month: string | null
    monthNumber: number | null
    paidAt: Date
    paidByUserId: number | null
    branchId: number | null
    createdAt: Date
    _count: CreditRepaymentCountAggregateOutputType | null
    _avg: CreditRepaymentAvgAggregateOutputType | null
    _sum: CreditRepaymentSumAggregateOutputType | null
    _min: CreditRepaymentMinAggregateOutputType | null
    _max: CreditRepaymentMaxAggregateOutputType | null
  }

  type GetCreditRepaymentGroupByPayload<T extends CreditRepaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditRepaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditRepaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditRepaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CreditRepaymentGroupByOutputType[P]>
        }
      >
    >


  export type CreditRepaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    month?: boolean
    monthNumber?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["creditRepayment"]>

  export type CreditRepaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    month?: boolean
    monthNumber?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["creditRepayment"]>

  export type CreditRepaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    month?: boolean
    monthNumber?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["creditRepayment"]>

  export type CreditRepaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    scheduleId?: boolean
    amount?: boolean
    channel?: boolean
    month?: boolean
    monthNumber?: boolean
    paidAt?: boolean
    paidByUserId?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type CreditRepaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "scheduleId" | "amount" | "channel" | "month" | "monthNumber" | "paidAt" | "paidByUserId" | "branchId" | "createdAt", ExtArgs["result"]["creditRepayment"]>
  export type CreditRepaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }
  export type CreditRepaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }
  export type CreditRepaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    schedule?: boolean | CreditRepayment$scheduleArgs<ExtArgs>
    paidBy?: boolean | CreditRepayment$paidByArgs<ExtArgs>
    branch?: boolean | CreditRepayment$branchArgs<ExtArgs>
  }

  export type $CreditRepaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditRepayment"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      schedule: Prisma.$PaymentSchedulePayload<ExtArgs> | null
      paidBy: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      scheduleId: number | null
      amount: number
      channel: string
      month: string | null
      monthNumber: number | null
      paidAt: Date
      paidByUserId: number | null
      branchId: number | null
      createdAt: Date
    }, ExtArgs["result"]["creditRepayment"]>
    composites: {}
  }

  type CreditRepaymentGetPayload<S extends boolean | null | undefined | CreditRepaymentDefaultArgs> = $Result.GetResult<Prisma.$CreditRepaymentPayload, S>

  type CreditRepaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditRepaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditRepaymentCountAggregateInputType | true
    }

  export interface CreditRepaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditRepayment'], meta: { name: 'CreditRepayment' } }
    /**
     * Find zero or one CreditRepayment that matches the filter.
     * @param {CreditRepaymentFindUniqueArgs} args - Arguments to find a CreditRepayment
     * @example
     * // Get one CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditRepaymentFindUniqueArgs>(args: SelectSubset<T, CreditRepaymentFindUniqueArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditRepayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditRepaymentFindUniqueOrThrowArgs} args - Arguments to find a CreditRepayment
     * @example
     * // Get one CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditRepaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditRepaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditRepayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentFindFirstArgs} args - Arguments to find a CreditRepayment
     * @example
     * // Get one CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditRepaymentFindFirstArgs>(args?: SelectSubset<T, CreditRepaymentFindFirstArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditRepayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentFindFirstOrThrowArgs} args - Arguments to find a CreditRepayment
     * @example
     * // Get one CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditRepaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditRepaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditRepayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditRepayments
     * const creditRepayments = await prisma.creditRepayment.findMany()
     * 
     * // Get first 10 CreditRepayments
     * const creditRepayments = await prisma.creditRepayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditRepaymentWithIdOnly = await prisma.creditRepayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditRepaymentFindManyArgs>(args?: SelectSubset<T, CreditRepaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditRepayment.
     * @param {CreditRepaymentCreateArgs} args - Arguments to create a CreditRepayment.
     * @example
     * // Create one CreditRepayment
     * const CreditRepayment = await prisma.creditRepayment.create({
     *   data: {
     *     // ... data to create a CreditRepayment
     *   }
     * })
     * 
     */
    create<T extends CreditRepaymentCreateArgs>(args: SelectSubset<T, CreditRepaymentCreateArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditRepayments.
     * @param {CreditRepaymentCreateManyArgs} args - Arguments to create many CreditRepayments.
     * @example
     * // Create many CreditRepayments
     * const creditRepayment = await prisma.creditRepayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditRepaymentCreateManyArgs>(args?: SelectSubset<T, CreditRepaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditRepayments and returns the data saved in the database.
     * @param {CreditRepaymentCreateManyAndReturnArgs} args - Arguments to create many CreditRepayments.
     * @example
     * // Create many CreditRepayments
     * const creditRepayment = await prisma.creditRepayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditRepayments and only return the `id`
     * const creditRepaymentWithIdOnly = await prisma.creditRepayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditRepaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditRepaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditRepayment.
     * @param {CreditRepaymentDeleteArgs} args - Arguments to delete one CreditRepayment.
     * @example
     * // Delete one CreditRepayment
     * const CreditRepayment = await prisma.creditRepayment.delete({
     *   where: {
     *     // ... filter to delete one CreditRepayment
     *   }
     * })
     * 
     */
    delete<T extends CreditRepaymentDeleteArgs>(args: SelectSubset<T, CreditRepaymentDeleteArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditRepayment.
     * @param {CreditRepaymentUpdateArgs} args - Arguments to update one CreditRepayment.
     * @example
     * // Update one CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditRepaymentUpdateArgs>(args: SelectSubset<T, CreditRepaymentUpdateArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditRepayments.
     * @param {CreditRepaymentDeleteManyArgs} args - Arguments to filter CreditRepayments to delete.
     * @example
     * // Delete a few CreditRepayments
     * const { count } = await prisma.creditRepayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditRepaymentDeleteManyArgs>(args?: SelectSubset<T, CreditRepaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditRepayments
     * const creditRepayment = await prisma.creditRepayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditRepaymentUpdateManyArgs>(args: SelectSubset<T, CreditRepaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditRepayments and returns the data updated in the database.
     * @param {CreditRepaymentUpdateManyAndReturnArgs} args - Arguments to update many CreditRepayments.
     * @example
     * // Update many CreditRepayments
     * const creditRepayment = await prisma.creditRepayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditRepayments and only return the `id`
     * const creditRepaymentWithIdOnly = await prisma.creditRepayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditRepaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditRepaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditRepayment.
     * @param {CreditRepaymentUpsertArgs} args - Arguments to update or create a CreditRepayment.
     * @example
     * // Update or create a CreditRepayment
     * const creditRepayment = await prisma.creditRepayment.upsert({
     *   create: {
     *     // ... data to create a CreditRepayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditRepayment we want to update
     *   }
     * })
     */
    upsert<T extends CreditRepaymentUpsertArgs>(args: SelectSubset<T, CreditRepaymentUpsertArgs<ExtArgs>>): Prisma__CreditRepaymentClient<$Result.GetResult<Prisma.$CreditRepaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditRepayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentCountArgs} args - Arguments to filter CreditRepayments to count.
     * @example
     * // Count the number of CreditRepayments
     * const count = await prisma.creditRepayment.count({
     *   where: {
     *     // ... the filter for the CreditRepayments we want to count
     *   }
     * })
    **/
    count<T extends CreditRepaymentCountArgs>(
      args?: Subset<T, CreditRepaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditRepaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditRepaymentAggregateArgs>(args: Subset<T, CreditRepaymentAggregateArgs>): Prisma.PrismaPromise<GetCreditRepaymentAggregateType<T>>

    /**
     * Group by CreditRepayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRepaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditRepaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditRepaymentGroupByArgs['orderBy'] }
        : { orderBy?: CreditRepaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditRepaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditRepaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditRepayment model
   */
  readonly fields: CreditRepaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditRepayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditRepaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends CreditRepayment$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, CreditRepayment$scheduleArgs<ExtArgs>>): Prisma__PaymentScheduleClient<$Result.GetResult<Prisma.$PaymentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paidBy<T extends CreditRepayment$paidByArgs<ExtArgs> = {}>(args?: Subset<T, CreditRepayment$paidByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends CreditRepayment$branchArgs<ExtArgs> = {}>(args?: Subset<T, CreditRepayment$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditRepayment model
   */
  interface CreditRepaymentFieldRefs {
    readonly id: FieldRef<"CreditRepayment", 'Int'>
    readonly transactionId: FieldRef<"CreditRepayment", 'Int'>
    readonly scheduleId: FieldRef<"CreditRepayment", 'Int'>
    readonly amount: FieldRef<"CreditRepayment", 'Float'>
    readonly channel: FieldRef<"CreditRepayment", 'String'>
    readonly month: FieldRef<"CreditRepayment", 'String'>
    readonly monthNumber: FieldRef<"CreditRepayment", 'Int'>
    readonly paidAt: FieldRef<"CreditRepayment", 'DateTime'>
    readonly paidByUserId: FieldRef<"CreditRepayment", 'Int'>
    readonly branchId: FieldRef<"CreditRepayment", 'Int'>
    readonly createdAt: FieldRef<"CreditRepayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditRepayment findUnique
   */
  export type CreditRepaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditRepayment to fetch.
     */
    where: CreditRepaymentWhereUniqueInput
  }

  /**
   * CreditRepayment findUniqueOrThrow
   */
  export type CreditRepaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditRepayment to fetch.
     */
    where: CreditRepaymentWhereUniqueInput
  }

  /**
   * CreditRepayment findFirst
   */
  export type CreditRepaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditRepayment to fetch.
     */
    where?: CreditRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRepayments to fetch.
     */
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditRepayments.
     */
    cursor?: CreditRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditRepayments.
     */
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * CreditRepayment findFirstOrThrow
   */
  export type CreditRepaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditRepayment to fetch.
     */
    where?: CreditRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRepayments to fetch.
     */
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditRepayments.
     */
    cursor?: CreditRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRepayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditRepayments.
     */
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * CreditRepayment findMany
   */
  export type CreditRepaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditRepayments to fetch.
     */
    where?: CreditRepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRepayments to fetch.
     */
    orderBy?: CreditRepaymentOrderByWithRelationInput | CreditRepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditRepayments.
     */
    cursor?: CreditRepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRepayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRepayments.
     */
    skip?: number
    distinct?: CreditRepaymentScalarFieldEnum | CreditRepaymentScalarFieldEnum[]
  }

  /**
   * CreditRepayment create
   */
  export type CreditRepaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditRepayment.
     */
    data: XOR<CreditRepaymentCreateInput, CreditRepaymentUncheckedCreateInput>
  }

  /**
   * CreditRepayment createMany
   */
  export type CreditRepaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditRepayments.
     */
    data: CreditRepaymentCreateManyInput | CreditRepaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditRepayment createManyAndReturn
   */
  export type CreditRepaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * The data used to create many CreditRepayments.
     */
    data: CreditRepaymentCreateManyInput | CreditRepaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditRepayment update
   */
  export type CreditRepaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditRepayment.
     */
    data: XOR<CreditRepaymentUpdateInput, CreditRepaymentUncheckedUpdateInput>
    /**
     * Choose, which CreditRepayment to update.
     */
    where: CreditRepaymentWhereUniqueInput
  }

  /**
   * CreditRepayment updateMany
   */
  export type CreditRepaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditRepayments.
     */
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which CreditRepayments to update
     */
    where?: CreditRepaymentWhereInput
    /**
     * Limit how many CreditRepayments to update.
     */
    limit?: number
  }

  /**
   * CreditRepayment updateManyAndReturn
   */
  export type CreditRepaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * The data used to update CreditRepayments.
     */
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyInput>
    /**
     * Filter which CreditRepayments to update
     */
    where?: CreditRepaymentWhereInput
    /**
     * Limit how many CreditRepayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditRepayment upsert
   */
  export type CreditRepaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditRepayment to update in case it exists.
     */
    where: CreditRepaymentWhereUniqueInput
    /**
     * In case the CreditRepayment found by the `where` argument doesn't exist, create a new CreditRepayment with this data.
     */
    create: XOR<CreditRepaymentCreateInput, CreditRepaymentUncheckedCreateInput>
    /**
     * In case the CreditRepayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditRepaymentUpdateInput, CreditRepaymentUncheckedUpdateInput>
  }

  /**
   * CreditRepayment delete
   */
  export type CreditRepaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
    /**
     * Filter which CreditRepayment to delete.
     */
    where: CreditRepaymentWhereUniqueInput
  }

  /**
   * CreditRepayment deleteMany
   */
  export type CreditRepaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditRepayments to delete
     */
    where?: CreditRepaymentWhereInput
    /**
     * Limit how many CreditRepayments to delete.
     */
    limit?: number
  }

  /**
   * CreditRepayment.schedule
   */
  export type CreditRepayment$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     */
    select?: PaymentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSchedule
     */
    omit?: PaymentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentScheduleInclude<ExtArgs> | null
    where?: PaymentScheduleWhereInput
  }

  /**
   * CreditRepayment.paidBy
   */
  export type CreditRepayment$paidByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CreditRepayment.branch
   */
  export type CreditRepayment$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * CreditRepayment without action
   */
  export type CreditRepaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditRepayment
     */
    select?: CreditRepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditRepayment
     */
    omit?: CreditRepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditRepaymentInclude<ExtArgs> | null
  }


  /**
   * Model CashierReport
   */

  export type AggregateCashierReport = {
    _count: CashierReportCountAggregateOutputType | null
    _avg: CashierReportAvgAggregateOutputType | null
    _sum: CashierReportSumAggregateOutputType | null
    _min: CashierReportMinAggregateOutputType | null
    _max: CashierReportMaxAggregateOutputType | null
  }

  export type CashierReportAvgAggregateOutputType = {
    id: number | null
    cashierId: number | null
    branchId: number | null
    cashTotal: number | null
    cardTotal: number | null
    creditTotal: number | null
    installmentTotal: number | null
    upfrontTotal: number | null
    upfrontCash: number | null
    upfrontCard: number | null
    soldQuantity: number | null
    soldAmount: number | null
    repaymentTotal: number | null
    defectivePlus: number | null
    defectiveMinus: number | null
  }

  export type CashierReportSumAggregateOutputType = {
    id: number | null
    cashierId: number | null
    branchId: number | null
    cashTotal: number | null
    cardTotal: number | null
    creditTotal: number | null
    installmentTotal: number | null
    upfrontTotal: number | null
    upfrontCash: number | null
    upfrontCard: number | null
    soldQuantity: number | null
    soldAmount: number | null
    repaymentTotal: number | null
    defectivePlus: number | null
    defectiveMinus: number | null
  }

  export type CashierReportMinAggregateOutputType = {
    id: number | null
    cashierId: number | null
    branchId: number | null
    reportDate: Date | null
    cashTotal: number | null
    cardTotal: number | null
    creditTotal: number | null
    installmentTotal: number | null
    upfrontTotal: number | null
    upfrontCash: number | null
    upfrontCard: number | null
    soldQuantity: number | null
    soldAmount: number | null
    repaymentTotal: number | null
    defectivePlus: number | null
    defectiveMinus: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashierReportMaxAggregateOutputType = {
    id: number | null
    cashierId: number | null
    branchId: number | null
    reportDate: Date | null
    cashTotal: number | null
    cardTotal: number | null
    creditTotal: number | null
    installmentTotal: number | null
    upfrontTotal: number | null
    upfrontCash: number | null
    upfrontCard: number | null
    soldQuantity: number | null
    soldAmount: number | null
    repaymentTotal: number | null
    defectivePlus: number | null
    defectiveMinus: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashierReportCountAggregateOutputType = {
    id: number
    cashierId: number
    branchId: number
    reportDate: number
    cashTotal: number
    cardTotal: number
    creditTotal: number
    installmentTotal: number
    upfrontTotal: number
    upfrontCash: number
    upfrontCard: number
    soldQuantity: number
    soldAmount: number
    repaymentTotal: number
    defectivePlus: number
    defectiveMinus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashierReportAvgAggregateInputType = {
    id?: true
    cashierId?: true
    branchId?: true
    cashTotal?: true
    cardTotal?: true
    creditTotal?: true
    installmentTotal?: true
    upfrontTotal?: true
    upfrontCash?: true
    upfrontCard?: true
    soldQuantity?: true
    soldAmount?: true
    repaymentTotal?: true
    defectivePlus?: true
    defectiveMinus?: true
  }

  export type CashierReportSumAggregateInputType = {
    id?: true
    cashierId?: true
    branchId?: true
    cashTotal?: true
    cardTotal?: true
    creditTotal?: true
    installmentTotal?: true
    upfrontTotal?: true
    upfrontCash?: true
    upfrontCard?: true
    soldQuantity?: true
    soldAmount?: true
    repaymentTotal?: true
    defectivePlus?: true
    defectiveMinus?: true
  }

  export type CashierReportMinAggregateInputType = {
    id?: true
    cashierId?: true
    branchId?: true
    reportDate?: true
    cashTotal?: true
    cardTotal?: true
    creditTotal?: true
    installmentTotal?: true
    upfrontTotal?: true
    upfrontCash?: true
    upfrontCard?: true
    soldQuantity?: true
    soldAmount?: true
    repaymentTotal?: true
    defectivePlus?: true
    defectiveMinus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashierReportMaxAggregateInputType = {
    id?: true
    cashierId?: true
    branchId?: true
    reportDate?: true
    cashTotal?: true
    cardTotal?: true
    creditTotal?: true
    installmentTotal?: true
    upfrontTotal?: true
    upfrontCash?: true
    upfrontCard?: true
    soldQuantity?: true
    soldAmount?: true
    repaymentTotal?: true
    defectivePlus?: true
    defectiveMinus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashierReportCountAggregateInputType = {
    id?: true
    cashierId?: true
    branchId?: true
    reportDate?: true
    cashTotal?: true
    cardTotal?: true
    creditTotal?: true
    installmentTotal?: true
    upfrontTotal?: true
    upfrontCash?: true
    upfrontCard?: true
    soldQuantity?: true
    soldAmount?: true
    repaymentTotal?: true
    defectivePlus?: true
    defectiveMinus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashierReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierReport to aggregate.
     */
    where?: CashierReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierReports to fetch.
     */
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashierReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashierReports
    **/
    _count?: true | CashierReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashierReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashierReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashierReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashierReportMaxAggregateInputType
  }

  export type GetCashierReportAggregateType<T extends CashierReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCashierReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashierReport[P]>
      : GetScalarType<T[P], AggregateCashierReport[P]>
  }




  export type CashierReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierReportWhereInput
    orderBy?: CashierReportOrderByWithAggregationInput | CashierReportOrderByWithAggregationInput[]
    by: CashierReportScalarFieldEnum[] | CashierReportScalarFieldEnum
    having?: CashierReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashierReportCountAggregateInputType | true
    _avg?: CashierReportAvgAggregateInputType
    _sum?: CashierReportSumAggregateInputType
    _min?: CashierReportMinAggregateInputType
    _max?: CashierReportMaxAggregateInputType
  }

  export type CashierReportGroupByOutputType = {
    id: number
    cashierId: number
    branchId: number
    reportDate: Date
    cashTotal: number
    cardTotal: number
    creditTotal: number
    installmentTotal: number
    upfrontTotal: number
    upfrontCash: number
    upfrontCard: number
    soldQuantity: number
    soldAmount: number
    repaymentTotal: number
    defectivePlus: number
    defectiveMinus: number
    createdAt: Date
    updatedAt: Date
    _count: CashierReportCountAggregateOutputType | null
    _avg: CashierReportAvgAggregateOutputType | null
    _sum: CashierReportSumAggregateOutputType | null
    _min: CashierReportMinAggregateOutputType | null
    _max: CashierReportMaxAggregateOutputType | null
  }

  type GetCashierReportGroupByPayload<T extends CashierReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashierReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashierReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashierReportGroupByOutputType[P]>
            : GetScalarType<T[P], CashierReportGroupByOutputType[P]>
        }
      >
    >


  export type CashierReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cashierId?: boolean
    branchId?: boolean
    reportDate?: boolean
    cashTotal?: boolean
    cardTotal?: boolean
    creditTotal?: boolean
    installmentTotal?: boolean
    upfrontTotal?: boolean
    upfrontCash?: boolean
    upfrontCard?: boolean
    soldQuantity?: boolean
    soldAmount?: boolean
    repaymentTotal?: boolean
    defectivePlus?: boolean
    defectiveMinus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashierReport"]>

  export type CashierReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cashierId?: boolean
    branchId?: boolean
    reportDate?: boolean
    cashTotal?: boolean
    cardTotal?: boolean
    creditTotal?: boolean
    installmentTotal?: boolean
    upfrontTotal?: boolean
    upfrontCash?: boolean
    upfrontCard?: boolean
    soldQuantity?: boolean
    soldAmount?: boolean
    repaymentTotal?: boolean
    defectivePlus?: boolean
    defectiveMinus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashierReport"]>

  export type CashierReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cashierId?: boolean
    branchId?: boolean
    reportDate?: boolean
    cashTotal?: boolean
    cardTotal?: boolean
    creditTotal?: boolean
    installmentTotal?: boolean
    upfrontTotal?: boolean
    upfrontCash?: boolean
    upfrontCard?: boolean
    soldQuantity?: boolean
    soldAmount?: boolean
    repaymentTotal?: boolean
    defectivePlus?: boolean
    defectiveMinus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashierReport"]>

  export type CashierReportSelectScalar = {
    id?: boolean
    cashierId?: boolean
    branchId?: boolean
    reportDate?: boolean
    cashTotal?: boolean
    cardTotal?: boolean
    creditTotal?: boolean
    installmentTotal?: boolean
    upfrontTotal?: boolean
    upfrontCash?: boolean
    upfrontCard?: boolean
    soldQuantity?: boolean
    soldAmount?: boolean
    repaymentTotal?: boolean
    defectivePlus?: boolean
    defectiveMinus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashierReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cashierId" | "branchId" | "reportDate" | "cashTotal" | "cardTotal" | "creditTotal" | "installmentTotal" | "upfrontTotal" | "upfrontCash" | "upfrontCard" | "soldQuantity" | "soldAmount" | "repaymentTotal" | "defectivePlus" | "defectiveMinus" | "createdAt" | "updatedAt", ExtArgs["result"]["cashierReport"]>
  export type CashierReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type CashierReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type CashierReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $CashierReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashierReport"
    objects: {
      cashier: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cashierId: number
      branchId: number
      reportDate: Date
      cashTotal: number
      cardTotal: number
      creditTotal: number
      installmentTotal: number
      upfrontTotal: number
      upfrontCash: number
      upfrontCard: number
      soldQuantity: number
      soldAmount: number
      repaymentTotal: number
      defectivePlus: number
      defectiveMinus: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashierReport"]>
    composites: {}
  }

  type CashierReportGetPayload<S extends boolean | null | undefined | CashierReportDefaultArgs> = $Result.GetResult<Prisma.$CashierReportPayload, S>

  type CashierReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashierReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashierReportCountAggregateInputType | true
    }

  export interface CashierReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashierReport'], meta: { name: 'CashierReport' } }
    /**
     * Find zero or one CashierReport that matches the filter.
     * @param {CashierReportFindUniqueArgs} args - Arguments to find a CashierReport
     * @example
     * // Get one CashierReport
     * const cashierReport = await prisma.cashierReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashierReportFindUniqueArgs>(args: SelectSubset<T, CashierReportFindUniqueArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashierReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashierReportFindUniqueOrThrowArgs} args - Arguments to find a CashierReport
     * @example
     * // Get one CashierReport
     * const cashierReport = await prisma.cashierReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashierReportFindUniqueOrThrowArgs>(args: SelectSubset<T, CashierReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashierReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportFindFirstArgs} args - Arguments to find a CashierReport
     * @example
     * // Get one CashierReport
     * const cashierReport = await prisma.cashierReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashierReportFindFirstArgs>(args?: SelectSubset<T, CashierReportFindFirstArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashierReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportFindFirstOrThrowArgs} args - Arguments to find a CashierReport
     * @example
     * // Get one CashierReport
     * const cashierReport = await prisma.cashierReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashierReportFindFirstOrThrowArgs>(args?: SelectSubset<T, CashierReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashierReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashierReports
     * const cashierReports = await prisma.cashierReport.findMany()
     * 
     * // Get first 10 CashierReports
     * const cashierReports = await prisma.cashierReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashierReportWithIdOnly = await prisma.cashierReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashierReportFindManyArgs>(args?: SelectSubset<T, CashierReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashierReport.
     * @param {CashierReportCreateArgs} args - Arguments to create a CashierReport.
     * @example
     * // Create one CashierReport
     * const CashierReport = await prisma.cashierReport.create({
     *   data: {
     *     // ... data to create a CashierReport
     *   }
     * })
     * 
     */
    create<T extends CashierReportCreateArgs>(args: SelectSubset<T, CashierReportCreateArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashierReports.
     * @param {CashierReportCreateManyArgs} args - Arguments to create many CashierReports.
     * @example
     * // Create many CashierReports
     * const cashierReport = await prisma.cashierReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashierReportCreateManyArgs>(args?: SelectSubset<T, CashierReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashierReports and returns the data saved in the database.
     * @param {CashierReportCreateManyAndReturnArgs} args - Arguments to create many CashierReports.
     * @example
     * // Create many CashierReports
     * const cashierReport = await prisma.cashierReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashierReports and only return the `id`
     * const cashierReportWithIdOnly = await prisma.cashierReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashierReportCreateManyAndReturnArgs>(args?: SelectSubset<T, CashierReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashierReport.
     * @param {CashierReportDeleteArgs} args - Arguments to delete one CashierReport.
     * @example
     * // Delete one CashierReport
     * const CashierReport = await prisma.cashierReport.delete({
     *   where: {
     *     // ... filter to delete one CashierReport
     *   }
     * })
     * 
     */
    delete<T extends CashierReportDeleteArgs>(args: SelectSubset<T, CashierReportDeleteArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashierReport.
     * @param {CashierReportUpdateArgs} args - Arguments to update one CashierReport.
     * @example
     * // Update one CashierReport
     * const cashierReport = await prisma.cashierReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashierReportUpdateArgs>(args: SelectSubset<T, CashierReportUpdateArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashierReports.
     * @param {CashierReportDeleteManyArgs} args - Arguments to filter CashierReports to delete.
     * @example
     * // Delete a few CashierReports
     * const { count } = await prisma.cashierReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashierReportDeleteManyArgs>(args?: SelectSubset<T, CashierReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashierReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashierReports
     * const cashierReport = await prisma.cashierReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashierReportUpdateManyArgs>(args: SelectSubset<T, CashierReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashierReports and returns the data updated in the database.
     * @param {CashierReportUpdateManyAndReturnArgs} args - Arguments to update many CashierReports.
     * @example
     * // Update many CashierReports
     * const cashierReport = await prisma.cashierReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashierReports and only return the `id`
     * const cashierReportWithIdOnly = await prisma.cashierReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashierReportUpdateManyAndReturnArgs>(args: SelectSubset<T, CashierReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashierReport.
     * @param {CashierReportUpsertArgs} args - Arguments to update or create a CashierReport.
     * @example
     * // Update or create a CashierReport
     * const cashierReport = await prisma.cashierReport.upsert({
     *   create: {
     *     // ... data to create a CashierReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashierReport we want to update
     *   }
     * })
     */
    upsert<T extends CashierReportUpsertArgs>(args: SelectSubset<T, CashierReportUpsertArgs<ExtArgs>>): Prisma__CashierReportClient<$Result.GetResult<Prisma.$CashierReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashierReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportCountArgs} args - Arguments to filter CashierReports to count.
     * @example
     * // Count the number of CashierReports
     * const count = await prisma.cashierReport.count({
     *   where: {
     *     // ... the filter for the CashierReports we want to count
     *   }
     * })
    **/
    count<T extends CashierReportCountArgs>(
      args?: Subset<T, CashierReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashierReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashierReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashierReportAggregateArgs>(args: Subset<T, CashierReportAggregateArgs>): Prisma.PrismaPromise<GetCashierReportAggregateType<T>>

    /**
     * Group by CashierReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashierReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashierReportGroupByArgs['orderBy'] }
        : { orderBy?: CashierReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashierReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashierReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashierReport model
   */
  readonly fields: CashierReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashierReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashierReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashierReport model
   */
  interface CashierReportFieldRefs {
    readonly id: FieldRef<"CashierReport", 'Int'>
    readonly cashierId: FieldRef<"CashierReport", 'Int'>
    readonly branchId: FieldRef<"CashierReport", 'Int'>
    readonly reportDate: FieldRef<"CashierReport", 'DateTime'>
    readonly cashTotal: FieldRef<"CashierReport", 'Float'>
    readonly cardTotal: FieldRef<"CashierReport", 'Float'>
    readonly creditTotal: FieldRef<"CashierReport", 'Float'>
    readonly installmentTotal: FieldRef<"CashierReport", 'Float'>
    readonly upfrontTotal: FieldRef<"CashierReport", 'Float'>
    readonly upfrontCash: FieldRef<"CashierReport", 'Float'>
    readonly upfrontCard: FieldRef<"CashierReport", 'Float'>
    readonly soldQuantity: FieldRef<"CashierReport", 'Int'>
    readonly soldAmount: FieldRef<"CashierReport", 'Float'>
    readonly repaymentTotal: FieldRef<"CashierReport", 'Float'>
    readonly defectivePlus: FieldRef<"CashierReport", 'Float'>
    readonly defectiveMinus: FieldRef<"CashierReport", 'Float'>
    readonly createdAt: FieldRef<"CashierReport", 'DateTime'>
    readonly updatedAt: FieldRef<"CashierReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashierReport findUnique
   */
  export type CashierReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter, which CashierReport to fetch.
     */
    where: CashierReportWhereUniqueInput
  }

  /**
   * CashierReport findUniqueOrThrow
   */
  export type CashierReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter, which CashierReport to fetch.
     */
    where: CashierReportWhereUniqueInput
  }

  /**
   * CashierReport findFirst
   */
  export type CashierReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter, which CashierReport to fetch.
     */
    where?: CashierReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierReports to fetch.
     */
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierReports.
     */
    cursor?: CashierReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierReports.
     */
    distinct?: CashierReportScalarFieldEnum | CashierReportScalarFieldEnum[]
  }

  /**
   * CashierReport findFirstOrThrow
   */
  export type CashierReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter, which CashierReport to fetch.
     */
    where?: CashierReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierReports to fetch.
     */
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierReports.
     */
    cursor?: CashierReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierReports.
     */
    distinct?: CashierReportScalarFieldEnum | CashierReportScalarFieldEnum[]
  }

  /**
   * CashierReport findMany
   */
  export type CashierReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter, which CashierReports to fetch.
     */
    where?: CashierReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierReports to fetch.
     */
    orderBy?: CashierReportOrderByWithRelationInput | CashierReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashierReports.
     */
    cursor?: CashierReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierReports.
     */
    skip?: number
    distinct?: CashierReportScalarFieldEnum | CashierReportScalarFieldEnum[]
  }

  /**
   * CashierReport create
   */
  export type CashierReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * The data needed to create a CashierReport.
     */
    data: XOR<CashierReportCreateInput, CashierReportUncheckedCreateInput>
  }

  /**
   * CashierReport createMany
   */
  export type CashierReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashierReports.
     */
    data: CashierReportCreateManyInput | CashierReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashierReport createManyAndReturn
   */
  export type CashierReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * The data used to create many CashierReports.
     */
    data: CashierReportCreateManyInput | CashierReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashierReport update
   */
  export type CashierReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * The data needed to update a CashierReport.
     */
    data: XOR<CashierReportUpdateInput, CashierReportUncheckedUpdateInput>
    /**
     * Choose, which CashierReport to update.
     */
    where: CashierReportWhereUniqueInput
  }

  /**
   * CashierReport updateMany
   */
  export type CashierReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashierReports.
     */
    data: XOR<CashierReportUpdateManyMutationInput, CashierReportUncheckedUpdateManyInput>
    /**
     * Filter which CashierReports to update
     */
    where?: CashierReportWhereInput
    /**
     * Limit how many CashierReports to update.
     */
    limit?: number
  }

  /**
   * CashierReport updateManyAndReturn
   */
  export type CashierReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * The data used to update CashierReports.
     */
    data: XOR<CashierReportUpdateManyMutationInput, CashierReportUncheckedUpdateManyInput>
    /**
     * Filter which CashierReports to update
     */
    where?: CashierReportWhereInput
    /**
     * Limit how many CashierReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashierReport upsert
   */
  export type CashierReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * The filter to search for the CashierReport to update in case it exists.
     */
    where: CashierReportWhereUniqueInput
    /**
     * In case the CashierReport found by the `where` argument doesn't exist, create a new CashierReport with this data.
     */
    create: XOR<CashierReportCreateInput, CashierReportUncheckedCreateInput>
    /**
     * In case the CashierReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashierReportUpdateInput, CashierReportUncheckedUpdateInput>
  }

  /**
   * CashierReport delete
   */
  export type CashierReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
    /**
     * Filter which CashierReport to delete.
     */
    where: CashierReportWhereUniqueInput
  }

  /**
   * CashierReport deleteMany
   */
  export type CashierReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierReports to delete
     */
    where?: CashierReportWhereInput
    /**
     * Limit how many CashierReports to delete.
     */
    limit?: number
  }

  /**
   * CashierReport without action
   */
  export type CashierReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierReport
     */
    select?: CashierReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashierReport
     */
    omit?: CashierReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierReportInclude<ExtArgs> | null
  }


  /**
   * Model CurrencyExchangeRate
   */

  export type AggregateCurrencyExchangeRate = {
    _count: CurrencyExchangeRateCountAggregateOutputType | null
    _avg: CurrencyExchangeRateAvgAggregateOutputType | null
    _sum: CurrencyExchangeRateSumAggregateOutputType | null
    _min: CurrencyExchangeRateMinAggregateOutputType | null
    _max: CurrencyExchangeRateMaxAggregateOutputType | null
  }

  export type CurrencyExchangeRateAvgAggregateOutputType = {
    id: number | null
    rate: number | null
    branchId: number | null
    createdBy: number | null
  }

  export type CurrencyExchangeRateSumAggregateOutputType = {
    id: number | null
    rate: number | null
    branchId: number | null
    createdBy: number | null
  }

  export type CurrencyExchangeRateMinAggregateOutputType = {
    id: number | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: number | null
    isActive: boolean | null
    branchId: number | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyExchangeRateMaxAggregateOutputType = {
    id: number | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: number | null
    isActive: boolean | null
    branchId: number | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyExchangeRateCountAggregateOutputType = {
    id: number
    fromCurrency: number
    toCurrency: number
    rate: number
    isActive: number
    branchId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyExchangeRateAvgAggregateInputType = {
    id?: true
    rate?: true
    branchId?: true
    createdBy?: true
  }

  export type CurrencyExchangeRateSumAggregateInputType = {
    id?: true
    rate?: true
    branchId?: true
    createdBy?: true
  }

  export type CurrencyExchangeRateMinAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    isActive?: true
    branchId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyExchangeRateMaxAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    isActive?: true
    branchId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyExchangeRateCountAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    isActive?: true
    branchId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyExchangeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyExchangeRate to aggregate.
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyExchangeRates to fetch.
     */
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrencyExchangeRates
    **/
    _count?: true | CurrencyExchangeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyExchangeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencyExchangeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyExchangeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyExchangeRateMaxAggregateInputType
  }

  export type GetCurrencyExchangeRateAggregateType<T extends CurrencyExchangeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrencyExchangeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrencyExchangeRate[P]>
      : GetScalarType<T[P], AggregateCurrencyExchangeRate[P]>
  }




  export type CurrencyExchangeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyExchangeRateWhereInput
    orderBy?: CurrencyExchangeRateOrderByWithAggregationInput | CurrencyExchangeRateOrderByWithAggregationInput[]
    by: CurrencyExchangeRateScalarFieldEnum[] | CurrencyExchangeRateScalarFieldEnum
    having?: CurrencyExchangeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyExchangeRateCountAggregateInputType | true
    _avg?: CurrencyExchangeRateAvgAggregateInputType
    _sum?: CurrencyExchangeRateSumAggregateInputType
    _min?: CurrencyExchangeRateMinAggregateInputType
    _max?: CurrencyExchangeRateMaxAggregateInputType
  }

  export type CurrencyExchangeRateGroupByOutputType = {
    id: number
    fromCurrency: string
    toCurrency: string
    rate: number
    isActive: boolean
    branchId: number | null
    createdBy: number | null
    createdAt: Date
    updatedAt: Date
    _count: CurrencyExchangeRateCountAggregateOutputType | null
    _avg: CurrencyExchangeRateAvgAggregateOutputType | null
    _sum: CurrencyExchangeRateSumAggregateOutputType | null
    _min: CurrencyExchangeRateMinAggregateOutputType | null
    _max: CurrencyExchangeRateMaxAggregateOutputType | null
  }

  type GetCurrencyExchangeRateGroupByPayload<T extends CurrencyExchangeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyExchangeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyExchangeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyExchangeRateGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyExchangeRateGroupByOutputType[P]>
        }
      >
    >


  export type CurrencyExchangeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    isActive?: boolean
    branchId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }, ExtArgs["result"]["currencyExchangeRate"]>

  export type CurrencyExchangeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    isActive?: boolean
    branchId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }, ExtArgs["result"]["currencyExchangeRate"]>

  export type CurrencyExchangeRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    isActive?: boolean
    branchId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }, ExtArgs["result"]["currencyExchangeRate"]>

  export type CurrencyExchangeRateSelectScalar = {
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    isActive?: boolean
    branchId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyExchangeRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromCurrency" | "toCurrency" | "rate" | "isActive" | "branchId" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["currencyExchangeRate"]>
  export type CurrencyExchangeRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }
  export type CurrencyExchangeRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }
  export type CurrencyExchangeRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | CurrencyExchangeRate$branchArgs<ExtArgs>
    user?: boolean | CurrencyExchangeRate$userArgs<ExtArgs>
  }

  export type $CurrencyExchangeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrencyExchangeRate"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromCurrency: string
      toCurrency: string
      rate: number
      isActive: boolean
      branchId: number | null
      createdBy: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currencyExchangeRate"]>
    composites: {}
  }

  type CurrencyExchangeRateGetPayload<S extends boolean | null | undefined | CurrencyExchangeRateDefaultArgs> = $Result.GetResult<Prisma.$CurrencyExchangeRatePayload, S>

  type CurrencyExchangeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyExchangeRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyExchangeRateCountAggregateInputType | true
    }

  export interface CurrencyExchangeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrencyExchangeRate'], meta: { name: 'CurrencyExchangeRate' } }
    /**
     * Find zero or one CurrencyExchangeRate that matches the filter.
     * @param {CurrencyExchangeRateFindUniqueArgs} args - Arguments to find a CurrencyExchangeRate
     * @example
     * // Get one CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyExchangeRateFindUniqueArgs>(args: SelectSubset<T, CurrencyExchangeRateFindUniqueArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CurrencyExchangeRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyExchangeRateFindUniqueOrThrowArgs} args - Arguments to find a CurrencyExchangeRate
     * @example
     * // Get one CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyExchangeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyExchangeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrencyExchangeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateFindFirstArgs} args - Arguments to find a CurrencyExchangeRate
     * @example
     * // Get one CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyExchangeRateFindFirstArgs>(args?: SelectSubset<T, CurrencyExchangeRateFindFirstArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrencyExchangeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateFindFirstOrThrowArgs} args - Arguments to find a CurrencyExchangeRate
     * @example
     * // Get one CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyExchangeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyExchangeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CurrencyExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrencyExchangeRates
     * const currencyExchangeRates = await prisma.currencyExchangeRate.findMany()
     * 
     * // Get first 10 CurrencyExchangeRates
     * const currencyExchangeRates = await prisma.currencyExchangeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyExchangeRateWithIdOnly = await prisma.currencyExchangeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyExchangeRateFindManyArgs>(args?: SelectSubset<T, CurrencyExchangeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CurrencyExchangeRate.
     * @param {CurrencyExchangeRateCreateArgs} args - Arguments to create a CurrencyExchangeRate.
     * @example
     * // Create one CurrencyExchangeRate
     * const CurrencyExchangeRate = await prisma.currencyExchangeRate.create({
     *   data: {
     *     // ... data to create a CurrencyExchangeRate
     *   }
     * })
     * 
     */
    create<T extends CurrencyExchangeRateCreateArgs>(args: SelectSubset<T, CurrencyExchangeRateCreateArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CurrencyExchangeRates.
     * @param {CurrencyExchangeRateCreateManyArgs} args - Arguments to create many CurrencyExchangeRates.
     * @example
     * // Create many CurrencyExchangeRates
     * const currencyExchangeRate = await prisma.currencyExchangeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyExchangeRateCreateManyArgs>(args?: SelectSubset<T, CurrencyExchangeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurrencyExchangeRates and returns the data saved in the database.
     * @param {CurrencyExchangeRateCreateManyAndReturnArgs} args - Arguments to create many CurrencyExchangeRates.
     * @example
     * // Create many CurrencyExchangeRates
     * const currencyExchangeRate = await prisma.currencyExchangeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurrencyExchangeRates and only return the `id`
     * const currencyExchangeRateWithIdOnly = await prisma.currencyExchangeRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyExchangeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyExchangeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CurrencyExchangeRate.
     * @param {CurrencyExchangeRateDeleteArgs} args - Arguments to delete one CurrencyExchangeRate.
     * @example
     * // Delete one CurrencyExchangeRate
     * const CurrencyExchangeRate = await prisma.currencyExchangeRate.delete({
     *   where: {
     *     // ... filter to delete one CurrencyExchangeRate
     *   }
     * })
     * 
     */
    delete<T extends CurrencyExchangeRateDeleteArgs>(args: SelectSubset<T, CurrencyExchangeRateDeleteArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CurrencyExchangeRate.
     * @param {CurrencyExchangeRateUpdateArgs} args - Arguments to update one CurrencyExchangeRate.
     * @example
     * // Update one CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyExchangeRateUpdateArgs>(args: SelectSubset<T, CurrencyExchangeRateUpdateArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CurrencyExchangeRates.
     * @param {CurrencyExchangeRateDeleteManyArgs} args - Arguments to filter CurrencyExchangeRates to delete.
     * @example
     * // Delete a few CurrencyExchangeRates
     * const { count } = await prisma.currencyExchangeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyExchangeRateDeleteManyArgs>(args?: SelectSubset<T, CurrencyExchangeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrencyExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrencyExchangeRates
     * const currencyExchangeRate = await prisma.currencyExchangeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyExchangeRateUpdateManyArgs>(args: SelectSubset<T, CurrencyExchangeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrencyExchangeRates and returns the data updated in the database.
     * @param {CurrencyExchangeRateUpdateManyAndReturnArgs} args - Arguments to update many CurrencyExchangeRates.
     * @example
     * // Update many CurrencyExchangeRates
     * const currencyExchangeRate = await prisma.currencyExchangeRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurrencyExchangeRates and only return the `id`
     * const currencyExchangeRateWithIdOnly = await prisma.currencyExchangeRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyExchangeRateUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyExchangeRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CurrencyExchangeRate.
     * @param {CurrencyExchangeRateUpsertArgs} args - Arguments to update or create a CurrencyExchangeRate.
     * @example
     * // Update or create a CurrencyExchangeRate
     * const currencyExchangeRate = await prisma.currencyExchangeRate.upsert({
     *   create: {
     *     // ... data to create a CurrencyExchangeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrencyExchangeRate we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyExchangeRateUpsertArgs>(args: SelectSubset<T, CurrencyExchangeRateUpsertArgs<ExtArgs>>): Prisma__CurrencyExchangeRateClient<$Result.GetResult<Prisma.$CurrencyExchangeRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CurrencyExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateCountArgs} args - Arguments to filter CurrencyExchangeRates to count.
     * @example
     * // Count the number of CurrencyExchangeRates
     * const count = await prisma.currencyExchangeRate.count({
     *   where: {
     *     // ... the filter for the CurrencyExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends CurrencyExchangeRateCountArgs>(
      args?: Subset<T, CurrencyExchangeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyExchangeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrencyExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyExchangeRateAggregateArgs>(args: Subset<T, CurrencyExchangeRateAggregateArgs>): Prisma.PrismaPromise<GetCurrencyExchangeRateAggregateType<T>>

    /**
     * Group by CurrencyExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyExchangeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyExchangeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyExchangeRateGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyExchangeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyExchangeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyExchangeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrencyExchangeRate model
   */
  readonly fields: CurrencyExchangeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrencyExchangeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyExchangeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends CurrencyExchangeRate$branchArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyExchangeRate$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends CurrencyExchangeRate$userArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyExchangeRate$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrencyExchangeRate model
   */
  interface CurrencyExchangeRateFieldRefs {
    readonly id: FieldRef<"CurrencyExchangeRate", 'Int'>
    readonly fromCurrency: FieldRef<"CurrencyExchangeRate", 'String'>
    readonly toCurrency: FieldRef<"CurrencyExchangeRate", 'String'>
    readonly rate: FieldRef<"CurrencyExchangeRate", 'Float'>
    readonly isActive: FieldRef<"CurrencyExchangeRate", 'Boolean'>
    readonly branchId: FieldRef<"CurrencyExchangeRate", 'Int'>
    readonly createdBy: FieldRef<"CurrencyExchangeRate", 'Int'>
    readonly createdAt: FieldRef<"CurrencyExchangeRate", 'DateTime'>
    readonly updatedAt: FieldRef<"CurrencyExchangeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CurrencyExchangeRate findUnique
   */
  export type CurrencyExchangeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyExchangeRate to fetch.
     */
    where: CurrencyExchangeRateWhereUniqueInput
  }

  /**
   * CurrencyExchangeRate findUniqueOrThrow
   */
  export type CurrencyExchangeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyExchangeRate to fetch.
     */
    where: CurrencyExchangeRateWhereUniqueInput
  }

  /**
   * CurrencyExchangeRate findFirst
   */
  export type CurrencyExchangeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyExchangeRate to fetch.
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyExchangeRates to fetch.
     */
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyExchangeRates.
     */
    cursor?: CurrencyExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyExchangeRates.
     */
    distinct?: CurrencyExchangeRateScalarFieldEnum | CurrencyExchangeRateScalarFieldEnum[]
  }

  /**
   * CurrencyExchangeRate findFirstOrThrow
   */
  export type CurrencyExchangeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyExchangeRate to fetch.
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyExchangeRates to fetch.
     */
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyExchangeRates.
     */
    cursor?: CurrencyExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyExchangeRates.
     */
    distinct?: CurrencyExchangeRateScalarFieldEnum | CurrencyExchangeRateScalarFieldEnum[]
  }

  /**
   * CurrencyExchangeRate findMany
   */
  export type CurrencyExchangeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyExchangeRates to fetch.
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyExchangeRates to fetch.
     */
    orderBy?: CurrencyExchangeRateOrderByWithRelationInput | CurrencyExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrencyExchangeRates.
     */
    cursor?: CurrencyExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyExchangeRates.
     */
    skip?: number
    distinct?: CurrencyExchangeRateScalarFieldEnum | CurrencyExchangeRateScalarFieldEnum[]
  }

  /**
   * CurrencyExchangeRate create
   */
  export type CurrencyExchangeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrencyExchangeRate.
     */
    data: XOR<CurrencyExchangeRateCreateInput, CurrencyExchangeRateUncheckedCreateInput>
  }

  /**
   * CurrencyExchangeRate createMany
   */
  export type CurrencyExchangeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrencyExchangeRates.
     */
    data: CurrencyExchangeRateCreateManyInput | CurrencyExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurrencyExchangeRate createManyAndReturn
   */
  export type CurrencyExchangeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to create many CurrencyExchangeRates.
     */
    data: CurrencyExchangeRateCreateManyInput | CurrencyExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrencyExchangeRate update
   */
  export type CurrencyExchangeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrencyExchangeRate.
     */
    data: XOR<CurrencyExchangeRateUpdateInput, CurrencyExchangeRateUncheckedUpdateInput>
    /**
     * Choose, which CurrencyExchangeRate to update.
     */
    where: CurrencyExchangeRateWhereUniqueInput
  }

  /**
   * CurrencyExchangeRate updateMany
   */
  export type CurrencyExchangeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrencyExchangeRates.
     */
    data: XOR<CurrencyExchangeRateUpdateManyMutationInput, CurrencyExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which CurrencyExchangeRates to update
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * Limit how many CurrencyExchangeRates to update.
     */
    limit?: number
  }

  /**
   * CurrencyExchangeRate updateManyAndReturn
   */
  export type CurrencyExchangeRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to update CurrencyExchangeRates.
     */
    data: XOR<CurrencyExchangeRateUpdateManyMutationInput, CurrencyExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which CurrencyExchangeRates to update
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * Limit how many CurrencyExchangeRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrencyExchangeRate upsert
   */
  export type CurrencyExchangeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrencyExchangeRate to update in case it exists.
     */
    where: CurrencyExchangeRateWhereUniqueInput
    /**
     * In case the CurrencyExchangeRate found by the `where` argument doesn't exist, create a new CurrencyExchangeRate with this data.
     */
    create: XOR<CurrencyExchangeRateCreateInput, CurrencyExchangeRateUncheckedCreateInput>
    /**
     * In case the CurrencyExchangeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyExchangeRateUpdateInput, CurrencyExchangeRateUncheckedUpdateInput>
  }

  /**
   * CurrencyExchangeRate delete
   */
  export type CurrencyExchangeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
    /**
     * Filter which CurrencyExchangeRate to delete.
     */
    where: CurrencyExchangeRateWhereUniqueInput
  }

  /**
   * CurrencyExchangeRate deleteMany
   */
  export type CurrencyExchangeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyExchangeRates to delete
     */
    where?: CurrencyExchangeRateWhereInput
    /**
     * Limit how many CurrencyExchangeRates to delete.
     */
    limit?: number
  }

  /**
   * CurrencyExchangeRate.branch
   */
  export type CurrencyExchangeRate$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * CurrencyExchangeRate.user
   */
  export type CurrencyExchangeRate$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CurrencyExchangeRate without action
   */
  export type CurrencyExchangeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyExchangeRate
     */
    select?: CurrencyExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyExchangeRate
     */
    omit?: CurrencyExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyExchangeRateInclude<ExtArgs> | null
  }


  /**
   * Model Bonus
   */

  export type AggregateBonus = {
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  export type BonusAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    createdById: number | null
    branchId: number | null
    transactionId: number | null
  }

  export type BonusSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    createdById: number | null
    branchId: number | null
    transactionId: number | null
  }

  export type BonusMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    reason: string | null
    description: string | null
    bonusDate: Date | null
    createdById: number | null
    branchId: number | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BonusMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    reason: string | null
    description: string | null
    bonusDate: Date | null
    createdById: number | null
    branchId: number | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BonusCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    reason: number
    description: number
    bonusProducts: number
    bonusDate: number
    createdById: number
    branchId: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BonusAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    createdById?: true
    branchId?: true
    transactionId?: true
  }

  export type BonusSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    createdById?: true
    branchId?: true
    transactionId?: true
  }

  export type BonusMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    description?: true
    bonusDate?: true
    createdById?: true
    branchId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BonusMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    description?: true
    bonusDate?: true
    createdById?: true
    branchId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BonusCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    description?: true
    bonusProducts?: true
    bonusDate?: true
    createdById?: true
    branchId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonus to aggregate.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bonuses
    **/
    _count?: true | BonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonusMaxAggregateInputType
  }

  export type GetBonusAggregateType<T extends BonusAggregateArgs> = {
        [P in keyof T & keyof AggregateBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonus[P]>
      : GetScalarType<T[P], AggregateBonus[P]>
  }




  export type BonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithAggregationInput | BonusOrderByWithAggregationInput[]
    by: BonusScalarFieldEnum[] | BonusScalarFieldEnum
    having?: BonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonusCountAggregateInputType | true
    _avg?: BonusAvgAggregateInputType
    _sum?: BonusSumAggregateInputType
    _min?: BonusMinAggregateInputType
    _max?: BonusMaxAggregateInputType
  }

  export type BonusGroupByOutputType = {
    id: number
    userId: number
    amount: number
    reason: string
    description: string | null
    bonusProducts: JsonValue | null
    bonusDate: Date
    createdById: number
    branchId: number | null
    transactionId: number | null
    createdAt: Date
    updatedAt: Date
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  type GetBonusGroupByPayload<T extends BonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonusGroupByOutputType[P]>
            : GetScalarType<T[P], BonusGroupByOutputType[P]>
        }
      >
    >


  export type BonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    bonusProducts?: boolean
    bonusDate?: boolean
    createdById?: boolean
    branchId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    bonusProducts?: boolean
    bonusDate?: boolean
    createdById?: boolean
    branchId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    bonusProducts?: boolean
    bonusDate?: boolean
    createdById?: boolean
    branchId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    bonusProducts?: boolean
    bonusDate?: boolean
    createdById?: boolean
    branchId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "reason" | "description" | "bonusProducts" | "bonusDate" | "createdById" | "branchId" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["bonus"]>
  export type BonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }
  export type BonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }
  export type BonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Bonus$branchArgs<ExtArgs>
    transaction?: boolean | Bonus$transactionArgs<ExtArgs>
  }

  export type $BonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bonus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      reason: string
      description: string | null
      bonusProducts: Prisma.JsonValue | null
      bonusDate: Date
      createdById: number
      branchId: number | null
      transactionId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bonus"]>
    composites: {}
  }

  type BonusGetPayload<S extends boolean | null | undefined | BonusDefaultArgs> = $Result.GetResult<Prisma.$BonusPayload, S>

  type BonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BonusCountAggregateInputType | true
    }

  export interface BonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bonus'], meta: { name: 'Bonus' } }
    /**
     * Find zero or one Bonus that matches the filter.
     * @param {BonusFindUniqueArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonusFindUniqueArgs>(args: SelectSubset<T, BonusFindUniqueArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BonusFindUniqueOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonusFindUniqueOrThrowArgs>(args: SelectSubset<T, BonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonusFindFirstArgs>(args?: SelectSubset<T, BonusFindFirstArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonusFindFirstOrThrowArgs>(args?: SelectSubset<T, BonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bonuses
     * const bonuses = await prisma.bonus.findMany()
     * 
     * // Get first 10 Bonuses
     * const bonuses = await prisma.bonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonusWithIdOnly = await prisma.bonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonusFindManyArgs>(args?: SelectSubset<T, BonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bonus.
     * @param {BonusCreateArgs} args - Arguments to create a Bonus.
     * @example
     * // Create one Bonus
     * const Bonus = await prisma.bonus.create({
     *   data: {
     *     // ... data to create a Bonus
     *   }
     * })
     * 
     */
    create<T extends BonusCreateArgs>(args: SelectSubset<T, BonusCreateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bonuses.
     * @param {BonusCreateManyArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonusCreateManyArgs>(args?: SelectSubset<T, BonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bonuses and returns the data saved in the database.
     * @param {BonusCreateManyAndReturnArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bonuses and only return the `id`
     * const bonusWithIdOnly = await prisma.bonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BonusCreateManyAndReturnArgs>(args?: SelectSubset<T, BonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bonus.
     * @param {BonusDeleteArgs} args - Arguments to delete one Bonus.
     * @example
     * // Delete one Bonus
     * const Bonus = await prisma.bonus.delete({
     *   where: {
     *     // ... filter to delete one Bonus
     *   }
     * })
     * 
     */
    delete<T extends BonusDeleteArgs>(args: SelectSubset<T, BonusDeleteArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bonus.
     * @param {BonusUpdateArgs} args - Arguments to update one Bonus.
     * @example
     * // Update one Bonus
     * const bonus = await prisma.bonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonusUpdateArgs>(args: SelectSubset<T, BonusUpdateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bonuses.
     * @param {BonusDeleteManyArgs} args - Arguments to filter Bonuses to delete.
     * @example
     * // Delete a few Bonuses
     * const { count } = await prisma.bonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonusDeleteManyArgs>(args?: SelectSubset<T, BonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bonuses
     * const bonus = await prisma.bonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonusUpdateManyArgs>(args: SelectSubset<T, BonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonuses and returns the data updated in the database.
     * @param {BonusUpdateManyAndReturnArgs} args - Arguments to update many Bonuses.
     * @example
     * // Update many Bonuses
     * const bonus = await prisma.bonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bonuses and only return the `id`
     * const bonusWithIdOnly = await prisma.bonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BonusUpdateManyAndReturnArgs>(args: SelectSubset<T, BonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bonus.
     * @param {BonusUpsertArgs} args - Arguments to update or create a Bonus.
     * @example
     * // Update or create a Bonus
     * const bonus = await prisma.bonus.upsert({
     *   create: {
     *     // ... data to create a Bonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bonus we want to update
     *   }
     * })
     */
    upsert<T extends BonusUpsertArgs>(args: SelectSubset<T, BonusUpsertArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusCountArgs} args - Arguments to filter Bonuses to count.
     * @example
     * // Count the number of Bonuses
     * const count = await prisma.bonus.count({
     *   where: {
     *     // ... the filter for the Bonuses we want to count
     *   }
     * })
    **/
    count<T extends BonusCountArgs>(
      args?: Subset<T, BonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonusAggregateArgs>(args: Subset<T, BonusAggregateArgs>): Prisma.PrismaPromise<GetBonusAggregateType<T>>

    /**
     * Group by Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonusGroupByArgs['orderBy'] }
        : { orderBy?: BonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bonus model
   */
  readonly fields: BonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends Bonus$branchArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends Bonus$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bonus model
   */
  interface BonusFieldRefs {
    readonly id: FieldRef<"Bonus", 'Int'>
    readonly userId: FieldRef<"Bonus", 'Int'>
    readonly amount: FieldRef<"Bonus", 'Float'>
    readonly reason: FieldRef<"Bonus", 'String'>
    readonly description: FieldRef<"Bonus", 'String'>
    readonly bonusProducts: FieldRef<"Bonus", 'Json'>
    readonly bonusDate: FieldRef<"Bonus", 'DateTime'>
    readonly createdById: FieldRef<"Bonus", 'Int'>
    readonly branchId: FieldRef<"Bonus", 'Int'>
    readonly transactionId: FieldRef<"Bonus", 'Int'>
    readonly createdAt: FieldRef<"Bonus", 'DateTime'>
    readonly updatedAt: FieldRef<"Bonus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bonus findUnique
   */
  export type BonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findUniqueOrThrow
   */
  export type BonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findFirst
   */
  export type BonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findFirstOrThrow
   */
  export type BonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findMany
   */
  export type BonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonuses to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus create
   */
  export type BonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to create a Bonus.
     */
    data: XOR<BonusCreateInput, BonusUncheckedCreateInput>
  }

  /**
   * Bonus createMany
   */
  export type BonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus createManyAndReturn
   */
  export type BonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bonus update
   */
  export type BonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to update a Bonus.
     */
    data: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
    /**
     * Choose, which Bonus to update.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus updateMany
   */
  export type BonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bonuses.
     */
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyInput>
    /**
     * Filter which Bonuses to update
     */
    where?: BonusWhereInput
    /**
     * Limit how many Bonuses to update.
     */
    limit?: number
  }

  /**
   * Bonus updateManyAndReturn
   */
  export type BonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * The data used to update Bonuses.
     */
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyInput>
    /**
     * Filter which Bonuses to update
     */
    where?: BonusWhereInput
    /**
     * Limit how many Bonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bonus upsert
   */
  export type BonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The filter to search for the Bonus to update in case it exists.
     */
    where: BonusWhereUniqueInput
    /**
     * In case the Bonus found by the `where` argument doesn't exist, create a new Bonus with this data.
     */
    create: XOR<BonusCreateInput, BonusUncheckedCreateInput>
    /**
     * In case the Bonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
  }

  /**
   * Bonus delete
   */
  export type BonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter which Bonus to delete.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus deleteMany
   */
  export type BonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonuses to delete
     */
    where?: BonusWhereInput
    /**
     * Limit how many Bonuses to delete.
     */
    limit?: number
  }

  /**
   * Bonus.branch
   */
  export type Bonus$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Bonus.transaction
   */
  export type Bonus$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Bonus without action
   */
  export type BonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bonus
     */
    omit?: BonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
  }


  /**
   * Model TransactionBonusProduct
   */

  export type AggregateTransactionBonusProduct = {
    _count: TransactionBonusProductCountAggregateOutputType | null
    _avg: TransactionBonusProductAvgAggregateOutputType | null
    _sum: TransactionBonusProductSumAggregateOutputType | null
    _min: TransactionBonusProductMinAggregateOutputType | null
    _max: TransactionBonusProductMaxAggregateOutputType | null
  }

  export type TransactionBonusProductAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
  }

  export type TransactionBonusProductSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
  }

  export type TransactionBonusProductMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionBonusProductMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionBonusProductCountAggregateOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionBonusProductAvgAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
  }

  export type TransactionBonusProductSumAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
  }

  export type TransactionBonusProductMinAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionBonusProductMaxAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionBonusProductCountAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionBonusProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionBonusProduct to aggregate.
     */
    where?: TransactionBonusProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionBonusProducts to fetch.
     */
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionBonusProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionBonusProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionBonusProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionBonusProducts
    **/
    _count?: true | TransactionBonusProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionBonusProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionBonusProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionBonusProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionBonusProductMaxAggregateInputType
  }

  export type GetTransactionBonusProductAggregateType<T extends TransactionBonusProductAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionBonusProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionBonusProduct[P]>
      : GetScalarType<T[P], AggregateTransactionBonusProduct[P]>
  }




  export type TransactionBonusProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionBonusProductWhereInput
    orderBy?: TransactionBonusProductOrderByWithAggregationInput | TransactionBonusProductOrderByWithAggregationInput[]
    by: TransactionBonusProductScalarFieldEnum[] | TransactionBonusProductScalarFieldEnum
    having?: TransactionBonusProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionBonusProductCountAggregateInputType | true
    _avg?: TransactionBonusProductAvgAggregateInputType
    _sum?: TransactionBonusProductSumAggregateInputType
    _min?: TransactionBonusProductMinAggregateInputType
    _max?: TransactionBonusProductMaxAggregateInputType
  }

  export type TransactionBonusProductGroupByOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: TransactionBonusProductCountAggregateOutputType | null
    _avg: TransactionBonusProductAvgAggregateOutputType | null
    _sum: TransactionBonusProductSumAggregateOutputType | null
    _min: TransactionBonusProductMinAggregateOutputType | null
    _max: TransactionBonusProductMaxAggregateOutputType | null
  }

  type GetTransactionBonusProductGroupByPayload<T extends TransactionBonusProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionBonusProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionBonusProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionBonusProductGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionBonusProductGroupByOutputType[P]>
        }
      >
    >


  export type TransactionBonusProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionBonusProduct"]>

  export type TransactionBonusProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionBonusProduct"]>

  export type TransactionBonusProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionBonusProduct"]>

  export type TransactionBonusProductSelectScalar = {
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionBonusProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "productId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionBonusProduct"]>
  export type TransactionBonusProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransactionBonusProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransactionBonusProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TransactionBonusProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionBonusProduct"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      productId: number
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionBonusProduct"]>
    composites: {}
  }

  type TransactionBonusProductGetPayload<S extends boolean | null | undefined | TransactionBonusProductDefaultArgs> = $Result.GetResult<Prisma.$TransactionBonusProductPayload, S>

  type TransactionBonusProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionBonusProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionBonusProductCountAggregateInputType | true
    }

  export interface TransactionBonusProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionBonusProduct'], meta: { name: 'TransactionBonusProduct' } }
    /**
     * Find zero or one TransactionBonusProduct that matches the filter.
     * @param {TransactionBonusProductFindUniqueArgs} args - Arguments to find a TransactionBonusProduct
     * @example
     * // Get one TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionBonusProductFindUniqueArgs>(args: SelectSubset<T, TransactionBonusProductFindUniqueArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionBonusProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionBonusProductFindUniqueOrThrowArgs} args - Arguments to find a TransactionBonusProduct
     * @example
     * // Get one TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionBonusProductFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionBonusProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionBonusProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductFindFirstArgs} args - Arguments to find a TransactionBonusProduct
     * @example
     * // Get one TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionBonusProductFindFirstArgs>(args?: SelectSubset<T, TransactionBonusProductFindFirstArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionBonusProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductFindFirstOrThrowArgs} args - Arguments to find a TransactionBonusProduct
     * @example
     * // Get one TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionBonusProductFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionBonusProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionBonusProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionBonusProducts
     * const transactionBonusProducts = await prisma.transactionBonusProduct.findMany()
     * 
     * // Get first 10 TransactionBonusProducts
     * const transactionBonusProducts = await prisma.transactionBonusProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionBonusProductWithIdOnly = await prisma.transactionBonusProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionBonusProductFindManyArgs>(args?: SelectSubset<T, TransactionBonusProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionBonusProduct.
     * @param {TransactionBonusProductCreateArgs} args - Arguments to create a TransactionBonusProduct.
     * @example
     * // Create one TransactionBonusProduct
     * const TransactionBonusProduct = await prisma.transactionBonusProduct.create({
     *   data: {
     *     // ... data to create a TransactionBonusProduct
     *   }
     * })
     * 
     */
    create<T extends TransactionBonusProductCreateArgs>(args: SelectSubset<T, TransactionBonusProductCreateArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionBonusProducts.
     * @param {TransactionBonusProductCreateManyArgs} args - Arguments to create many TransactionBonusProducts.
     * @example
     * // Create many TransactionBonusProducts
     * const transactionBonusProduct = await prisma.transactionBonusProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionBonusProductCreateManyArgs>(args?: SelectSubset<T, TransactionBonusProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionBonusProducts and returns the data saved in the database.
     * @param {TransactionBonusProductCreateManyAndReturnArgs} args - Arguments to create many TransactionBonusProducts.
     * @example
     * // Create many TransactionBonusProducts
     * const transactionBonusProduct = await prisma.transactionBonusProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionBonusProducts and only return the `id`
     * const transactionBonusProductWithIdOnly = await prisma.transactionBonusProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionBonusProductCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionBonusProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionBonusProduct.
     * @param {TransactionBonusProductDeleteArgs} args - Arguments to delete one TransactionBonusProduct.
     * @example
     * // Delete one TransactionBonusProduct
     * const TransactionBonusProduct = await prisma.transactionBonusProduct.delete({
     *   where: {
     *     // ... filter to delete one TransactionBonusProduct
     *   }
     * })
     * 
     */
    delete<T extends TransactionBonusProductDeleteArgs>(args: SelectSubset<T, TransactionBonusProductDeleteArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionBonusProduct.
     * @param {TransactionBonusProductUpdateArgs} args - Arguments to update one TransactionBonusProduct.
     * @example
     * // Update one TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionBonusProductUpdateArgs>(args: SelectSubset<T, TransactionBonusProductUpdateArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionBonusProducts.
     * @param {TransactionBonusProductDeleteManyArgs} args - Arguments to filter TransactionBonusProducts to delete.
     * @example
     * // Delete a few TransactionBonusProducts
     * const { count } = await prisma.transactionBonusProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionBonusProductDeleteManyArgs>(args?: SelectSubset<T, TransactionBonusProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionBonusProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionBonusProducts
     * const transactionBonusProduct = await prisma.transactionBonusProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionBonusProductUpdateManyArgs>(args: SelectSubset<T, TransactionBonusProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionBonusProducts and returns the data updated in the database.
     * @param {TransactionBonusProductUpdateManyAndReturnArgs} args - Arguments to update many TransactionBonusProducts.
     * @example
     * // Update many TransactionBonusProducts
     * const transactionBonusProduct = await prisma.transactionBonusProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionBonusProducts and only return the `id`
     * const transactionBonusProductWithIdOnly = await prisma.transactionBonusProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionBonusProductUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionBonusProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionBonusProduct.
     * @param {TransactionBonusProductUpsertArgs} args - Arguments to update or create a TransactionBonusProduct.
     * @example
     * // Update or create a TransactionBonusProduct
     * const transactionBonusProduct = await prisma.transactionBonusProduct.upsert({
     *   create: {
     *     // ... data to create a TransactionBonusProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionBonusProduct we want to update
     *   }
     * })
     */
    upsert<T extends TransactionBonusProductUpsertArgs>(args: SelectSubset<T, TransactionBonusProductUpsertArgs<ExtArgs>>): Prisma__TransactionBonusProductClient<$Result.GetResult<Prisma.$TransactionBonusProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionBonusProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductCountArgs} args - Arguments to filter TransactionBonusProducts to count.
     * @example
     * // Count the number of TransactionBonusProducts
     * const count = await prisma.transactionBonusProduct.count({
     *   where: {
     *     // ... the filter for the TransactionBonusProducts we want to count
     *   }
     * })
    **/
    count<T extends TransactionBonusProductCountArgs>(
      args?: Subset<T, TransactionBonusProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionBonusProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionBonusProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionBonusProductAggregateArgs>(args: Subset<T, TransactionBonusProductAggregateArgs>): Prisma.PrismaPromise<GetTransactionBonusProductAggregateType<T>>

    /**
     * Group by TransactionBonusProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionBonusProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionBonusProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionBonusProductGroupByArgs['orderBy'] }
        : { orderBy?: TransactionBonusProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionBonusProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionBonusProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionBonusProduct model
   */
  readonly fields: TransactionBonusProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionBonusProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionBonusProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionBonusProduct model
   */
  interface TransactionBonusProductFieldRefs {
    readonly id: FieldRef<"TransactionBonusProduct", 'Int'>
    readonly transactionId: FieldRef<"TransactionBonusProduct", 'Int'>
    readonly productId: FieldRef<"TransactionBonusProduct", 'Int'>
    readonly quantity: FieldRef<"TransactionBonusProduct", 'Int'>
    readonly createdAt: FieldRef<"TransactionBonusProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionBonusProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionBonusProduct findUnique
   */
  export type TransactionBonusProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionBonusProduct to fetch.
     */
    where: TransactionBonusProductWhereUniqueInput
  }

  /**
   * TransactionBonusProduct findUniqueOrThrow
   */
  export type TransactionBonusProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionBonusProduct to fetch.
     */
    where: TransactionBonusProductWhereUniqueInput
  }

  /**
   * TransactionBonusProduct findFirst
   */
  export type TransactionBonusProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionBonusProduct to fetch.
     */
    where?: TransactionBonusProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionBonusProducts to fetch.
     */
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionBonusProducts.
     */
    cursor?: TransactionBonusProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionBonusProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionBonusProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionBonusProducts.
     */
    distinct?: TransactionBonusProductScalarFieldEnum | TransactionBonusProductScalarFieldEnum[]
  }

  /**
   * TransactionBonusProduct findFirstOrThrow
   */
  export type TransactionBonusProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionBonusProduct to fetch.
     */
    where?: TransactionBonusProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionBonusProducts to fetch.
     */
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionBonusProducts.
     */
    cursor?: TransactionBonusProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionBonusProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionBonusProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionBonusProducts.
     */
    distinct?: TransactionBonusProductScalarFieldEnum | TransactionBonusProductScalarFieldEnum[]
  }

  /**
   * TransactionBonusProduct findMany
   */
  export type TransactionBonusProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionBonusProducts to fetch.
     */
    where?: TransactionBonusProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionBonusProducts to fetch.
     */
    orderBy?: TransactionBonusProductOrderByWithRelationInput | TransactionBonusProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionBonusProducts.
     */
    cursor?: TransactionBonusProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionBonusProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionBonusProducts.
     */
    skip?: number
    distinct?: TransactionBonusProductScalarFieldEnum | TransactionBonusProductScalarFieldEnum[]
  }

  /**
   * TransactionBonusProduct create
   */
  export type TransactionBonusProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionBonusProduct.
     */
    data: XOR<TransactionBonusProductCreateInput, TransactionBonusProductUncheckedCreateInput>
  }

  /**
   * TransactionBonusProduct createMany
   */
  export type TransactionBonusProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionBonusProducts.
     */
    data: TransactionBonusProductCreateManyInput | TransactionBonusProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionBonusProduct createManyAndReturn
   */
  export type TransactionBonusProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionBonusProducts.
     */
    data: TransactionBonusProductCreateManyInput | TransactionBonusProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionBonusProduct update
   */
  export type TransactionBonusProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionBonusProduct.
     */
    data: XOR<TransactionBonusProductUpdateInput, TransactionBonusProductUncheckedUpdateInput>
    /**
     * Choose, which TransactionBonusProduct to update.
     */
    where: TransactionBonusProductWhereUniqueInput
  }

  /**
   * TransactionBonusProduct updateMany
   */
  export type TransactionBonusProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionBonusProducts.
     */
    data: XOR<TransactionBonusProductUpdateManyMutationInput, TransactionBonusProductUncheckedUpdateManyInput>
    /**
     * Filter which TransactionBonusProducts to update
     */
    where?: TransactionBonusProductWhereInput
    /**
     * Limit how many TransactionBonusProducts to update.
     */
    limit?: number
  }

  /**
   * TransactionBonusProduct updateManyAndReturn
   */
  export type TransactionBonusProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * The data used to update TransactionBonusProducts.
     */
    data: XOR<TransactionBonusProductUpdateManyMutationInput, TransactionBonusProductUncheckedUpdateManyInput>
    /**
     * Filter which TransactionBonusProducts to update
     */
    where?: TransactionBonusProductWhereInput
    /**
     * Limit how many TransactionBonusProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionBonusProduct upsert
   */
  export type TransactionBonusProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionBonusProduct to update in case it exists.
     */
    where: TransactionBonusProductWhereUniqueInput
    /**
     * In case the TransactionBonusProduct found by the `where` argument doesn't exist, create a new TransactionBonusProduct with this data.
     */
    create: XOR<TransactionBonusProductCreateInput, TransactionBonusProductUncheckedCreateInput>
    /**
     * In case the TransactionBonusProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionBonusProductUpdateInput, TransactionBonusProductUncheckedUpdateInput>
  }

  /**
   * TransactionBonusProduct delete
   */
  export type TransactionBonusProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
    /**
     * Filter which TransactionBonusProduct to delete.
     */
    where: TransactionBonusProductWhereUniqueInput
  }

  /**
   * TransactionBonusProduct deleteMany
   */
  export type TransactionBonusProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionBonusProducts to delete
     */
    where?: TransactionBonusProductWhereInput
    /**
     * Limit how many TransactionBonusProducts to delete.
     */
    limit?: number
  }

  /**
   * TransactionBonusProduct without action
   */
  export type TransactionBonusProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionBonusProduct
     */
    select?: TransactionBonusProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionBonusProduct
     */
    omit?: TransactionBonusProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionBonusProductInclude<ExtArgs> | null
  }


  /**
   * Model WorkSchedule
   */

  export type AggregateWorkSchedule = {
    _count: WorkScheduleCountAggregateOutputType | null
    _avg: WorkScheduleAvgAggregateOutputType | null
    _sum: WorkScheduleSumAggregateOutputType | null
    _min: WorkScheduleMinAggregateOutputType | null
    _max: WorkScheduleMaxAggregateOutputType | null
  }

  export type WorkScheduleAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkScheduleSumAggregateOutputType = {
    id: number | null
  }

  export type WorkScheduleMinAggregateOutputType = {
    id: number | null
    workStartTime: string | null
    workEndTime: string | null
    isDefault: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkScheduleMaxAggregateOutputType = {
    id: number | null
    workStartTime: string | null
    workEndTime: string | null
    isDefault: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkScheduleCountAggregateOutputType = {
    id: number
    workStartTime: number
    workEndTime: number
    isDefault: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkScheduleAvgAggregateInputType = {
    id?: true
  }

  export type WorkScheduleSumAggregateInputType = {
    id?: true
  }

  export type WorkScheduleMinAggregateInputType = {
    id?: true
    workStartTime?: true
    workEndTime?: true
    isDefault?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkScheduleMaxAggregateInputType = {
    id?: true
    workStartTime?: true
    workEndTime?: true
    isDefault?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkScheduleCountAggregateInputType = {
    id?: true
    workStartTime?: true
    workEndTime?: true
    isDefault?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSchedule to aggregate.
     */
    where?: WorkScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSchedules to fetch.
     */
    orderBy?: WorkScheduleOrderByWithRelationInput | WorkScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkSchedules
    **/
    _count?: true | WorkScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkScheduleMaxAggregateInputType
  }

  export type GetWorkScheduleAggregateType<T extends WorkScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkSchedule[P]>
      : GetScalarType<T[P], AggregateWorkSchedule[P]>
  }




  export type WorkScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkScheduleWhereInput
    orderBy?: WorkScheduleOrderByWithAggregationInput | WorkScheduleOrderByWithAggregationInput[]
    by: WorkScheduleScalarFieldEnum[] | WorkScheduleScalarFieldEnum
    having?: WorkScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkScheduleCountAggregateInputType | true
    _avg?: WorkScheduleAvgAggregateInputType
    _sum?: WorkScheduleSumAggregateInputType
    _min?: WorkScheduleMinAggregateInputType
    _max?: WorkScheduleMaxAggregateInputType
  }

  export type WorkScheduleGroupByOutputType = {
    id: number
    workStartTime: string
    workEndTime: string
    isDefault: boolean
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkScheduleCountAggregateOutputType | null
    _avg: WorkScheduleAvgAggregateOutputType | null
    _sum: WorkScheduleSumAggregateOutputType | null
    _min: WorkScheduleMinAggregateOutputType | null
    _max: WorkScheduleMaxAggregateOutputType | null
  }

  type GetWorkScheduleGroupByPayload<T extends WorkScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkScheduleGroupByOutputType[P]>
        }
      >
    >


  export type WorkScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    isDefault?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workSchedule"]>

  export type WorkScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    isDefault?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workSchedule"]>

  export type WorkScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    isDefault?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workSchedule"]>

  export type WorkScheduleSelectScalar = {
    id?: boolean
    workStartTime?: boolean
    workEndTime?: boolean
    isDefault?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workStartTime" | "workEndTime" | "isDefault" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["workSchedule"]>

  export type $WorkSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkSchedule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workStartTime: string
      workEndTime: string
      isDefault: boolean
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workSchedule"]>
    composites: {}
  }

  type WorkScheduleGetPayload<S extends boolean | null | undefined | WorkScheduleDefaultArgs> = $Result.GetResult<Prisma.$WorkSchedulePayload, S>

  type WorkScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkScheduleCountAggregateInputType | true
    }

  export interface WorkScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkSchedule'], meta: { name: 'WorkSchedule' } }
    /**
     * Find zero or one WorkSchedule that matches the filter.
     * @param {WorkScheduleFindUniqueArgs} args - Arguments to find a WorkSchedule
     * @example
     * // Get one WorkSchedule
     * const workSchedule = await prisma.workSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkScheduleFindUniqueArgs>(args: SelectSubset<T, WorkScheduleFindUniqueArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkScheduleFindUniqueOrThrowArgs} args - Arguments to find a WorkSchedule
     * @example
     * // Get one WorkSchedule
     * const workSchedule = await prisma.workSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleFindFirstArgs} args - Arguments to find a WorkSchedule
     * @example
     * // Get one WorkSchedule
     * const workSchedule = await prisma.workSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkScheduleFindFirstArgs>(args?: SelectSubset<T, WorkScheduleFindFirstArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleFindFirstOrThrowArgs} args - Arguments to find a WorkSchedule
     * @example
     * // Get one WorkSchedule
     * const workSchedule = await prisma.workSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkSchedules
     * const workSchedules = await prisma.workSchedule.findMany()
     * 
     * // Get first 10 WorkSchedules
     * const workSchedules = await prisma.workSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workScheduleWithIdOnly = await prisma.workSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkScheduleFindManyArgs>(args?: SelectSubset<T, WorkScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkSchedule.
     * @param {WorkScheduleCreateArgs} args - Arguments to create a WorkSchedule.
     * @example
     * // Create one WorkSchedule
     * const WorkSchedule = await prisma.workSchedule.create({
     *   data: {
     *     // ... data to create a WorkSchedule
     *   }
     * })
     * 
     */
    create<T extends WorkScheduleCreateArgs>(args: SelectSubset<T, WorkScheduleCreateArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkSchedules.
     * @param {WorkScheduleCreateManyArgs} args - Arguments to create many WorkSchedules.
     * @example
     * // Create many WorkSchedules
     * const workSchedule = await prisma.workSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkScheduleCreateManyArgs>(args?: SelectSubset<T, WorkScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkSchedules and returns the data saved in the database.
     * @param {WorkScheduleCreateManyAndReturnArgs} args - Arguments to create many WorkSchedules.
     * @example
     * // Create many WorkSchedules
     * const workSchedule = await prisma.workSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkSchedules and only return the `id`
     * const workScheduleWithIdOnly = await prisma.workSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkSchedule.
     * @param {WorkScheduleDeleteArgs} args - Arguments to delete one WorkSchedule.
     * @example
     * // Delete one WorkSchedule
     * const WorkSchedule = await prisma.workSchedule.delete({
     *   where: {
     *     // ... filter to delete one WorkSchedule
     *   }
     * })
     * 
     */
    delete<T extends WorkScheduleDeleteArgs>(args: SelectSubset<T, WorkScheduleDeleteArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkSchedule.
     * @param {WorkScheduleUpdateArgs} args - Arguments to update one WorkSchedule.
     * @example
     * // Update one WorkSchedule
     * const workSchedule = await prisma.workSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkScheduleUpdateArgs>(args: SelectSubset<T, WorkScheduleUpdateArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkSchedules.
     * @param {WorkScheduleDeleteManyArgs} args - Arguments to filter WorkSchedules to delete.
     * @example
     * // Delete a few WorkSchedules
     * const { count } = await prisma.workSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkScheduleDeleteManyArgs>(args?: SelectSubset<T, WorkScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkSchedules
     * const workSchedule = await prisma.workSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkScheduleUpdateManyArgs>(args: SelectSubset<T, WorkScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSchedules and returns the data updated in the database.
     * @param {WorkScheduleUpdateManyAndReturnArgs} args - Arguments to update many WorkSchedules.
     * @example
     * // Update many WorkSchedules
     * const workSchedule = await prisma.workSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkSchedules and only return the `id`
     * const workScheduleWithIdOnly = await prisma.workSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkSchedule.
     * @param {WorkScheduleUpsertArgs} args - Arguments to update or create a WorkSchedule.
     * @example
     * // Update or create a WorkSchedule
     * const workSchedule = await prisma.workSchedule.upsert({
     *   create: {
     *     // ... data to create a WorkSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkSchedule we want to update
     *   }
     * })
     */
    upsert<T extends WorkScheduleUpsertArgs>(args: SelectSubset<T, WorkScheduleUpsertArgs<ExtArgs>>): Prisma__WorkScheduleClient<$Result.GetResult<Prisma.$WorkSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleCountArgs} args - Arguments to filter WorkSchedules to count.
     * @example
     * // Count the number of WorkSchedules
     * const count = await prisma.workSchedule.count({
     *   where: {
     *     // ... the filter for the WorkSchedules we want to count
     *   }
     * })
    **/
    count<T extends WorkScheduleCountArgs>(
      args?: Subset<T, WorkScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkScheduleAggregateArgs>(args: Subset<T, WorkScheduleAggregateArgs>): Prisma.PrismaPromise<GetWorkScheduleAggregateType<T>>

    /**
     * Group by WorkSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkScheduleGroupByArgs['orderBy'] }
        : { orderBy?: WorkScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkSchedule model
   */
  readonly fields: WorkScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkSchedule model
   */
  interface WorkScheduleFieldRefs {
    readonly id: FieldRef<"WorkSchedule", 'Int'>
    readonly workStartTime: FieldRef<"WorkSchedule", 'String'>
    readonly workEndTime: FieldRef<"WorkSchedule", 'String'>
    readonly isDefault: FieldRef<"WorkSchedule", 'Boolean'>
    readonly description: FieldRef<"WorkSchedule", 'String'>
    readonly createdAt: FieldRef<"WorkSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkSchedule findUnique
   */
  export type WorkScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter, which WorkSchedule to fetch.
     */
    where: WorkScheduleWhereUniqueInput
  }

  /**
   * WorkSchedule findUniqueOrThrow
   */
  export type WorkScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter, which WorkSchedule to fetch.
     */
    where: WorkScheduleWhereUniqueInput
  }

  /**
   * WorkSchedule findFirst
   */
  export type WorkScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter, which WorkSchedule to fetch.
     */
    where?: WorkScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSchedules to fetch.
     */
    orderBy?: WorkScheduleOrderByWithRelationInput | WorkScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSchedules.
     */
    cursor?: WorkScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSchedules.
     */
    distinct?: WorkScheduleScalarFieldEnum | WorkScheduleScalarFieldEnum[]
  }

  /**
   * WorkSchedule findFirstOrThrow
   */
  export type WorkScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter, which WorkSchedule to fetch.
     */
    where?: WorkScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSchedules to fetch.
     */
    orderBy?: WorkScheduleOrderByWithRelationInput | WorkScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSchedules.
     */
    cursor?: WorkScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSchedules.
     */
    distinct?: WorkScheduleScalarFieldEnum | WorkScheduleScalarFieldEnum[]
  }

  /**
   * WorkSchedule findMany
   */
  export type WorkScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter, which WorkSchedules to fetch.
     */
    where?: WorkScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSchedules to fetch.
     */
    orderBy?: WorkScheduleOrderByWithRelationInput | WorkScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkSchedules.
     */
    cursor?: WorkScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSchedules.
     */
    skip?: number
    distinct?: WorkScheduleScalarFieldEnum | WorkScheduleScalarFieldEnum[]
  }

  /**
   * WorkSchedule create
   */
  export type WorkScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * The data needed to create a WorkSchedule.
     */
    data: XOR<WorkScheduleCreateInput, WorkScheduleUncheckedCreateInput>
  }

  /**
   * WorkSchedule createMany
   */
  export type WorkScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkSchedules.
     */
    data: WorkScheduleCreateManyInput | WorkScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkSchedule createManyAndReturn
   */
  export type WorkScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many WorkSchedules.
     */
    data: WorkScheduleCreateManyInput | WorkScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkSchedule update
   */
  export type WorkScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * The data needed to update a WorkSchedule.
     */
    data: XOR<WorkScheduleUpdateInput, WorkScheduleUncheckedUpdateInput>
    /**
     * Choose, which WorkSchedule to update.
     */
    where: WorkScheduleWhereUniqueInput
  }

  /**
   * WorkSchedule updateMany
   */
  export type WorkScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkSchedules.
     */
    data: XOR<WorkScheduleUpdateManyMutationInput, WorkScheduleUncheckedUpdateManyInput>
    /**
     * Filter which WorkSchedules to update
     */
    where?: WorkScheduleWhereInput
    /**
     * Limit how many WorkSchedules to update.
     */
    limit?: number
  }

  /**
   * WorkSchedule updateManyAndReturn
   */
  export type WorkScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * The data used to update WorkSchedules.
     */
    data: XOR<WorkScheduleUpdateManyMutationInput, WorkScheduleUncheckedUpdateManyInput>
    /**
     * Filter which WorkSchedules to update
     */
    where?: WorkScheduleWhereInput
    /**
     * Limit how many WorkSchedules to update.
     */
    limit?: number
  }

  /**
   * WorkSchedule upsert
   */
  export type WorkScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * The filter to search for the WorkSchedule to update in case it exists.
     */
    where: WorkScheduleWhereUniqueInput
    /**
     * In case the WorkSchedule found by the `where` argument doesn't exist, create a new WorkSchedule with this data.
     */
    create: XOR<WorkScheduleCreateInput, WorkScheduleUncheckedCreateInput>
    /**
     * In case the WorkSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkScheduleUpdateInput, WorkScheduleUncheckedUpdateInput>
  }

  /**
   * WorkSchedule delete
   */
  export type WorkScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
    /**
     * Filter which WorkSchedule to delete.
     */
    where: WorkScheduleWhereUniqueInput
  }

  /**
   * WorkSchedule deleteMany
   */
  export type WorkScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSchedules to delete
     */
    where?: WorkScheduleWhereInput
    /**
     * Limit how many WorkSchedules to delete.
     */
    limit?: number
  }

  /**
   * WorkSchedule without action
   */
  export type WorkScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSchedule
     */
    select?: WorkScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSchedule
     */
    omit?: WorkScheduleOmit<ExtArgs> | null
  }


  /**
   * Model barcodeCounter
   */

  export type AggregateBarcodeCounter = {
    _count: BarcodeCounterCountAggregateOutputType | null
    _avg: BarcodeCounterAvgAggregateOutputType | null
    _sum: BarcodeCounterSumAggregateOutputType | null
    _min: BarcodeCounterMinAggregateOutputType | null
    _max: BarcodeCounterMaxAggregateOutputType | null
  }

  export type BarcodeCounterAvgAggregateOutputType = {
    id: number | null
    counter: number | null
  }

  export type BarcodeCounterSumAggregateOutputType = {
    id: number | null
    counter: bigint | null
  }

  export type BarcodeCounterMinAggregateOutputType = {
    id: number | null
    counter: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarcodeCounterMaxAggregateOutputType = {
    id: number | null
    counter: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarcodeCounterCountAggregateOutputType = {
    id: number
    counter: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BarcodeCounterAvgAggregateInputType = {
    id?: true
    counter?: true
  }

  export type BarcodeCounterSumAggregateInputType = {
    id?: true
    counter?: true
  }

  export type BarcodeCounterMinAggregateInputType = {
    id?: true
    counter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarcodeCounterMaxAggregateInputType = {
    id?: true
    counter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarcodeCounterCountAggregateInputType = {
    id?: true
    counter?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BarcodeCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barcodeCounter to aggregate.
     */
    where?: barcodeCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodeCounters to fetch.
     */
    orderBy?: barcodeCounterOrderByWithRelationInput | barcodeCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: barcodeCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodeCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodeCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned barcodeCounters
    **/
    _count?: true | BarcodeCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarcodeCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarcodeCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarcodeCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarcodeCounterMaxAggregateInputType
  }

  export type GetBarcodeCounterAggregateType<T extends BarcodeCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateBarcodeCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarcodeCounter[P]>
      : GetScalarType<T[P], AggregateBarcodeCounter[P]>
  }




  export type barcodeCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: barcodeCounterWhereInput
    orderBy?: barcodeCounterOrderByWithAggregationInput | barcodeCounterOrderByWithAggregationInput[]
    by: BarcodeCounterScalarFieldEnum[] | BarcodeCounterScalarFieldEnum
    having?: barcodeCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarcodeCounterCountAggregateInputType | true
    _avg?: BarcodeCounterAvgAggregateInputType
    _sum?: BarcodeCounterSumAggregateInputType
    _min?: BarcodeCounterMinAggregateInputType
    _max?: BarcodeCounterMaxAggregateInputType
  }

  export type BarcodeCounterGroupByOutputType = {
    id: number
    counter: bigint
    createdAt: Date
    updatedAt: Date
    _count: BarcodeCounterCountAggregateOutputType | null
    _avg: BarcodeCounterAvgAggregateOutputType | null
    _sum: BarcodeCounterSumAggregateOutputType | null
    _min: BarcodeCounterMinAggregateOutputType | null
    _max: BarcodeCounterMaxAggregateOutputType | null
  }

  type GetBarcodeCounterGroupByPayload<T extends barcodeCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarcodeCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarcodeCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarcodeCounterGroupByOutputType[P]>
            : GetScalarType<T[P], BarcodeCounterGroupByOutputType[P]>
        }
      >
    >


  export type barcodeCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["barcodeCounter"]>

  export type barcodeCounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["barcodeCounter"]>

  export type barcodeCounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["barcodeCounter"]>

  export type barcodeCounterSelectScalar = {
    id?: boolean
    counter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type barcodeCounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "counter" | "createdAt" | "updatedAt", ExtArgs["result"]["barcodeCounter"]>

  export type $barcodeCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "barcodeCounter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      counter: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["barcodeCounter"]>
    composites: {}
  }

  type barcodeCounterGetPayload<S extends boolean | null | undefined | barcodeCounterDefaultArgs> = $Result.GetResult<Prisma.$barcodeCounterPayload, S>

  type barcodeCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<barcodeCounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarcodeCounterCountAggregateInputType | true
    }

  export interface barcodeCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['barcodeCounter'], meta: { name: 'barcodeCounter' } }
    /**
     * Find zero or one BarcodeCounter that matches the filter.
     * @param {barcodeCounterFindUniqueArgs} args - Arguments to find a BarcodeCounter
     * @example
     * // Get one BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends barcodeCounterFindUniqueArgs>(args: SelectSubset<T, barcodeCounterFindUniqueArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarcodeCounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {barcodeCounterFindUniqueOrThrowArgs} args - Arguments to find a BarcodeCounter
     * @example
     * // Get one BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends barcodeCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, barcodeCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarcodeCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterFindFirstArgs} args - Arguments to find a BarcodeCounter
     * @example
     * // Get one BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends barcodeCounterFindFirstArgs>(args?: SelectSubset<T, barcodeCounterFindFirstArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarcodeCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterFindFirstOrThrowArgs} args - Arguments to find a BarcodeCounter
     * @example
     * // Get one BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends barcodeCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, barcodeCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarcodeCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarcodeCounters
     * const barcodeCounters = await prisma.barcodeCounter.findMany()
     * 
     * // Get first 10 BarcodeCounters
     * const barcodeCounters = await prisma.barcodeCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barcodeCounterWithIdOnly = await prisma.barcodeCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends barcodeCounterFindManyArgs>(args?: SelectSubset<T, barcodeCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarcodeCounter.
     * @param {barcodeCounterCreateArgs} args - Arguments to create a BarcodeCounter.
     * @example
     * // Create one BarcodeCounter
     * const BarcodeCounter = await prisma.barcodeCounter.create({
     *   data: {
     *     // ... data to create a BarcodeCounter
     *   }
     * })
     * 
     */
    create<T extends barcodeCounterCreateArgs>(args: SelectSubset<T, barcodeCounterCreateArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarcodeCounters.
     * @param {barcodeCounterCreateManyArgs} args - Arguments to create many BarcodeCounters.
     * @example
     * // Create many BarcodeCounters
     * const barcodeCounter = await prisma.barcodeCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends barcodeCounterCreateManyArgs>(args?: SelectSubset<T, barcodeCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarcodeCounters and returns the data saved in the database.
     * @param {barcodeCounterCreateManyAndReturnArgs} args - Arguments to create many BarcodeCounters.
     * @example
     * // Create many BarcodeCounters
     * const barcodeCounter = await prisma.barcodeCounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarcodeCounters and only return the `id`
     * const barcodeCounterWithIdOnly = await prisma.barcodeCounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends barcodeCounterCreateManyAndReturnArgs>(args?: SelectSubset<T, barcodeCounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarcodeCounter.
     * @param {barcodeCounterDeleteArgs} args - Arguments to delete one BarcodeCounter.
     * @example
     * // Delete one BarcodeCounter
     * const BarcodeCounter = await prisma.barcodeCounter.delete({
     *   where: {
     *     // ... filter to delete one BarcodeCounter
     *   }
     * })
     * 
     */
    delete<T extends barcodeCounterDeleteArgs>(args: SelectSubset<T, barcodeCounterDeleteArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarcodeCounter.
     * @param {barcodeCounterUpdateArgs} args - Arguments to update one BarcodeCounter.
     * @example
     * // Update one BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends barcodeCounterUpdateArgs>(args: SelectSubset<T, barcodeCounterUpdateArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarcodeCounters.
     * @param {barcodeCounterDeleteManyArgs} args - Arguments to filter BarcodeCounters to delete.
     * @example
     * // Delete a few BarcodeCounters
     * const { count } = await prisma.barcodeCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends barcodeCounterDeleteManyArgs>(args?: SelectSubset<T, barcodeCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarcodeCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarcodeCounters
     * const barcodeCounter = await prisma.barcodeCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends barcodeCounterUpdateManyArgs>(args: SelectSubset<T, barcodeCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarcodeCounters and returns the data updated in the database.
     * @param {barcodeCounterUpdateManyAndReturnArgs} args - Arguments to update many BarcodeCounters.
     * @example
     * // Update many BarcodeCounters
     * const barcodeCounter = await prisma.barcodeCounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarcodeCounters and only return the `id`
     * const barcodeCounterWithIdOnly = await prisma.barcodeCounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends barcodeCounterUpdateManyAndReturnArgs>(args: SelectSubset<T, barcodeCounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarcodeCounter.
     * @param {barcodeCounterUpsertArgs} args - Arguments to update or create a BarcodeCounter.
     * @example
     * // Update or create a BarcodeCounter
     * const barcodeCounter = await prisma.barcodeCounter.upsert({
     *   create: {
     *     // ... data to create a BarcodeCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarcodeCounter we want to update
     *   }
     * })
     */
    upsert<T extends barcodeCounterUpsertArgs>(args: SelectSubset<T, barcodeCounterUpsertArgs<ExtArgs>>): Prisma__barcodeCounterClient<$Result.GetResult<Prisma.$barcodeCounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarcodeCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterCountArgs} args - Arguments to filter BarcodeCounters to count.
     * @example
     * // Count the number of BarcodeCounters
     * const count = await prisma.barcodeCounter.count({
     *   where: {
     *     // ... the filter for the BarcodeCounters we want to count
     *   }
     * })
    **/
    count<T extends barcodeCounterCountArgs>(
      args?: Subset<T, barcodeCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarcodeCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarcodeCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarcodeCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarcodeCounterAggregateArgs>(args: Subset<T, BarcodeCounterAggregateArgs>): Prisma.PrismaPromise<GetBarcodeCounterAggregateType<T>>

    /**
     * Group by BarcodeCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends barcodeCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: barcodeCounterGroupByArgs['orderBy'] }
        : { orderBy?: barcodeCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, barcodeCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarcodeCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the barcodeCounter model
   */
  readonly fields: barcodeCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for barcodeCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__barcodeCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the barcodeCounter model
   */
  interface barcodeCounterFieldRefs {
    readonly id: FieldRef<"barcodeCounter", 'Int'>
    readonly counter: FieldRef<"barcodeCounter", 'BigInt'>
    readonly createdAt: FieldRef<"barcodeCounter", 'DateTime'>
    readonly updatedAt: FieldRef<"barcodeCounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * barcodeCounter findUnique
   */
  export type barcodeCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter, which barcodeCounter to fetch.
     */
    where: barcodeCounterWhereUniqueInput
  }

  /**
   * barcodeCounter findUniqueOrThrow
   */
  export type barcodeCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter, which barcodeCounter to fetch.
     */
    where: barcodeCounterWhereUniqueInput
  }

  /**
   * barcodeCounter findFirst
   */
  export type barcodeCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter, which barcodeCounter to fetch.
     */
    where?: barcodeCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodeCounters to fetch.
     */
    orderBy?: barcodeCounterOrderByWithRelationInput | barcodeCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barcodeCounters.
     */
    cursor?: barcodeCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodeCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodeCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barcodeCounters.
     */
    distinct?: BarcodeCounterScalarFieldEnum | BarcodeCounterScalarFieldEnum[]
  }

  /**
   * barcodeCounter findFirstOrThrow
   */
  export type barcodeCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter, which barcodeCounter to fetch.
     */
    where?: barcodeCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodeCounters to fetch.
     */
    orderBy?: barcodeCounterOrderByWithRelationInput | barcodeCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barcodeCounters.
     */
    cursor?: barcodeCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodeCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodeCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barcodeCounters.
     */
    distinct?: BarcodeCounterScalarFieldEnum | BarcodeCounterScalarFieldEnum[]
  }

  /**
   * barcodeCounter findMany
   */
  export type barcodeCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter, which barcodeCounters to fetch.
     */
    where?: barcodeCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodeCounters to fetch.
     */
    orderBy?: barcodeCounterOrderByWithRelationInput | barcodeCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing barcodeCounters.
     */
    cursor?: barcodeCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodeCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodeCounters.
     */
    skip?: number
    distinct?: BarcodeCounterScalarFieldEnum | BarcodeCounterScalarFieldEnum[]
  }

  /**
   * barcodeCounter create
   */
  export type barcodeCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * The data needed to create a barcodeCounter.
     */
    data: XOR<barcodeCounterCreateInput, barcodeCounterUncheckedCreateInput>
  }

  /**
   * barcodeCounter createMany
   */
  export type barcodeCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many barcodeCounters.
     */
    data: barcodeCounterCreateManyInput | barcodeCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * barcodeCounter createManyAndReturn
   */
  export type barcodeCounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * The data used to create many barcodeCounters.
     */
    data: barcodeCounterCreateManyInput | barcodeCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * barcodeCounter update
   */
  export type barcodeCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * The data needed to update a barcodeCounter.
     */
    data: XOR<barcodeCounterUpdateInput, barcodeCounterUncheckedUpdateInput>
    /**
     * Choose, which barcodeCounter to update.
     */
    where: barcodeCounterWhereUniqueInput
  }

  /**
   * barcodeCounter updateMany
   */
  export type barcodeCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update barcodeCounters.
     */
    data: XOR<barcodeCounterUpdateManyMutationInput, barcodeCounterUncheckedUpdateManyInput>
    /**
     * Filter which barcodeCounters to update
     */
    where?: barcodeCounterWhereInput
    /**
     * Limit how many barcodeCounters to update.
     */
    limit?: number
  }

  /**
   * barcodeCounter updateManyAndReturn
   */
  export type barcodeCounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * The data used to update barcodeCounters.
     */
    data: XOR<barcodeCounterUpdateManyMutationInput, barcodeCounterUncheckedUpdateManyInput>
    /**
     * Filter which barcodeCounters to update
     */
    where?: barcodeCounterWhereInput
    /**
     * Limit how many barcodeCounters to update.
     */
    limit?: number
  }

  /**
   * barcodeCounter upsert
   */
  export type barcodeCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * The filter to search for the barcodeCounter to update in case it exists.
     */
    where: barcodeCounterWhereUniqueInput
    /**
     * In case the barcodeCounter found by the `where` argument doesn't exist, create a new barcodeCounter with this data.
     */
    create: XOR<barcodeCounterCreateInput, barcodeCounterUncheckedCreateInput>
    /**
     * In case the barcodeCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<barcodeCounterUpdateInput, barcodeCounterUncheckedUpdateInput>
  }

  /**
   * barcodeCounter delete
   */
  export type barcodeCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
    /**
     * Filter which barcodeCounter to delete.
     */
    where: barcodeCounterWhereUniqueInput
  }

  /**
   * barcodeCounter deleteMany
   */
  export type barcodeCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barcodeCounters to delete
     */
    where?: barcodeCounterWhereInput
    /**
     * Limit how many barcodeCounters to delete.
     */
    limit?: number
  }

  /**
   * barcodeCounter without action
   */
  export type barcodeCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcodeCounter
     */
    select?: barcodeCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barcodeCounter
     */
    omit?: barcodeCounterOmit<ExtArgs> | null
  }


  /**
   * Model FaceTemplate
   */

  export type AggregateFaceTemplate = {
    _count: FaceTemplateCountAggregateOutputType | null
    _avg: FaceTemplateAvgAggregateOutputType | null
    _sum: FaceTemplateSumAggregateOutputType | null
    _min: FaceTemplateMinAggregateOutputType | null
    _max: FaceTemplateMaxAggregateOutputType | null
  }

  export type FaceTemplateAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FaceTemplateSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FaceTemplateMinAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: string | null
    template: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaceTemplateMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: string | null
    template: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaceTemplateCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    template: number
    vector: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FaceTemplateAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FaceTemplateSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FaceTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    template?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaceTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    template?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaceTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    template?: true
    vector?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FaceTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FaceTemplate to aggregate.
     */
    where?: FaceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaceTemplates to fetch.
     */
    orderBy?: FaceTemplateOrderByWithRelationInput | FaceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FaceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FaceTemplates
    **/
    _count?: true | FaceTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaceTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaceTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaceTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaceTemplateMaxAggregateInputType
  }

  export type GetFaceTemplateAggregateType<T extends FaceTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFaceTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaceTemplate[P]>
      : GetScalarType<T[P], AggregateFaceTemplate[P]>
  }




  export type FaceTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaceTemplateWhereInput
    orderBy?: FaceTemplateOrderByWithAggregationInput | FaceTemplateOrderByWithAggregationInput[]
    by: FaceTemplateScalarFieldEnum[] | FaceTemplateScalarFieldEnum
    having?: FaceTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaceTemplateCountAggregateInputType | true
    _avg?: FaceTemplateAvgAggregateInputType
    _sum?: FaceTemplateSumAggregateInputType
    _min?: FaceTemplateMinAggregateInputType
    _max?: FaceTemplateMaxAggregateInputType
  }

  export type FaceTemplateGroupByOutputType = {
    id: number
    userId: number
    deviceId: string | null
    template: string | null
    vector: JsonValue | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: FaceTemplateCountAggregateOutputType | null
    _avg: FaceTemplateAvgAggregateOutputType | null
    _sum: FaceTemplateSumAggregateOutputType | null
    _min: FaceTemplateMinAggregateOutputType | null
    _max: FaceTemplateMaxAggregateOutputType | null
  }

  type GetFaceTemplateGroupByPayload<T extends FaceTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaceTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaceTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaceTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FaceTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FaceTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    template?: boolean
    vector?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faceTemplate"]>

  export type FaceTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    template?: boolean
    vector?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faceTemplate"]>

  export type FaceTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    template?: boolean
    vector?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faceTemplate"]>

  export type FaceTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    template?: boolean
    vector?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FaceTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceId" | "template" | "vector" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["faceTemplate"]>
  export type FaceTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FaceTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FaceTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FaceTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FaceTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      deviceId: string | null
      template: string | null
      vector: Prisma.JsonValue | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faceTemplate"]>
    composites: {}
  }

  type FaceTemplateGetPayload<S extends boolean | null | undefined | FaceTemplateDefaultArgs> = $Result.GetResult<Prisma.$FaceTemplatePayload, S>

  type FaceTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FaceTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaceTemplateCountAggregateInputType | true
    }

  export interface FaceTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FaceTemplate'], meta: { name: 'FaceTemplate' } }
    /**
     * Find zero or one FaceTemplate that matches the filter.
     * @param {FaceTemplateFindUniqueArgs} args - Arguments to find a FaceTemplate
     * @example
     * // Get one FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FaceTemplateFindUniqueArgs>(args: SelectSubset<T, FaceTemplateFindUniqueArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FaceTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FaceTemplateFindUniqueOrThrowArgs} args - Arguments to find a FaceTemplate
     * @example
     * // Get one FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FaceTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, FaceTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FaceTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateFindFirstArgs} args - Arguments to find a FaceTemplate
     * @example
     * // Get one FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FaceTemplateFindFirstArgs>(args?: SelectSubset<T, FaceTemplateFindFirstArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FaceTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateFindFirstOrThrowArgs} args - Arguments to find a FaceTemplate
     * @example
     * // Get one FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FaceTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, FaceTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FaceTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FaceTemplates
     * const faceTemplates = await prisma.faceTemplate.findMany()
     * 
     * // Get first 10 FaceTemplates
     * const faceTemplates = await prisma.faceTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faceTemplateWithIdOnly = await prisma.faceTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FaceTemplateFindManyArgs>(args?: SelectSubset<T, FaceTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FaceTemplate.
     * @param {FaceTemplateCreateArgs} args - Arguments to create a FaceTemplate.
     * @example
     * // Create one FaceTemplate
     * const FaceTemplate = await prisma.faceTemplate.create({
     *   data: {
     *     // ... data to create a FaceTemplate
     *   }
     * })
     * 
     */
    create<T extends FaceTemplateCreateArgs>(args: SelectSubset<T, FaceTemplateCreateArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FaceTemplates.
     * @param {FaceTemplateCreateManyArgs} args - Arguments to create many FaceTemplates.
     * @example
     * // Create many FaceTemplates
     * const faceTemplate = await prisma.faceTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FaceTemplateCreateManyArgs>(args?: SelectSubset<T, FaceTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FaceTemplates and returns the data saved in the database.
     * @param {FaceTemplateCreateManyAndReturnArgs} args - Arguments to create many FaceTemplates.
     * @example
     * // Create many FaceTemplates
     * const faceTemplate = await prisma.faceTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FaceTemplates and only return the `id`
     * const faceTemplateWithIdOnly = await prisma.faceTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FaceTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, FaceTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FaceTemplate.
     * @param {FaceTemplateDeleteArgs} args - Arguments to delete one FaceTemplate.
     * @example
     * // Delete one FaceTemplate
     * const FaceTemplate = await prisma.faceTemplate.delete({
     *   where: {
     *     // ... filter to delete one FaceTemplate
     *   }
     * })
     * 
     */
    delete<T extends FaceTemplateDeleteArgs>(args: SelectSubset<T, FaceTemplateDeleteArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FaceTemplate.
     * @param {FaceTemplateUpdateArgs} args - Arguments to update one FaceTemplate.
     * @example
     * // Update one FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FaceTemplateUpdateArgs>(args: SelectSubset<T, FaceTemplateUpdateArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FaceTemplates.
     * @param {FaceTemplateDeleteManyArgs} args - Arguments to filter FaceTemplates to delete.
     * @example
     * // Delete a few FaceTemplates
     * const { count } = await prisma.faceTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FaceTemplateDeleteManyArgs>(args?: SelectSubset<T, FaceTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FaceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FaceTemplates
     * const faceTemplate = await prisma.faceTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FaceTemplateUpdateManyArgs>(args: SelectSubset<T, FaceTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FaceTemplates and returns the data updated in the database.
     * @param {FaceTemplateUpdateManyAndReturnArgs} args - Arguments to update many FaceTemplates.
     * @example
     * // Update many FaceTemplates
     * const faceTemplate = await prisma.faceTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FaceTemplates and only return the `id`
     * const faceTemplateWithIdOnly = await prisma.faceTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FaceTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, FaceTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FaceTemplate.
     * @param {FaceTemplateUpsertArgs} args - Arguments to update or create a FaceTemplate.
     * @example
     * // Update or create a FaceTemplate
     * const faceTemplate = await prisma.faceTemplate.upsert({
     *   create: {
     *     // ... data to create a FaceTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FaceTemplate we want to update
     *   }
     * })
     */
    upsert<T extends FaceTemplateUpsertArgs>(args: SelectSubset<T, FaceTemplateUpsertArgs<ExtArgs>>): Prisma__FaceTemplateClient<$Result.GetResult<Prisma.$FaceTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FaceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateCountArgs} args - Arguments to filter FaceTemplates to count.
     * @example
     * // Count the number of FaceTemplates
     * const count = await prisma.faceTemplate.count({
     *   where: {
     *     // ... the filter for the FaceTemplates we want to count
     *   }
     * })
    **/
    count<T extends FaceTemplateCountArgs>(
      args?: Subset<T, FaceTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaceTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FaceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaceTemplateAggregateArgs>(args: Subset<T, FaceTemplateAggregateArgs>): Prisma.PrismaPromise<GetFaceTemplateAggregateType<T>>

    /**
     * Group by FaceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaceTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaceTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FaceTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaceTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaceTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FaceTemplate model
   */
  readonly fields: FaceTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FaceTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FaceTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FaceTemplate model
   */
  interface FaceTemplateFieldRefs {
    readonly id: FieldRef<"FaceTemplate", 'Int'>
    readonly userId: FieldRef<"FaceTemplate", 'Int'>
    readonly deviceId: FieldRef<"FaceTemplate", 'String'>
    readonly template: FieldRef<"FaceTemplate", 'String'>
    readonly vector: FieldRef<"FaceTemplate", 'Json'>
    readonly imageUrl: FieldRef<"FaceTemplate", 'String'>
    readonly createdAt: FieldRef<"FaceTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"FaceTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FaceTemplate findUnique
   */
  export type FaceTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FaceTemplate to fetch.
     */
    where: FaceTemplateWhereUniqueInput
  }

  /**
   * FaceTemplate findUniqueOrThrow
   */
  export type FaceTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FaceTemplate to fetch.
     */
    where: FaceTemplateWhereUniqueInput
  }

  /**
   * FaceTemplate findFirst
   */
  export type FaceTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FaceTemplate to fetch.
     */
    where?: FaceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaceTemplates to fetch.
     */
    orderBy?: FaceTemplateOrderByWithRelationInput | FaceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FaceTemplates.
     */
    cursor?: FaceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FaceTemplates.
     */
    distinct?: FaceTemplateScalarFieldEnum | FaceTemplateScalarFieldEnum[]
  }

  /**
   * FaceTemplate findFirstOrThrow
   */
  export type FaceTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FaceTemplate to fetch.
     */
    where?: FaceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaceTemplates to fetch.
     */
    orderBy?: FaceTemplateOrderByWithRelationInput | FaceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FaceTemplates.
     */
    cursor?: FaceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FaceTemplates.
     */
    distinct?: FaceTemplateScalarFieldEnum | FaceTemplateScalarFieldEnum[]
  }

  /**
   * FaceTemplate findMany
   */
  export type FaceTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FaceTemplates to fetch.
     */
    where?: FaceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaceTemplates to fetch.
     */
    orderBy?: FaceTemplateOrderByWithRelationInput | FaceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FaceTemplates.
     */
    cursor?: FaceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaceTemplates.
     */
    skip?: number
    distinct?: FaceTemplateScalarFieldEnum | FaceTemplateScalarFieldEnum[]
  }

  /**
   * FaceTemplate create
   */
  export type FaceTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a FaceTemplate.
     */
    data: XOR<FaceTemplateCreateInput, FaceTemplateUncheckedCreateInput>
  }

  /**
   * FaceTemplate createMany
   */
  export type FaceTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FaceTemplates.
     */
    data: FaceTemplateCreateManyInput | FaceTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FaceTemplate createManyAndReturn
   */
  export type FaceTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many FaceTemplates.
     */
    data: FaceTemplateCreateManyInput | FaceTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FaceTemplate update
   */
  export type FaceTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a FaceTemplate.
     */
    data: XOR<FaceTemplateUpdateInput, FaceTemplateUncheckedUpdateInput>
    /**
     * Choose, which FaceTemplate to update.
     */
    where: FaceTemplateWhereUniqueInput
  }

  /**
   * FaceTemplate updateMany
   */
  export type FaceTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FaceTemplates.
     */
    data: XOR<FaceTemplateUpdateManyMutationInput, FaceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FaceTemplates to update
     */
    where?: FaceTemplateWhereInput
    /**
     * Limit how many FaceTemplates to update.
     */
    limit?: number
  }

  /**
   * FaceTemplate updateManyAndReturn
   */
  export type FaceTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * The data used to update FaceTemplates.
     */
    data: XOR<FaceTemplateUpdateManyMutationInput, FaceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FaceTemplates to update
     */
    where?: FaceTemplateWhereInput
    /**
     * Limit how many FaceTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FaceTemplate upsert
   */
  export type FaceTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the FaceTemplate to update in case it exists.
     */
    where: FaceTemplateWhereUniqueInput
    /**
     * In case the FaceTemplate found by the `where` argument doesn't exist, create a new FaceTemplate with this data.
     */
    create: XOR<FaceTemplateCreateInput, FaceTemplateUncheckedCreateInput>
    /**
     * In case the FaceTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FaceTemplateUpdateInput, FaceTemplateUncheckedUpdateInput>
  }

  /**
   * FaceTemplate delete
   */
  export type FaceTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
    /**
     * Filter which FaceTemplate to delete.
     */
    where: FaceTemplateWhereUniqueInput
  }

  /**
   * FaceTemplate deleteMany
   */
  export type FaceTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FaceTemplates to delete
     */
    where?: FaceTemplateWhereInput
    /**
     * Limit how many FaceTemplates to delete.
     */
    limit?: number
  }

  /**
   * FaceTemplate without action
   */
  export type FaceTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceTemplate
     */
    select?: FaceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FaceTemplate
     */
    omit?: FaceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceTemplateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AttendanceDayScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    date: 'date',
    checkInAt: 'checkInAt',
    checkOutAt: 'checkOutAt',
    totalMinutes: 'totalMinutes',
    status: 'status',
    deviceId: 'deviceId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceDayScalarFieldEnum = (typeof AttendanceDayScalarFieldEnum)[keyof typeof AttendanceDayScalarFieldEnum]


  export const AttendanceEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    dayId: 'dayId',
    eventType: 'eventType',
    occurredAt: 'occurredAt',
    deviceId: 'deviceId',
    similarity: 'similarity',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type AttendanceEventScalarFieldEnum = (typeof AttendanceEventScalarFieldEnum)[keyof typeof AttendanceEventScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    type: 'type',
    cashBalance: 'cashBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phoneNumber: 'phoneNumber',
    status: 'status'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    username: 'username',
    password: 'password',
    role: 'role',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    workStartTime: 'workStartTime',
    workEndTime: 'workEndTime',
    workShift: 'workShift'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserBranchAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBranchAccessScalarFieldEnum = (typeof UserBranchAccessScalarFieldEnum)[keyof typeof UserBranchAccessScalarFieldEnum]


  export const UserLocationScalarFieldEnum: {
    userId: 'userId',
    latitude: 'latitude',
    longitude: 'longitude',
    address: 'address',
    isOnline: 'isOnline',
    lastSeen: 'lastSeen',
    updatedAt: 'updatedAt'
  };

  export type UserLocationScalarFieldEnum = (typeof UserLocationScalarFieldEnum)[keyof typeof UserLocationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    model: 'model',
    price: 'price',
    quantity: 'quantity',
    defectiveQuantity: 'defectiveQuantity',
    returnedQuantity: 'returnedQuantity',
    exchangedQuantity: 'exchangedQuantity',
    initialQuantity: 'initialQuantity',
    status: 'status',
    branchId: 'branchId',
    categoryId: 'categoryId',
    marketPrice: 'marketPrice',
    bonusPercentage: 'bonusPercentage',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sizeType: 'sizeType',
    sizeLabel: 'sizeLabel',
    sizeNumber: 'sizeNumber',
    areaSqm: 'areaSqm'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const DefectiveLogScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    description: 'description',
    userId: 'userId',
    branchId: 'branchId',
    cashAmount: 'cashAmount',
    actionType: 'actionType',
    createdAt: 'createdAt',
    exchangeWithProductId: 'exchangeWithProductId',
    replacementQuantity: 'replacementQuantity',
    replacementUnitPrice: 'replacementUnitPrice',
    replacementTransactionId: 'replacementTransactionId'
  };

  export type DefectiveLogScalarFieldEnum = (typeof DefectiveLogScalarFieldEnum)[keyof typeof DefectiveLogScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    passportSeries: 'passportSeries',
    jshshir: 'jshshir',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    userId: 'userId',
    soldByUserId: 'soldByUserId',
    fromBranchId: 'fromBranchId',
    toBranchId: 'toBranchId',
    type: 'type',
    transactionType: 'transactionType',
    status: 'status',
    discount: 'discount',
    total: 'total',
    finalTotal: 'finalTotal',
    paymentType: 'paymentType',
    upfrontPaymentType: 'upfrontPaymentType',
    termUnit: 'termUnit',
    deliveryMethod: 'deliveryMethod',
    deliveryType: 'deliveryType',
    deliveryAddress: 'deliveryAddress',
    amountPaid: 'amountPaid',
    downPayment: 'downPayment',
    remainingBalance: 'remainingBalance',
    receiptId: 'receiptId',
    description: 'description',
    updatedById: 'updatedById',
    creditRepaymentAmount: 'creditRepaymentAmount',
    lastRepaymentDate: 'lastRepaymentDate',
    extraProfit: 'extraProfit',
    days: 'days',
    months: 'months',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionItemScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    sellingPrice: 'sellingPrice',
    originalPrice: 'originalPrice',
    total: 'total',
    creditMonth: 'creditMonth',
    creditPercent: 'creditPercent',
    monthlyPayment: 'monthlyPayment',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionItemScalarFieldEnum = (typeof TransactionItemScalarFieldEnum)[keyof typeof TransactionItemScalarFieldEnum]


  export const ProductTransferScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    fromBranchId: 'fromBranchId',
    toBranchId: 'toBranchId',
    quantity: 'quantity',
    status: 'status',
    initiatedById: 'initiatedById',
    approvedById: 'approvedById',
    transferDate: 'transferDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductTransferScalarFieldEnum = (typeof ProductTransferScalarFieldEnum)[keyof typeof ProductTransferScalarFieldEnum]


  export const PaymentScheduleScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    month: 'month',
    payment: 'payment',
    remainingBalance: 'remainingBalance',
    isPaid: 'isPaid',
    paidAmount: 'paidAmount',
    paidAt: 'paidAt',
    paidChannel: 'paidChannel',
    paidByUserId: 'paidByUserId',
    createdAt: 'createdAt',
    creditRepaymentAmount: 'creditRepaymentAmount',
    repaymentDate: 'repaymentDate',
    rating: 'rating',
    dueDate: 'dueDate',
    isDailyInstallment: 'isDailyInstallment',
    daysCount: 'daysCount',
    installmentType: 'installmentType',
    totalDays: 'totalDays',
    remainingDays: 'remainingDays',
    totalMonths: 'totalMonths',
    remainingMonths: 'remainingMonths'
  };

  export type PaymentScheduleScalarFieldEnum = (typeof PaymentScheduleScalarFieldEnum)[keyof typeof PaymentScheduleScalarFieldEnum]


  export const PaymentRepaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    scheduleId: 'scheduleId',
    amount: 'amount',
    channel: 'channel',
    paidAt: 'paidAt',
    paidByUserId: 'paidByUserId',
    createdAt: 'createdAt'
  };

  export type PaymentRepaymentScalarFieldEnum = (typeof PaymentRepaymentScalarFieldEnum)[keyof typeof PaymentRepaymentScalarFieldEnum]


  export const DailyRepaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    amount: 'amount',
    channel: 'channel',
    paidAt: 'paidAt',
    paidByUserId: 'paidByUserId',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type DailyRepaymentScalarFieldEnum = (typeof DailyRepaymentScalarFieldEnum)[keyof typeof DailyRepaymentScalarFieldEnum]


  export const CreditRepaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    scheduleId: 'scheduleId',
    amount: 'amount',
    channel: 'channel',
    month: 'month',
    monthNumber: 'monthNumber',
    paidAt: 'paidAt',
    paidByUserId: 'paidByUserId',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type CreditRepaymentScalarFieldEnum = (typeof CreditRepaymentScalarFieldEnum)[keyof typeof CreditRepaymentScalarFieldEnum]


  export const CashierReportScalarFieldEnum: {
    id: 'id',
    cashierId: 'cashierId',
    branchId: 'branchId',
    reportDate: 'reportDate',
    cashTotal: 'cashTotal',
    cardTotal: 'cardTotal',
    creditTotal: 'creditTotal',
    installmentTotal: 'installmentTotal',
    upfrontTotal: 'upfrontTotal',
    upfrontCash: 'upfrontCash',
    upfrontCard: 'upfrontCard',
    soldQuantity: 'soldQuantity',
    soldAmount: 'soldAmount',
    repaymentTotal: 'repaymentTotal',
    defectivePlus: 'defectivePlus',
    defectiveMinus: 'defectiveMinus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashierReportScalarFieldEnum = (typeof CashierReportScalarFieldEnum)[keyof typeof CashierReportScalarFieldEnum]


  export const CurrencyExchangeRateScalarFieldEnum: {
    id: 'id',
    fromCurrency: 'fromCurrency',
    toCurrency: 'toCurrency',
    rate: 'rate',
    isActive: 'isActive',
    branchId: 'branchId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyExchangeRateScalarFieldEnum = (typeof CurrencyExchangeRateScalarFieldEnum)[keyof typeof CurrencyExchangeRateScalarFieldEnum]


  export const BonusScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    reason: 'reason',
    description: 'description',
    bonusProducts: 'bonusProducts',
    bonusDate: 'bonusDate',
    createdById: 'createdById',
    branchId: 'branchId',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BonusScalarFieldEnum = (typeof BonusScalarFieldEnum)[keyof typeof BonusScalarFieldEnum]


  export const TransactionBonusProductScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionBonusProductScalarFieldEnum = (typeof TransactionBonusProductScalarFieldEnum)[keyof typeof TransactionBonusProductScalarFieldEnum]


  export const WorkScheduleScalarFieldEnum: {
    id: 'id',
    workStartTime: 'workStartTime',
    workEndTime: 'workEndTime',
    isDefault: 'isDefault',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkScheduleScalarFieldEnum = (typeof WorkScheduleScalarFieldEnum)[keyof typeof WorkScheduleScalarFieldEnum]


  export const BarcodeCounterScalarFieldEnum: {
    id: 'id',
    counter: 'counter',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BarcodeCounterScalarFieldEnum = (typeof BarcodeCounterScalarFieldEnum)[keyof typeof BarcodeCounterScalarFieldEnum]


  export const FaceTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    template: 'template',
    vector: 'vector',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FaceTemplateScalarFieldEnum = (typeof FaceTemplateScalarFieldEnum)[keyof typeof FaceTemplateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AttendanceEventType'
   */
  export type EnumAttendanceEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceEventType'>
    


  /**
   * Reference to a field of type 'AttendanceEventType[]'
   */
  export type ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BranchType'
   */
  export type EnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType'>
    


  /**
   * Reference to a field of type 'BranchType[]'
   */
  export type ListEnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType[]'>
    


  /**
   * Reference to a field of type 'BranchStatus'
   */
  export type EnumBranchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchStatus'>
    


  /**
   * Reference to a field of type 'BranchStatus[]'
   */
  export type ListEnumBranchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'ProductSizeType'
   */
  export type EnumProductSizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductSizeType'>
    


  /**
   * Reference to a field of type 'ProductSizeType[]'
   */
  export type ListEnumProductSizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductSizeType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type AttendanceDayWhereInput = {
    AND?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    OR?: AttendanceDayWhereInput[]
    NOT?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    id?: IntFilter<"AttendanceDay"> | number
    userId?: IntFilter<"AttendanceDay"> | number
    branchId?: IntNullableFilter<"AttendanceDay"> | number | null
    date?: DateTimeFilter<"AttendanceDay"> | Date | string
    checkInAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    totalMinutes?: IntNullableFilter<"AttendanceDay"> | number | null
    status?: EnumAttendanceStatusNullableFilter<"AttendanceDay"> | $Enums.AttendanceStatus | null
    deviceId?: StringNullableFilter<"AttendanceDay"> | string | null
    notes?: StringNullableFilter<"AttendanceDay"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    events?: AttendanceEventListRelationFilter
  }

  export type AttendanceDayOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    date?: SortOrder
    checkInAt?: SortOrderInput | SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    totalMinutes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    events?: AttendanceEventOrderByRelationAggregateInput
  }

  export type AttendanceDayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_date?: AttendanceDayUserIdDateCompoundUniqueInput
    AND?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    OR?: AttendanceDayWhereInput[]
    NOT?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    userId?: IntFilter<"AttendanceDay"> | number
    branchId?: IntNullableFilter<"AttendanceDay"> | number | null
    date?: DateTimeFilter<"AttendanceDay"> | Date | string
    checkInAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    totalMinutes?: IntNullableFilter<"AttendanceDay"> | number | null
    status?: EnumAttendanceStatusNullableFilter<"AttendanceDay"> | $Enums.AttendanceStatus | null
    deviceId?: StringNullableFilter<"AttendanceDay"> | string | null
    notes?: StringNullableFilter<"AttendanceDay"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    events?: AttendanceEventListRelationFilter
  }, "id" | "userId_date">

  export type AttendanceDayOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    date?: SortOrder
    checkInAt?: SortOrderInput | SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    totalMinutes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceDayCountOrderByAggregateInput
    _avg?: AttendanceDayAvgOrderByAggregateInput
    _max?: AttendanceDayMaxOrderByAggregateInput
    _min?: AttendanceDayMinOrderByAggregateInput
    _sum?: AttendanceDaySumOrderByAggregateInput
  }

  export type AttendanceDayScalarWhereWithAggregatesInput = {
    AND?: AttendanceDayScalarWhereWithAggregatesInput | AttendanceDayScalarWhereWithAggregatesInput[]
    OR?: AttendanceDayScalarWhereWithAggregatesInput[]
    NOT?: AttendanceDayScalarWhereWithAggregatesInput | AttendanceDayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceDay"> | number
    userId?: IntWithAggregatesFilter<"AttendanceDay"> | number
    branchId?: IntNullableWithAggregatesFilter<"AttendanceDay"> | number | null
    date?: DateTimeWithAggregatesFilter<"AttendanceDay"> | Date | string
    checkInAt?: DateTimeNullableWithAggregatesFilter<"AttendanceDay"> | Date | string | null
    checkOutAt?: DateTimeNullableWithAggregatesFilter<"AttendanceDay"> | Date | string | null
    totalMinutes?: IntNullableWithAggregatesFilter<"AttendanceDay"> | number | null
    status?: EnumAttendanceStatusNullableWithAggregatesFilter<"AttendanceDay"> | $Enums.AttendanceStatus | null
    deviceId?: StringNullableWithAggregatesFilter<"AttendanceDay"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AttendanceDay"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceDay"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceDay"> | Date | string
  }

  export type AttendanceEventWhereInput = {
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    id?: IntFilter<"AttendanceEvent"> | number
    userId?: IntFilter<"AttendanceEvent"> | number
    branchId?: IntNullableFilter<"AttendanceEvent"> | number | null
    dayId?: IntNullableFilter<"AttendanceEvent"> | number | null
    eventType?: EnumAttendanceEventTypeFilter<"AttendanceEvent"> | $Enums.AttendanceEventType
    occurredAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    similarity?: FloatNullableFilter<"AttendanceEvent"> | number | null
    payload?: JsonNullableFilter<"AttendanceEvent">
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    day?: XOR<AttendanceDayNullableScalarRelationFilter, AttendanceDayWhereInput> | null
  }

  export type AttendanceEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    dayId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    occurredAt?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    similarity?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    day?: AttendanceDayOrderByWithRelationInput
  }

  export type AttendanceEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    userId?: IntFilter<"AttendanceEvent"> | number
    branchId?: IntNullableFilter<"AttendanceEvent"> | number | null
    dayId?: IntNullableFilter<"AttendanceEvent"> | number | null
    eventType?: EnumAttendanceEventTypeFilter<"AttendanceEvent"> | $Enums.AttendanceEventType
    occurredAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    similarity?: FloatNullableFilter<"AttendanceEvent"> | number | null
    payload?: JsonNullableFilter<"AttendanceEvent">
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    day?: XOR<AttendanceDayNullableScalarRelationFilter, AttendanceDayWhereInput> | null
  }, "id">

  export type AttendanceEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    dayId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    occurredAt?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    similarity?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceEventCountOrderByAggregateInput
    _avg?: AttendanceEventAvgOrderByAggregateInput
    _max?: AttendanceEventMaxOrderByAggregateInput
    _min?: AttendanceEventMinOrderByAggregateInput
    _sum?: AttendanceEventSumOrderByAggregateInput
  }

  export type AttendanceEventScalarWhereWithAggregatesInput = {
    AND?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    OR?: AttendanceEventScalarWhereWithAggregatesInput[]
    NOT?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceEvent"> | number
    userId?: IntWithAggregatesFilter<"AttendanceEvent"> | number
    branchId?: IntNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    dayId?: IntNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    eventType?: EnumAttendanceEventTypeWithAggregatesFilter<"AttendanceEvent"> | $Enums.AttendanceEventType
    occurredAt?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
    deviceId?: StringNullableWithAggregatesFilter<"AttendanceEvent"> | string | null
    similarity?: FloatNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    payload?: JsonNullableWithAggregatesFilter<"AttendanceEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    cashBalance?: FloatFilter<"Branch"> | number
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    phoneNumber?: StringNullableFilter<"Branch"> | string | null
    status?: EnumBranchStatusFilter<"Branch"> | $Enums.BranchStatus
    products?: ProductListRelationFilter
    transactions?: TransactionListRelationFilter
    toTransactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    allowedUsers?: UserBranchAccessListRelationFilter
    categories?: CategoryListRelationFilter
    fromTransfers?: ProductTransferListRelationFilter
    toTransfers?: ProductTransferListRelationFilter
    defectiveLogs?: DefectiveLogListRelationFilter
    exchangeRates?: CurrencyExchangeRateListRelationFilter
    cashierReports?: CashierReportListRelationFilter
    DailyRepayment?: DailyRepaymentListRelationFilter
    CreditRepayment?: CreditRepaymentListRelationFilter
    bonuses?: BonusListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    type?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    toTransactions?: TransactionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    allowedUsers?: UserBranchAccessOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    fromTransfers?: ProductTransferOrderByRelationAggregateInput
    toTransfers?: ProductTransferOrderByRelationAggregateInput
    defectiveLogs?: DefectiveLogOrderByRelationAggregateInput
    exchangeRates?: CurrencyExchangeRateOrderByRelationAggregateInput
    cashierReports?: CashierReportOrderByRelationAggregateInput
    DailyRepayment?: DailyRepaymentOrderByRelationAggregateInput
    CreditRepayment?: CreditRepaymentOrderByRelationAggregateInput
    bonuses?: BonusOrderByRelationAggregateInput
    attendanceDays?: AttendanceDayOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    cashBalance?: FloatFilter<"Branch"> | number
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    phoneNumber?: StringNullableFilter<"Branch"> | string | null
    status?: EnumBranchStatusFilter<"Branch"> | $Enums.BranchStatus
    products?: ProductListRelationFilter
    transactions?: TransactionListRelationFilter
    toTransactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    allowedUsers?: UserBranchAccessListRelationFilter
    categories?: CategoryListRelationFilter
    fromTransfers?: ProductTransferListRelationFilter
    toTransfers?: ProductTransferListRelationFilter
    defectiveLogs?: DefectiveLogListRelationFilter
    exchangeRates?: CurrencyExchangeRateListRelationFilter
    cashierReports?: CashierReportListRelationFilter
    DailyRepayment?: DailyRepaymentListRelationFilter
    CreditRepayment?: CreditRepaymentListRelationFilter
    bonuses?: BonusListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    type?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    type?: EnumBranchTypeWithAggregatesFilter<"Branch"> | $Enums.BranchType
    cashBalance?: FloatWithAggregatesFilter<"Branch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    status?: EnumBranchStatusWithAggregatesFilter<"Branch"> | $Enums.BranchStatus
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    workStartTime?: StringNullableFilter<"User"> | string | null
    workEndTime?: StringNullableFilter<"User"> | string | null
    workShift?: StringNullableFilter<"User"> | string | null
    allowedBranches?: UserBranchAccessListRelationFilter
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    createdTransactions?: TransactionListRelationFilter
    soldTransactions?: TransactionListRelationFilter
    initiatedTransfers?: ProductTransferListRelationFilter
    approvedTransfers?: ProductTransferListRelationFilter
    userLocations?: UserLocationListRelationFilter
    defectiveLogs?: DefectiveLogListRelationFilter
    PaymentSchedule?: PaymentScheduleListRelationFilter
    PaymentRepayment?: PaymentRepaymentListRelationFilter
    dailyRepayments?: DailyRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
    cashierReports?: CashierReportListRelationFilter
    exchangeRates?: CurrencyExchangeRateListRelationFilter
    bonuses?: BonusListRelationFilter
    createdBonuses?: BonusListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    faceTemplates?: FaceTemplateListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    workStartTime?: SortOrderInput | SortOrder
    workEndTime?: SortOrderInput | SortOrder
    workShift?: SortOrderInput | SortOrder
    allowedBranches?: UserBranchAccessOrderByRelationAggregateInput
    branch?: BranchOrderByWithRelationInput
    createdTransactions?: TransactionOrderByRelationAggregateInput
    soldTransactions?: TransactionOrderByRelationAggregateInput
    initiatedTransfers?: ProductTransferOrderByRelationAggregateInput
    approvedTransfers?: ProductTransferOrderByRelationAggregateInput
    userLocations?: UserLocationOrderByRelationAggregateInput
    defectiveLogs?: DefectiveLogOrderByRelationAggregateInput
    PaymentSchedule?: PaymentScheduleOrderByRelationAggregateInput
    PaymentRepayment?: PaymentRepaymentOrderByRelationAggregateInput
    dailyRepayments?: DailyRepaymentOrderByRelationAggregateInput
    creditRepayments?: CreditRepaymentOrderByRelationAggregateInput
    cashierReports?: CashierReportOrderByRelationAggregateInput
    exchangeRates?: CurrencyExchangeRateOrderByRelationAggregateInput
    bonuses?: BonusOrderByRelationAggregateInput
    createdBonuses?: BonusOrderByRelationAggregateInput
    attendanceDays?: AttendanceDayOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    faceTemplates?: FaceTemplateOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    workStartTime?: StringNullableFilter<"User"> | string | null
    workEndTime?: StringNullableFilter<"User"> | string | null
    workShift?: StringNullableFilter<"User"> | string | null
    allowedBranches?: UserBranchAccessListRelationFilter
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    createdTransactions?: TransactionListRelationFilter
    soldTransactions?: TransactionListRelationFilter
    initiatedTransfers?: ProductTransferListRelationFilter
    approvedTransfers?: ProductTransferListRelationFilter
    userLocations?: UserLocationListRelationFilter
    defectiveLogs?: DefectiveLogListRelationFilter
    PaymentSchedule?: PaymentScheduleListRelationFilter
    PaymentRepayment?: PaymentRepaymentListRelationFilter
    dailyRepayments?: DailyRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
    cashierReports?: CashierReportListRelationFilter
    exchangeRates?: CurrencyExchangeRateListRelationFilter
    bonuses?: BonusListRelationFilter
    createdBonuses?: BonusListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    faceTemplates?: FaceTemplateListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "phone" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    workStartTime?: SortOrderInput | SortOrder
    workEndTime?: SortOrderInput | SortOrder
    workShift?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    workStartTime?: StringNullableWithAggregatesFilter<"User"> | string | null
    workEndTime?: StringNullableWithAggregatesFilter<"User"> | string | null
    workShift?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserBranchAccessWhereInput = {
    AND?: UserBranchAccessWhereInput | UserBranchAccessWhereInput[]
    OR?: UserBranchAccessWhereInput[]
    NOT?: UserBranchAccessWhereInput | UserBranchAccessWhereInput[]
    id?: IntFilter<"UserBranchAccess"> | number
    userId?: IntFilter<"UserBranchAccess"> | number
    branchId?: IntFilter<"UserBranchAccess"> | number
    createdAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type UserBranchAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type UserBranchAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_branchId?: UserBranchAccessUserIdBranchIdCompoundUniqueInput
    AND?: UserBranchAccessWhereInput | UserBranchAccessWhereInput[]
    OR?: UserBranchAccessWhereInput[]
    NOT?: UserBranchAccessWhereInput | UserBranchAccessWhereInput[]
    userId?: IntFilter<"UserBranchAccess"> | number
    branchId?: IntFilter<"UserBranchAccess"> | number
    createdAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id" | "userId_branchId">

  export type UserBranchAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBranchAccessCountOrderByAggregateInput
    _avg?: UserBranchAccessAvgOrderByAggregateInput
    _max?: UserBranchAccessMaxOrderByAggregateInput
    _min?: UserBranchAccessMinOrderByAggregateInput
    _sum?: UserBranchAccessSumOrderByAggregateInput
  }

  export type UserBranchAccessScalarWhereWithAggregatesInput = {
    AND?: UserBranchAccessScalarWhereWithAggregatesInput | UserBranchAccessScalarWhereWithAggregatesInput[]
    OR?: UserBranchAccessScalarWhereWithAggregatesInput[]
    NOT?: UserBranchAccessScalarWhereWithAggregatesInput | UserBranchAccessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBranchAccess"> | number
    userId?: IntWithAggregatesFilter<"UserBranchAccess"> | number
    branchId?: IntWithAggregatesFilter<"UserBranchAccess"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserBranchAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBranchAccess"> | Date | string
  }

  export type UserLocationWhereInput = {
    AND?: UserLocationWhereInput | UserLocationWhereInput[]
    OR?: UserLocationWhereInput[]
    NOT?: UserLocationWhereInput | UserLocationWhereInput[]
    userId?: IntFilter<"UserLocation"> | number
    latitude?: FloatFilter<"UserLocation"> | number
    longitude?: FloatFilter<"UserLocation"> | number
    address?: StringNullableFilter<"UserLocation"> | string | null
    isOnline?: BoolFilter<"UserLocation"> | boolean
    lastSeen?: DateTimeFilter<"UserLocation"> | Date | string
    updatedAt?: DateTimeFilter<"UserLocation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLocationOrderByWithRelationInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLocationWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserLocationWhereInput | UserLocationWhereInput[]
    OR?: UserLocationWhereInput[]
    NOT?: UserLocationWhereInput | UserLocationWhereInput[]
    latitude?: FloatFilter<"UserLocation"> | number
    longitude?: FloatFilter<"UserLocation"> | number
    address?: StringNullableFilter<"UserLocation"> | string | null
    isOnline?: BoolFilter<"UserLocation"> | boolean
    lastSeen?: DateTimeFilter<"UserLocation"> | Date | string
    updatedAt?: DateTimeFilter<"UserLocation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type UserLocationOrderByWithAggregationInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
    _count?: UserLocationCountOrderByAggregateInput
    _avg?: UserLocationAvgOrderByAggregateInput
    _max?: UserLocationMaxOrderByAggregateInput
    _min?: UserLocationMinOrderByAggregateInput
    _sum?: UserLocationSumOrderByAggregateInput
  }

  export type UserLocationScalarWhereWithAggregatesInput = {
    AND?: UserLocationScalarWhereWithAggregatesInput | UserLocationScalarWhereWithAggregatesInput[]
    OR?: UserLocationScalarWhereWithAggregatesInput[]
    NOT?: UserLocationScalarWhereWithAggregatesInput | UserLocationScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserLocation"> | number
    latitude?: FloatWithAggregatesFilter<"UserLocation"> | number
    longitude?: FloatWithAggregatesFilter<"UserLocation"> | number
    address?: StringNullableWithAggregatesFilter<"UserLocation"> | string | null
    isOnline?: BoolWithAggregatesFilter<"UserLocation"> | boolean
    lastSeen?: DateTimeWithAggregatesFilter<"UserLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLocation"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    branchId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    branchId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    branchId?: IntNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    defectiveQuantity?: IntFilter<"Product"> | number
    returnedQuantity?: IntFilter<"Product"> | number
    exchangedQuantity?: IntFilter<"Product"> | number
    initialQuantity?: IntFilter<"Product"> | number
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    marketPrice?: FloatNullableFilter<"Product"> | number | null
    bonusPercentage?: FloatNullableFilter<"Product"> | number | null
    isDeleted?: BoolFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    sizeType?: EnumProductSizeTypeFilter<"Product"> | $Enums.ProductSizeType
    sizeLabel?: StringNullableFilter<"Product"> | string | null
    sizeNumber?: FloatNullableFilter<"Product"> | number | null
    areaSqm?: FloatNullableFilter<"Product"> | number | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    transactions?: TransactionItemListRelationFilter
    DefectiveLog?: DefectiveLogListRelationFilter
    ProductTransfer?: ProductTransferListRelationFilter
    bonusProducts?: TransactionBonusProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrderInput | SortOrder
    bonusPercentage?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    sizeType?: SortOrder
    sizeLabel?: SortOrderInput | SortOrder
    sizeNumber?: SortOrderInput | SortOrder
    areaSqm?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    transactions?: TransactionItemOrderByRelationAggregateInput
    DefectiveLog?: DefectiveLogOrderByRelationAggregateInput
    ProductTransfer?: ProductTransferOrderByRelationAggregateInput
    bonusProducts?: TransactionBonusProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    barcode_branchId?: ProductBarcode_branchIdCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    defectiveQuantity?: IntFilter<"Product"> | number
    returnedQuantity?: IntFilter<"Product"> | number
    exchangedQuantity?: IntFilter<"Product"> | number
    initialQuantity?: IntFilter<"Product"> | number
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    marketPrice?: FloatNullableFilter<"Product"> | number | null
    bonusPercentage?: FloatNullableFilter<"Product"> | number | null
    isDeleted?: BoolFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    sizeType?: EnumProductSizeTypeFilter<"Product"> | $Enums.ProductSizeType
    sizeLabel?: StringNullableFilter<"Product"> | string | null
    sizeNumber?: FloatNullableFilter<"Product"> | number | null
    areaSqm?: FloatNullableFilter<"Product"> | number | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    transactions?: TransactionItemListRelationFilter
    DefectiveLog?: DefectiveLogListRelationFilter
    ProductTransfer?: ProductTransferListRelationFilter
    bonusProducts?: TransactionBonusProductListRelationFilter
  }, "id" | "barcode_branchId">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrderInput | SortOrder
    bonusPercentage?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    sizeType?: SortOrder
    sizeLabel?: SortOrderInput | SortOrder
    sizeNumber?: SortOrderInput | SortOrder
    areaSqm?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    model?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    quantity?: IntWithAggregatesFilter<"Product"> | number
    defectiveQuantity?: IntWithAggregatesFilter<"Product"> | number
    returnedQuantity?: IntWithAggregatesFilter<"Product"> | number
    exchangedQuantity?: IntWithAggregatesFilter<"Product"> | number
    initialQuantity?: IntWithAggregatesFilter<"Product"> | number
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    branchId?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    marketPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    bonusPercentage?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    sizeType?: EnumProductSizeTypeWithAggregatesFilter<"Product"> | $Enums.ProductSizeType
    sizeLabel?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sizeNumber?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    areaSqm?: FloatNullableWithAggregatesFilter<"Product"> | number | null
  }

  export type DefectiveLogWhereInput = {
    AND?: DefectiveLogWhereInput | DefectiveLogWhereInput[]
    OR?: DefectiveLogWhereInput[]
    NOT?: DefectiveLogWhereInput | DefectiveLogWhereInput[]
    id?: IntFilter<"DefectiveLog"> | number
    productId?: IntFilter<"DefectiveLog"> | number
    quantity?: IntFilter<"DefectiveLog"> | number
    description?: StringFilter<"DefectiveLog"> | string
    userId?: IntNullableFilter<"DefectiveLog"> | number | null
    branchId?: IntNullableFilter<"DefectiveLog"> | number | null
    cashAmount?: FloatFilter<"DefectiveLog"> | number
    actionType?: StringFilter<"DefectiveLog"> | string
    createdAt?: DateTimeFilter<"DefectiveLog"> | Date | string
    exchangeWithProductId?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementQuantity?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementUnitPrice?: FloatNullableFilter<"DefectiveLog"> | number | null
    replacementTransactionId?: IntNullableFilter<"DefectiveLog"> | number | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type DefectiveLogOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    cashAmount?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    exchangeWithProductId?: SortOrderInput | SortOrder
    replacementQuantity?: SortOrderInput | SortOrder
    replacementUnitPrice?: SortOrderInput | SortOrder
    replacementTransactionId?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DefectiveLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DefectiveLogWhereInput | DefectiveLogWhereInput[]
    OR?: DefectiveLogWhereInput[]
    NOT?: DefectiveLogWhereInput | DefectiveLogWhereInput[]
    productId?: IntFilter<"DefectiveLog"> | number
    quantity?: IntFilter<"DefectiveLog"> | number
    description?: StringFilter<"DefectiveLog"> | string
    userId?: IntNullableFilter<"DefectiveLog"> | number | null
    branchId?: IntNullableFilter<"DefectiveLog"> | number | null
    cashAmount?: FloatFilter<"DefectiveLog"> | number
    actionType?: StringFilter<"DefectiveLog"> | string
    createdAt?: DateTimeFilter<"DefectiveLog"> | Date | string
    exchangeWithProductId?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementQuantity?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementUnitPrice?: FloatNullableFilter<"DefectiveLog"> | number | null
    replacementTransactionId?: IntNullableFilter<"DefectiveLog"> | number | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type DefectiveLogOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    cashAmount?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    exchangeWithProductId?: SortOrderInput | SortOrder
    replacementQuantity?: SortOrderInput | SortOrder
    replacementUnitPrice?: SortOrderInput | SortOrder
    replacementTransactionId?: SortOrderInput | SortOrder
    _count?: DefectiveLogCountOrderByAggregateInput
    _avg?: DefectiveLogAvgOrderByAggregateInput
    _max?: DefectiveLogMaxOrderByAggregateInput
    _min?: DefectiveLogMinOrderByAggregateInput
    _sum?: DefectiveLogSumOrderByAggregateInput
  }

  export type DefectiveLogScalarWhereWithAggregatesInput = {
    AND?: DefectiveLogScalarWhereWithAggregatesInput | DefectiveLogScalarWhereWithAggregatesInput[]
    OR?: DefectiveLogScalarWhereWithAggregatesInput[]
    NOT?: DefectiveLogScalarWhereWithAggregatesInput | DefectiveLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DefectiveLog"> | number
    productId?: IntWithAggregatesFilter<"DefectiveLog"> | number
    quantity?: IntWithAggregatesFilter<"DefectiveLog"> | number
    description?: StringWithAggregatesFilter<"DefectiveLog"> | string
    userId?: IntNullableWithAggregatesFilter<"DefectiveLog"> | number | null
    branchId?: IntNullableWithAggregatesFilter<"DefectiveLog"> | number | null
    cashAmount?: FloatWithAggregatesFilter<"DefectiveLog"> | number
    actionType?: StringWithAggregatesFilter<"DefectiveLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DefectiveLog"> | Date | string
    exchangeWithProductId?: IntNullableWithAggregatesFilter<"DefectiveLog"> | number | null
    replacementQuantity?: IntNullableWithAggregatesFilter<"DefectiveLog"> | number | null
    replacementUnitPrice?: FloatNullableWithAggregatesFilter<"DefectiveLog"> | number | null
    replacementTransactionId?: IntNullableWithAggregatesFilter<"DefectiveLog"> | number | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    fullName?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    passportSeries?: StringNullableFilter<"Customer"> | string | null
    jshshir?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    passportSeries?: SortOrderInput | SortOrder
    jshshir?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    fullName?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    passportSeries?: StringNullableFilter<"Customer"> | string | null
    jshshir?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
  }, "id" | "phone" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    passportSeries?: SortOrderInput | SortOrder
    jshshir?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    fullName?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    passportSeries?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    jshshir?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    customerId?: IntNullableFilter<"Transaction"> | number | null
    userId?: IntNullableFilter<"Transaction"> | number | null
    soldByUserId?: IntNullableFilter<"Transaction"> | number | null
    fromBranchId?: IntNullableFilter<"Transaction"> | number | null
    toBranchId?: IntNullableFilter<"Transaction"> | number | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transactionType?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    finalTotal?: FloatFilter<"Transaction"> | number
    paymentType?: EnumPaymentTypeNullableFilter<"Transaction"> | $Enums.PaymentType | null
    upfrontPaymentType?: StringNullableFilter<"Transaction"> | string | null
    termUnit?: StringNullableFilter<"Transaction"> | string | null
    deliveryMethod?: StringNullableFilter<"Transaction"> | string | null
    deliveryType?: StringNullableFilter<"Transaction"> | string | null
    deliveryAddress?: StringNullableFilter<"Transaction"> | string | null
    amountPaid?: FloatNullableFilter<"Transaction"> | number | null
    downPayment?: FloatNullableFilter<"Transaction"> | number | null
    remainingBalance?: FloatNullableFilter<"Transaction"> | number | null
    receiptId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: IntNullableFilter<"Transaction"> | number | null
    creditRepaymentAmount?: FloatNullableFilter<"Transaction"> | number | null
    lastRepaymentDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    extraProfit?: FloatNullableFilter<"Transaction"> | number | null
    days?: IntNullableFilter<"Transaction"> | number | null
    months?: IntNullableFilter<"Transaction"> | number | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    soldBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    fromBranch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    toBranch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: TransactionItemListRelationFilter
    paymentSchedules?: PaymentScheduleListRelationFilter
    PaymentRepayment?: PaymentRepaymentListRelationFilter
    dailyRepayments?: DailyRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
    bonusProducts?: TransactionBonusProductListRelationFilter
    bonuses?: BonusListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    soldByUserId?: SortOrderInput | SortOrder
    fromBranchId?: SortOrderInput | SortOrder
    toBranchId?: SortOrderInput | SortOrder
    type?: SortOrder
    transactionType?: SortOrderInput | SortOrder
    status?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    upfrontPaymentType?: SortOrderInput | SortOrder
    termUnit?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    deliveryType?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    downPayment?: SortOrderInput | SortOrder
    remainingBalance?: SortOrderInput | SortOrder
    receiptId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    creditRepaymentAmount?: SortOrderInput | SortOrder
    lastRepaymentDate?: SortOrderInput | SortOrder
    extraProfit?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    months?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    soldBy?: UserOrderByWithRelationInput
    fromBranch?: BranchOrderByWithRelationInput
    toBranch?: BranchOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: TransactionItemOrderByRelationAggregateInput
    paymentSchedules?: PaymentScheduleOrderByRelationAggregateInput
    PaymentRepayment?: PaymentRepaymentOrderByRelationAggregateInput
    dailyRepayments?: DailyRepaymentOrderByRelationAggregateInput
    creditRepayments?: CreditRepaymentOrderByRelationAggregateInput
    bonusProducts?: TransactionBonusProductOrderByRelationAggregateInput
    bonuses?: BonusOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    customerId?: IntNullableFilter<"Transaction"> | number | null
    userId?: IntNullableFilter<"Transaction"> | number | null
    soldByUserId?: IntNullableFilter<"Transaction"> | number | null
    fromBranchId?: IntNullableFilter<"Transaction"> | number | null
    toBranchId?: IntNullableFilter<"Transaction"> | number | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transactionType?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    finalTotal?: FloatFilter<"Transaction"> | number
    paymentType?: EnumPaymentTypeNullableFilter<"Transaction"> | $Enums.PaymentType | null
    upfrontPaymentType?: StringNullableFilter<"Transaction"> | string | null
    termUnit?: StringNullableFilter<"Transaction"> | string | null
    deliveryMethod?: StringNullableFilter<"Transaction"> | string | null
    deliveryType?: StringNullableFilter<"Transaction"> | string | null
    deliveryAddress?: StringNullableFilter<"Transaction"> | string | null
    amountPaid?: FloatNullableFilter<"Transaction"> | number | null
    downPayment?: FloatNullableFilter<"Transaction"> | number | null
    remainingBalance?: FloatNullableFilter<"Transaction"> | number | null
    receiptId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: IntNullableFilter<"Transaction"> | number | null
    creditRepaymentAmount?: FloatNullableFilter<"Transaction"> | number | null
    lastRepaymentDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    extraProfit?: FloatNullableFilter<"Transaction"> | number | null
    days?: IntNullableFilter<"Transaction"> | number | null
    months?: IntNullableFilter<"Transaction"> | number | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    soldBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    fromBranch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    toBranch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: TransactionItemListRelationFilter
    paymentSchedules?: PaymentScheduleListRelationFilter
    PaymentRepayment?: PaymentRepaymentListRelationFilter
    dailyRepayments?: DailyRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
    bonusProducts?: TransactionBonusProductListRelationFilter
    bonuses?: BonusListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    soldByUserId?: SortOrderInput | SortOrder
    fromBranchId?: SortOrderInput | SortOrder
    toBranchId?: SortOrderInput | SortOrder
    type?: SortOrder
    transactionType?: SortOrderInput | SortOrder
    status?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    upfrontPaymentType?: SortOrderInput | SortOrder
    termUnit?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    deliveryType?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    downPayment?: SortOrderInput | SortOrder
    remainingBalance?: SortOrderInput | SortOrder
    receiptId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    creditRepaymentAmount?: SortOrderInput | SortOrder
    lastRepaymentDate?: SortOrderInput | SortOrder
    extraProfit?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    months?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    customerId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    soldByUserId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    fromBranchId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    toBranchId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    transactionType?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    discount?: FloatWithAggregatesFilter<"Transaction"> | number
    total?: FloatWithAggregatesFilter<"Transaction"> | number
    finalTotal?: FloatWithAggregatesFilter<"Transaction"> | number
    paymentType?: EnumPaymentTypeNullableWithAggregatesFilter<"Transaction"> | $Enums.PaymentType | null
    upfrontPaymentType?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    termUnit?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    deliveryMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    deliveryType?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    deliveryAddress?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    amountPaid?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    downPayment?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    remainingBalance?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    receiptId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    updatedById?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    creditRepaymentAmount?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    lastRepaymentDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    extraProfit?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    days?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    months?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransactionItemWhereInput = {
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    id?: IntFilter<"TransactionItem"> | number
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntNullableFilter<"TransactionItem"> | number | null
    quantity?: IntFilter<"TransactionItem"> | number
    price?: FloatFilter<"TransactionItem"> | number
    sellingPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    originalPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    total?: FloatFilter<"TransactionItem"> | number
    creditMonth?: IntNullableFilter<"TransactionItem"> | number | null
    creditPercent?: FloatNullableFilter<"TransactionItem"> | number | null
    monthlyPayment?: FloatNullableFilter<"TransactionItem"> | number | null
    status?: StringNullableFilter<"TransactionItem"> | string | null
    createdAt?: DateTimeFilter<"TransactionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionItem"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type TransactionItemOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    total?: SortOrder
    creditMonth?: SortOrderInput | SortOrder
    creditPercent?: SortOrderInput | SortOrder
    monthlyPayment?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransactionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntNullableFilter<"TransactionItem"> | number | null
    quantity?: IntFilter<"TransactionItem"> | number
    price?: FloatFilter<"TransactionItem"> | number
    sellingPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    originalPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    total?: FloatFilter<"TransactionItem"> | number
    creditMonth?: IntNullableFilter<"TransactionItem"> | number | null
    creditPercent?: FloatNullableFilter<"TransactionItem"> | number | null
    monthlyPayment?: FloatNullableFilter<"TransactionItem"> | number | null
    status?: StringNullableFilter<"TransactionItem"> | string | null
    createdAt?: DateTimeFilter<"TransactionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionItem"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type TransactionItemOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    total?: SortOrder
    creditMonth?: SortOrderInput | SortOrder
    creditPercent?: SortOrderInput | SortOrder
    monthlyPayment?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionItemCountOrderByAggregateInput
    _avg?: TransactionItemAvgOrderByAggregateInput
    _max?: TransactionItemMaxOrderByAggregateInput
    _min?: TransactionItemMinOrderByAggregateInput
    _sum?: TransactionItemSumOrderByAggregateInput
  }

  export type TransactionItemScalarWhereWithAggregatesInput = {
    AND?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    OR?: TransactionItemScalarWhereWithAggregatesInput[]
    NOT?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionItem"> | number
    transactionId?: IntWithAggregatesFilter<"TransactionItem"> | number
    productId?: IntNullableWithAggregatesFilter<"TransactionItem"> | number | null
    quantity?: IntWithAggregatesFilter<"TransactionItem"> | number
    price?: FloatWithAggregatesFilter<"TransactionItem"> | number
    sellingPrice?: FloatNullableWithAggregatesFilter<"TransactionItem"> | number | null
    originalPrice?: FloatNullableWithAggregatesFilter<"TransactionItem"> | number | null
    total?: FloatWithAggregatesFilter<"TransactionItem"> | number
    creditMonth?: IntNullableWithAggregatesFilter<"TransactionItem"> | number | null
    creditPercent?: FloatNullableWithAggregatesFilter<"TransactionItem"> | number | null
    monthlyPayment?: FloatNullableWithAggregatesFilter<"TransactionItem"> | number | null
    status?: StringNullableWithAggregatesFilter<"TransactionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionItem"> | Date | string
  }

  export type ProductTransferWhereInput = {
    AND?: ProductTransferWhereInput | ProductTransferWhereInput[]
    OR?: ProductTransferWhereInput[]
    NOT?: ProductTransferWhereInput | ProductTransferWhereInput[]
    id?: IntFilter<"ProductTransfer"> | number
    productId?: IntFilter<"ProductTransfer"> | number
    fromBranchId?: IntFilter<"ProductTransfer"> | number
    toBranchId?: IntFilter<"ProductTransfer"> | number
    quantity?: IntFilter<"ProductTransfer"> | number
    status?: EnumTransferStatusFilter<"ProductTransfer"> | $Enums.TransferStatus
    initiatedById?: IntFilter<"ProductTransfer"> | number
    approvedById?: IntNullableFilter<"ProductTransfer"> | number | null
    transferDate?: DateTimeFilter<"ProductTransfer"> | Date | string
    createdAt?: DateTimeFilter<"ProductTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTransfer"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromBranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    toBranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    initiatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProductTransferOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    fromBranch?: BranchOrderByWithRelationInput
    toBranch?: BranchOrderByWithRelationInput
    initiatedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type ProductTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductTransferWhereInput | ProductTransferWhereInput[]
    OR?: ProductTransferWhereInput[]
    NOT?: ProductTransferWhereInput | ProductTransferWhereInput[]
    productId?: IntFilter<"ProductTransfer"> | number
    fromBranchId?: IntFilter<"ProductTransfer"> | number
    toBranchId?: IntFilter<"ProductTransfer"> | number
    quantity?: IntFilter<"ProductTransfer"> | number
    status?: EnumTransferStatusFilter<"ProductTransfer"> | $Enums.TransferStatus
    initiatedById?: IntFilter<"ProductTransfer"> | number
    approvedById?: IntNullableFilter<"ProductTransfer"> | number | null
    transferDate?: DateTimeFilter<"ProductTransfer"> | Date | string
    createdAt?: DateTimeFilter<"ProductTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTransfer"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromBranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    toBranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    initiatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProductTransferOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductTransferCountOrderByAggregateInput
    _avg?: ProductTransferAvgOrderByAggregateInput
    _max?: ProductTransferMaxOrderByAggregateInput
    _min?: ProductTransferMinOrderByAggregateInput
    _sum?: ProductTransferSumOrderByAggregateInput
  }

  export type ProductTransferScalarWhereWithAggregatesInput = {
    AND?: ProductTransferScalarWhereWithAggregatesInput | ProductTransferScalarWhereWithAggregatesInput[]
    OR?: ProductTransferScalarWhereWithAggregatesInput[]
    NOT?: ProductTransferScalarWhereWithAggregatesInput | ProductTransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductTransfer"> | number
    productId?: IntWithAggregatesFilter<"ProductTransfer"> | number
    fromBranchId?: IntWithAggregatesFilter<"ProductTransfer"> | number
    toBranchId?: IntWithAggregatesFilter<"ProductTransfer"> | number
    quantity?: IntWithAggregatesFilter<"ProductTransfer"> | number
    status?: EnumTransferStatusWithAggregatesFilter<"ProductTransfer"> | $Enums.TransferStatus
    initiatedById?: IntWithAggregatesFilter<"ProductTransfer"> | number
    approvedById?: IntNullableWithAggregatesFilter<"ProductTransfer"> | number | null
    transferDate?: DateTimeWithAggregatesFilter<"ProductTransfer"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductTransfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductTransfer"> | Date | string
  }

  export type PaymentScheduleWhereInput = {
    AND?: PaymentScheduleWhereInput | PaymentScheduleWhereInput[]
    OR?: PaymentScheduleWhereInput[]
    NOT?: PaymentScheduleWhereInput | PaymentScheduleWhereInput[]
    id?: IntFilter<"PaymentSchedule"> | number
    transactionId?: IntFilter<"PaymentSchedule"> | number
    month?: IntFilter<"PaymentSchedule"> | number
    payment?: FloatFilter<"PaymentSchedule"> | number
    remainingBalance?: FloatFilter<"PaymentSchedule"> | number
    isPaid?: BoolFilter<"PaymentSchedule"> | boolean
    paidAmount?: FloatFilter<"PaymentSchedule"> | number
    paidAt?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    paidChannel?: StringNullableFilter<"PaymentSchedule"> | string | null
    paidByUserId?: IntNullableFilter<"PaymentSchedule"> | number | null
    createdAt?: DateTimeFilter<"PaymentSchedule"> | Date | string
    creditRepaymentAmount?: FloatNullableFilter<"PaymentSchedule"> | number | null
    repaymentDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    rating?: StringNullableFilter<"PaymentSchedule"> | string | null
    dueDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    isDailyInstallment?: BoolFilter<"PaymentSchedule"> | boolean
    daysCount?: IntNullableFilter<"PaymentSchedule"> | number | null
    installmentType?: StringNullableFilter<"PaymentSchedule"> | string | null
    totalDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    totalMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    repayments?: PaymentRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
  }

  export type PaymentScheduleOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidChannel?: SortOrderInput | SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creditRepaymentAmount?: SortOrderInput | SortOrder
    repaymentDate?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    isDailyInstallment?: SortOrder
    daysCount?: SortOrderInput | SortOrder
    installmentType?: SortOrderInput | SortOrder
    totalDays?: SortOrderInput | SortOrder
    remainingDays?: SortOrderInput | SortOrder
    totalMonths?: SortOrderInput | SortOrder
    remainingMonths?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
    paidBy?: UserOrderByWithRelationInput
    repayments?: PaymentRepaymentOrderByRelationAggregateInput
    creditRepayments?: CreditRepaymentOrderByRelationAggregateInput
  }

  export type PaymentScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentScheduleWhereInput | PaymentScheduleWhereInput[]
    OR?: PaymentScheduleWhereInput[]
    NOT?: PaymentScheduleWhereInput | PaymentScheduleWhereInput[]
    transactionId?: IntFilter<"PaymentSchedule"> | number
    month?: IntFilter<"PaymentSchedule"> | number
    payment?: FloatFilter<"PaymentSchedule"> | number
    remainingBalance?: FloatFilter<"PaymentSchedule"> | number
    isPaid?: BoolFilter<"PaymentSchedule"> | boolean
    paidAmount?: FloatFilter<"PaymentSchedule"> | number
    paidAt?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    paidChannel?: StringNullableFilter<"PaymentSchedule"> | string | null
    paidByUserId?: IntNullableFilter<"PaymentSchedule"> | number | null
    createdAt?: DateTimeFilter<"PaymentSchedule"> | Date | string
    creditRepaymentAmount?: FloatNullableFilter<"PaymentSchedule"> | number | null
    repaymentDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    rating?: StringNullableFilter<"PaymentSchedule"> | string | null
    dueDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    isDailyInstallment?: BoolFilter<"PaymentSchedule"> | boolean
    daysCount?: IntNullableFilter<"PaymentSchedule"> | number | null
    installmentType?: StringNullableFilter<"PaymentSchedule"> | string | null
    totalDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    totalMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    repayments?: PaymentRepaymentListRelationFilter
    creditRepayments?: CreditRepaymentListRelationFilter
  }, "id">

  export type PaymentScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidChannel?: SortOrderInput | SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creditRepaymentAmount?: SortOrderInput | SortOrder
    repaymentDate?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    isDailyInstallment?: SortOrder
    daysCount?: SortOrderInput | SortOrder
    installmentType?: SortOrderInput | SortOrder
    totalDays?: SortOrderInput | SortOrder
    remainingDays?: SortOrderInput | SortOrder
    totalMonths?: SortOrderInput | SortOrder
    remainingMonths?: SortOrderInput | SortOrder
    _count?: PaymentScheduleCountOrderByAggregateInput
    _avg?: PaymentScheduleAvgOrderByAggregateInput
    _max?: PaymentScheduleMaxOrderByAggregateInput
    _min?: PaymentScheduleMinOrderByAggregateInput
    _sum?: PaymentScheduleSumOrderByAggregateInput
  }

  export type PaymentScheduleScalarWhereWithAggregatesInput = {
    AND?: PaymentScheduleScalarWhereWithAggregatesInput | PaymentScheduleScalarWhereWithAggregatesInput[]
    OR?: PaymentScheduleScalarWhereWithAggregatesInput[]
    NOT?: PaymentScheduleScalarWhereWithAggregatesInput | PaymentScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentSchedule"> | number
    transactionId?: IntWithAggregatesFilter<"PaymentSchedule"> | number
    month?: IntWithAggregatesFilter<"PaymentSchedule"> | number
    payment?: FloatWithAggregatesFilter<"PaymentSchedule"> | number
    remainingBalance?: FloatWithAggregatesFilter<"PaymentSchedule"> | number
    isPaid?: BoolWithAggregatesFilter<"PaymentSchedule"> | boolean
    paidAmount?: FloatWithAggregatesFilter<"PaymentSchedule"> | number
    paidAt?: DateTimeNullableWithAggregatesFilter<"PaymentSchedule"> | Date | string | null
    paidChannel?: StringNullableWithAggregatesFilter<"PaymentSchedule"> | string | null
    paidByUserId?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentSchedule"> | Date | string
    creditRepaymentAmount?: FloatNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    repaymentDate?: DateTimeNullableWithAggregatesFilter<"PaymentSchedule"> | Date | string | null
    rating?: StringNullableWithAggregatesFilter<"PaymentSchedule"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"PaymentSchedule"> | Date | string | null
    isDailyInstallment?: BoolWithAggregatesFilter<"PaymentSchedule"> | boolean
    daysCount?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    installmentType?: StringNullableWithAggregatesFilter<"PaymentSchedule"> | string | null
    totalDays?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    remainingDays?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    totalMonths?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
    remainingMonths?: IntNullableWithAggregatesFilter<"PaymentSchedule"> | number | null
  }

  export type PaymentRepaymentWhereInput = {
    AND?: PaymentRepaymentWhereInput | PaymentRepaymentWhereInput[]
    OR?: PaymentRepaymentWhereInput[]
    NOT?: PaymentRepaymentWhereInput | PaymentRepaymentWhereInput[]
    id?: IntFilter<"PaymentRepayment"> | number
    transactionId?: IntFilter<"PaymentRepayment"> | number
    scheduleId?: IntFilter<"PaymentRepayment"> | number
    amount?: FloatFilter<"PaymentRepayment"> | number
    channel?: StringFilter<"PaymentRepayment"> | string
    paidAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"PaymentRepayment"> | number | null
    createdAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    schedule?: XOR<PaymentScheduleScalarRelationFilter, PaymentScheduleWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentRepaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    schedule?: PaymentScheduleOrderByWithRelationInput
    paidBy?: UserOrderByWithRelationInput
  }

  export type PaymentRepaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentRepaymentWhereInput | PaymentRepaymentWhereInput[]
    OR?: PaymentRepaymentWhereInput[]
    NOT?: PaymentRepaymentWhereInput | PaymentRepaymentWhereInput[]
    transactionId?: IntFilter<"PaymentRepayment"> | number
    scheduleId?: IntFilter<"PaymentRepayment"> | number
    amount?: FloatFilter<"PaymentRepayment"> | number
    channel?: StringFilter<"PaymentRepayment"> | string
    paidAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"PaymentRepayment"> | number | null
    createdAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    schedule?: XOR<PaymentScheduleScalarRelationFilter, PaymentScheduleWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PaymentRepaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentRepaymentCountOrderByAggregateInput
    _avg?: PaymentRepaymentAvgOrderByAggregateInput
    _max?: PaymentRepaymentMaxOrderByAggregateInput
    _min?: PaymentRepaymentMinOrderByAggregateInput
    _sum?: PaymentRepaymentSumOrderByAggregateInput
  }

  export type PaymentRepaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentRepaymentScalarWhereWithAggregatesInput | PaymentRepaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentRepaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentRepaymentScalarWhereWithAggregatesInput | PaymentRepaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentRepayment"> | number
    transactionId?: IntWithAggregatesFilter<"PaymentRepayment"> | number
    scheduleId?: IntWithAggregatesFilter<"PaymentRepayment"> | number
    amount?: FloatWithAggregatesFilter<"PaymentRepayment"> | number
    channel?: StringWithAggregatesFilter<"PaymentRepayment"> | string
    paidAt?: DateTimeWithAggregatesFilter<"PaymentRepayment"> | Date | string
    paidByUserId?: IntNullableWithAggregatesFilter<"PaymentRepayment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentRepayment"> | Date | string
  }

  export type DailyRepaymentWhereInput = {
    AND?: DailyRepaymentWhereInput | DailyRepaymentWhereInput[]
    OR?: DailyRepaymentWhereInput[]
    NOT?: DailyRepaymentWhereInput | DailyRepaymentWhereInput[]
    id?: IntFilter<"DailyRepayment"> | number
    transactionId?: IntFilter<"DailyRepayment"> | number
    amount?: FloatFilter<"DailyRepayment"> | number
    channel?: StringFilter<"DailyRepayment"> | string
    paidAt?: DateTimeFilter<"DailyRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"DailyRepayment"> | number | null
    branchId?: IntNullableFilter<"DailyRepayment"> | number | null
    createdAt?: DateTimeFilter<"DailyRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type DailyRepaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    paidBy?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DailyRepaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyRepaymentWhereInput | DailyRepaymentWhereInput[]
    OR?: DailyRepaymentWhereInput[]
    NOT?: DailyRepaymentWhereInput | DailyRepaymentWhereInput[]
    transactionId?: IntFilter<"DailyRepayment"> | number
    amount?: FloatFilter<"DailyRepayment"> | number
    channel?: StringFilter<"DailyRepayment"> | string
    paidAt?: DateTimeFilter<"DailyRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"DailyRepayment"> | number | null
    branchId?: IntNullableFilter<"DailyRepayment"> | number | null
    createdAt?: DateTimeFilter<"DailyRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type DailyRepaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DailyRepaymentCountOrderByAggregateInput
    _avg?: DailyRepaymentAvgOrderByAggregateInput
    _max?: DailyRepaymentMaxOrderByAggregateInput
    _min?: DailyRepaymentMinOrderByAggregateInput
    _sum?: DailyRepaymentSumOrderByAggregateInput
  }

  export type DailyRepaymentScalarWhereWithAggregatesInput = {
    AND?: DailyRepaymentScalarWhereWithAggregatesInput | DailyRepaymentScalarWhereWithAggregatesInput[]
    OR?: DailyRepaymentScalarWhereWithAggregatesInput[]
    NOT?: DailyRepaymentScalarWhereWithAggregatesInput | DailyRepaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyRepayment"> | number
    transactionId?: IntWithAggregatesFilter<"DailyRepayment"> | number
    amount?: FloatWithAggregatesFilter<"DailyRepayment"> | number
    channel?: StringWithAggregatesFilter<"DailyRepayment"> | string
    paidAt?: DateTimeWithAggregatesFilter<"DailyRepayment"> | Date | string
    paidByUserId?: IntNullableWithAggregatesFilter<"DailyRepayment"> | number | null
    branchId?: IntNullableWithAggregatesFilter<"DailyRepayment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyRepayment"> | Date | string
  }

  export type CreditRepaymentWhereInput = {
    AND?: CreditRepaymentWhereInput | CreditRepaymentWhereInput[]
    OR?: CreditRepaymentWhereInput[]
    NOT?: CreditRepaymentWhereInput | CreditRepaymentWhereInput[]
    id?: IntFilter<"CreditRepayment"> | number
    transactionId?: IntFilter<"CreditRepayment"> | number
    scheduleId?: IntNullableFilter<"CreditRepayment"> | number | null
    amount?: FloatFilter<"CreditRepayment"> | number
    channel?: StringFilter<"CreditRepayment"> | string
    month?: StringNullableFilter<"CreditRepayment"> | string | null
    monthNumber?: IntNullableFilter<"CreditRepayment"> | number | null
    paidAt?: DateTimeFilter<"CreditRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"CreditRepayment"> | number | null
    branchId?: IntNullableFilter<"CreditRepayment"> | number | null
    createdAt?: DateTimeFilter<"CreditRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    schedule?: XOR<PaymentScheduleNullableScalarRelationFilter, PaymentScheduleWhereInput> | null
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type CreditRepaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    amount?: SortOrder
    channel?: SortOrder
    month?: SortOrderInput | SortOrder
    monthNumber?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    schedule?: PaymentScheduleOrderByWithRelationInput
    paidBy?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type CreditRepaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreditRepaymentWhereInput | CreditRepaymentWhereInput[]
    OR?: CreditRepaymentWhereInput[]
    NOT?: CreditRepaymentWhereInput | CreditRepaymentWhereInput[]
    transactionId?: IntFilter<"CreditRepayment"> | number
    scheduleId?: IntNullableFilter<"CreditRepayment"> | number | null
    amount?: FloatFilter<"CreditRepayment"> | number
    channel?: StringFilter<"CreditRepayment"> | string
    month?: StringNullableFilter<"CreditRepayment"> | string | null
    monthNumber?: IntNullableFilter<"CreditRepayment"> | number | null
    paidAt?: DateTimeFilter<"CreditRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"CreditRepayment"> | number | null
    branchId?: IntNullableFilter<"CreditRepayment"> | number | null
    createdAt?: DateTimeFilter<"CreditRepayment"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    schedule?: XOR<PaymentScheduleNullableScalarRelationFilter, PaymentScheduleWhereInput> | null
    paidBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type CreditRepaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    amount?: SortOrder
    channel?: SortOrder
    month?: SortOrderInput | SortOrder
    monthNumber?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CreditRepaymentCountOrderByAggregateInput
    _avg?: CreditRepaymentAvgOrderByAggregateInput
    _max?: CreditRepaymentMaxOrderByAggregateInput
    _min?: CreditRepaymentMinOrderByAggregateInput
    _sum?: CreditRepaymentSumOrderByAggregateInput
  }

  export type CreditRepaymentScalarWhereWithAggregatesInput = {
    AND?: CreditRepaymentScalarWhereWithAggregatesInput | CreditRepaymentScalarWhereWithAggregatesInput[]
    OR?: CreditRepaymentScalarWhereWithAggregatesInput[]
    NOT?: CreditRepaymentScalarWhereWithAggregatesInput | CreditRepaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreditRepayment"> | number
    transactionId?: IntWithAggregatesFilter<"CreditRepayment"> | number
    scheduleId?: IntNullableWithAggregatesFilter<"CreditRepayment"> | number | null
    amount?: FloatWithAggregatesFilter<"CreditRepayment"> | number
    channel?: StringWithAggregatesFilter<"CreditRepayment"> | string
    month?: StringNullableWithAggregatesFilter<"CreditRepayment"> | string | null
    monthNumber?: IntNullableWithAggregatesFilter<"CreditRepayment"> | number | null
    paidAt?: DateTimeWithAggregatesFilter<"CreditRepayment"> | Date | string
    paidByUserId?: IntNullableWithAggregatesFilter<"CreditRepayment"> | number | null
    branchId?: IntNullableWithAggregatesFilter<"CreditRepayment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CreditRepayment"> | Date | string
  }

  export type CashierReportWhereInput = {
    AND?: CashierReportWhereInput | CashierReportWhereInput[]
    OR?: CashierReportWhereInput[]
    NOT?: CashierReportWhereInput | CashierReportWhereInput[]
    id?: IntFilter<"CashierReport"> | number
    cashierId?: IntFilter<"CashierReport"> | number
    branchId?: IntFilter<"CashierReport"> | number
    reportDate?: DateTimeFilter<"CashierReport"> | Date | string
    cashTotal?: FloatFilter<"CashierReport"> | number
    cardTotal?: FloatFilter<"CashierReport"> | number
    creditTotal?: FloatFilter<"CashierReport"> | number
    installmentTotal?: FloatFilter<"CashierReport"> | number
    upfrontTotal?: FloatFilter<"CashierReport"> | number
    upfrontCash?: FloatFilter<"CashierReport"> | number
    upfrontCard?: FloatFilter<"CashierReport"> | number
    soldQuantity?: IntFilter<"CashierReport"> | number
    soldAmount?: FloatFilter<"CashierReport"> | number
    repaymentTotal?: FloatFilter<"CashierReport"> | number
    defectivePlus?: FloatFilter<"CashierReport"> | number
    defectiveMinus?: FloatFilter<"CashierReport"> | number
    createdAt?: DateTimeFilter<"CashierReport"> | Date | string
    updatedAt?: DateTimeFilter<"CashierReport"> | Date | string
    cashier?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type CashierReportOrderByWithRelationInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    reportDate?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cashier?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type CashierReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cashierId_branchId_reportDate?: CashierReportCashierIdBranchIdReportDateCompoundUniqueInput
    AND?: CashierReportWhereInput | CashierReportWhereInput[]
    OR?: CashierReportWhereInput[]
    NOT?: CashierReportWhereInput | CashierReportWhereInput[]
    cashierId?: IntFilter<"CashierReport"> | number
    branchId?: IntFilter<"CashierReport"> | number
    reportDate?: DateTimeFilter<"CashierReport"> | Date | string
    cashTotal?: FloatFilter<"CashierReport"> | number
    cardTotal?: FloatFilter<"CashierReport"> | number
    creditTotal?: FloatFilter<"CashierReport"> | number
    installmentTotal?: FloatFilter<"CashierReport"> | number
    upfrontTotal?: FloatFilter<"CashierReport"> | number
    upfrontCash?: FloatFilter<"CashierReport"> | number
    upfrontCard?: FloatFilter<"CashierReport"> | number
    soldQuantity?: IntFilter<"CashierReport"> | number
    soldAmount?: FloatFilter<"CashierReport"> | number
    repaymentTotal?: FloatFilter<"CashierReport"> | number
    defectivePlus?: FloatFilter<"CashierReport"> | number
    defectiveMinus?: FloatFilter<"CashierReport"> | number
    createdAt?: DateTimeFilter<"CashierReport"> | Date | string
    updatedAt?: DateTimeFilter<"CashierReport"> | Date | string
    cashier?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id" | "cashierId_branchId_reportDate">

  export type CashierReportOrderByWithAggregationInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    reportDate?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashierReportCountOrderByAggregateInput
    _avg?: CashierReportAvgOrderByAggregateInput
    _max?: CashierReportMaxOrderByAggregateInput
    _min?: CashierReportMinOrderByAggregateInput
    _sum?: CashierReportSumOrderByAggregateInput
  }

  export type CashierReportScalarWhereWithAggregatesInput = {
    AND?: CashierReportScalarWhereWithAggregatesInput | CashierReportScalarWhereWithAggregatesInput[]
    OR?: CashierReportScalarWhereWithAggregatesInput[]
    NOT?: CashierReportScalarWhereWithAggregatesInput | CashierReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CashierReport"> | number
    cashierId?: IntWithAggregatesFilter<"CashierReport"> | number
    branchId?: IntWithAggregatesFilter<"CashierReport"> | number
    reportDate?: DateTimeWithAggregatesFilter<"CashierReport"> | Date | string
    cashTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    cardTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    creditTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    installmentTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    upfrontTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    upfrontCash?: FloatWithAggregatesFilter<"CashierReport"> | number
    upfrontCard?: FloatWithAggregatesFilter<"CashierReport"> | number
    soldQuantity?: IntWithAggregatesFilter<"CashierReport"> | number
    soldAmount?: FloatWithAggregatesFilter<"CashierReport"> | number
    repaymentTotal?: FloatWithAggregatesFilter<"CashierReport"> | number
    defectivePlus?: FloatWithAggregatesFilter<"CashierReport"> | number
    defectiveMinus?: FloatWithAggregatesFilter<"CashierReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CashierReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashierReport"> | Date | string
  }

  export type CurrencyExchangeRateWhereInput = {
    AND?: CurrencyExchangeRateWhereInput | CurrencyExchangeRateWhereInput[]
    OR?: CurrencyExchangeRateWhereInput[]
    NOT?: CurrencyExchangeRateWhereInput | CurrencyExchangeRateWhereInput[]
    id?: IntFilter<"CurrencyExchangeRate"> | number
    fromCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    toCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    rate?: FloatFilter<"CurrencyExchangeRate"> | number
    isActive?: BoolFilter<"CurrencyExchangeRate"> | boolean
    branchId?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdBy?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
    updatedAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CurrencyExchangeRateOrderByWithRelationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CurrencyExchangeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fromCurrency_toCurrency_branchId?: CurrencyExchangeRateFromCurrencyToCurrencyBranchIdCompoundUniqueInput
    AND?: CurrencyExchangeRateWhereInput | CurrencyExchangeRateWhereInput[]
    OR?: CurrencyExchangeRateWhereInput[]
    NOT?: CurrencyExchangeRateWhereInput | CurrencyExchangeRateWhereInput[]
    fromCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    toCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    rate?: FloatFilter<"CurrencyExchangeRate"> | number
    isActive?: BoolFilter<"CurrencyExchangeRate"> | boolean
    branchId?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdBy?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
    updatedAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "fromCurrency_toCurrency_branchId">

  export type CurrencyExchangeRateOrderByWithAggregationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyExchangeRateCountOrderByAggregateInput
    _avg?: CurrencyExchangeRateAvgOrderByAggregateInput
    _max?: CurrencyExchangeRateMaxOrderByAggregateInput
    _min?: CurrencyExchangeRateMinOrderByAggregateInput
    _sum?: CurrencyExchangeRateSumOrderByAggregateInput
  }

  export type CurrencyExchangeRateScalarWhereWithAggregatesInput = {
    AND?: CurrencyExchangeRateScalarWhereWithAggregatesInput | CurrencyExchangeRateScalarWhereWithAggregatesInput[]
    OR?: CurrencyExchangeRateScalarWhereWithAggregatesInput[]
    NOT?: CurrencyExchangeRateScalarWhereWithAggregatesInput | CurrencyExchangeRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CurrencyExchangeRate"> | number
    fromCurrency?: StringWithAggregatesFilter<"CurrencyExchangeRate"> | string
    toCurrency?: StringWithAggregatesFilter<"CurrencyExchangeRate"> | string
    rate?: FloatWithAggregatesFilter<"CurrencyExchangeRate"> | number
    isActive?: BoolWithAggregatesFilter<"CurrencyExchangeRate"> | boolean
    branchId?: IntNullableWithAggregatesFilter<"CurrencyExchangeRate"> | number | null
    createdBy?: IntNullableWithAggregatesFilter<"CurrencyExchangeRate"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CurrencyExchangeRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CurrencyExchangeRate"> | Date | string
  }

  export type BonusWhereInput = {
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    id?: IntFilter<"Bonus"> | number
    userId?: IntFilter<"Bonus"> | number
    amount?: FloatFilter<"Bonus"> | number
    reason?: StringFilter<"Bonus"> | string
    description?: StringNullableFilter<"Bonus"> | string | null
    bonusProducts?: JsonNullableFilter<"Bonus">
    bonusDate?: DateTimeFilter<"Bonus"> | Date | string
    createdById?: IntFilter<"Bonus"> | number
    branchId?: IntNullableFilter<"Bonus"> | number | null
    transactionId?: IntNullableFilter<"Bonus"> | number | null
    createdAt?: DateTimeFilter<"Bonus"> | Date | string
    updatedAt?: DateTimeFilter<"Bonus"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type BonusOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    bonusProducts?: SortOrderInput | SortOrder
    bonusDate?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type BonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    userId?: IntFilter<"Bonus"> | number
    amount?: FloatFilter<"Bonus"> | number
    reason?: StringFilter<"Bonus"> | string
    description?: StringNullableFilter<"Bonus"> | string | null
    bonusProducts?: JsonNullableFilter<"Bonus">
    bonusDate?: DateTimeFilter<"Bonus"> | Date | string
    createdById?: IntFilter<"Bonus"> | number
    branchId?: IntNullableFilter<"Bonus"> | number | null
    transactionId?: IntNullableFilter<"Bonus"> | number | null
    createdAt?: DateTimeFilter<"Bonus"> | Date | string
    updatedAt?: DateTimeFilter<"Bonus"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type BonusOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    bonusProducts?: SortOrderInput | SortOrder
    bonusDate?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BonusCountOrderByAggregateInput
    _avg?: BonusAvgOrderByAggregateInput
    _max?: BonusMaxOrderByAggregateInput
    _min?: BonusMinOrderByAggregateInput
    _sum?: BonusSumOrderByAggregateInput
  }

  export type BonusScalarWhereWithAggregatesInput = {
    AND?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    OR?: BonusScalarWhereWithAggregatesInput[]
    NOT?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bonus"> | number
    userId?: IntWithAggregatesFilter<"Bonus"> | number
    amount?: FloatWithAggregatesFilter<"Bonus"> | number
    reason?: StringWithAggregatesFilter<"Bonus"> | string
    description?: StringNullableWithAggregatesFilter<"Bonus"> | string | null
    bonusProducts?: JsonNullableWithAggregatesFilter<"Bonus">
    bonusDate?: DateTimeWithAggregatesFilter<"Bonus"> | Date | string
    createdById?: IntWithAggregatesFilter<"Bonus"> | number
    branchId?: IntNullableWithAggregatesFilter<"Bonus"> | number | null
    transactionId?: IntNullableWithAggregatesFilter<"Bonus"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Bonus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bonus"> | Date | string
  }

  export type TransactionBonusProductWhereInput = {
    AND?: TransactionBonusProductWhereInput | TransactionBonusProductWhereInput[]
    OR?: TransactionBonusProductWhereInput[]
    NOT?: TransactionBonusProductWhereInput | TransactionBonusProductWhereInput[]
    id?: IntFilter<"TransactionBonusProduct"> | number
    transactionId?: IntFilter<"TransactionBonusProduct"> | number
    productId?: IntFilter<"TransactionBonusProduct"> | number
    quantity?: IntFilter<"TransactionBonusProduct"> | number
    createdAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type TransactionBonusProductOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransactionBonusProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionBonusProductWhereInput | TransactionBonusProductWhereInput[]
    OR?: TransactionBonusProductWhereInput[]
    NOT?: TransactionBonusProductWhereInput | TransactionBonusProductWhereInput[]
    transactionId?: IntFilter<"TransactionBonusProduct"> | number
    productId?: IntFilter<"TransactionBonusProduct"> | number
    quantity?: IntFilter<"TransactionBonusProduct"> | number
    createdAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type TransactionBonusProductOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionBonusProductCountOrderByAggregateInput
    _avg?: TransactionBonusProductAvgOrderByAggregateInput
    _max?: TransactionBonusProductMaxOrderByAggregateInput
    _min?: TransactionBonusProductMinOrderByAggregateInput
    _sum?: TransactionBonusProductSumOrderByAggregateInput
  }

  export type TransactionBonusProductScalarWhereWithAggregatesInput = {
    AND?: TransactionBonusProductScalarWhereWithAggregatesInput | TransactionBonusProductScalarWhereWithAggregatesInput[]
    OR?: TransactionBonusProductScalarWhereWithAggregatesInput[]
    NOT?: TransactionBonusProductScalarWhereWithAggregatesInput | TransactionBonusProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionBonusProduct"> | number
    transactionId?: IntWithAggregatesFilter<"TransactionBonusProduct"> | number
    productId?: IntWithAggregatesFilter<"TransactionBonusProduct"> | number
    quantity?: IntWithAggregatesFilter<"TransactionBonusProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransactionBonusProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionBonusProduct"> | Date | string
  }

  export type WorkScheduleWhereInput = {
    AND?: WorkScheduleWhereInput | WorkScheduleWhereInput[]
    OR?: WorkScheduleWhereInput[]
    NOT?: WorkScheduleWhereInput | WorkScheduleWhereInput[]
    id?: IntFilter<"WorkSchedule"> | number
    workStartTime?: StringFilter<"WorkSchedule"> | string
    workEndTime?: StringFilter<"WorkSchedule"> | string
    isDefault?: BoolFilter<"WorkSchedule"> | boolean
    description?: StringNullableFilter<"WorkSchedule"> | string | null
    createdAt?: DateTimeFilter<"WorkSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkSchedule"> | Date | string
  }

  export type WorkScheduleOrderByWithRelationInput = {
    id?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    isDefault?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkScheduleWhereInput | WorkScheduleWhereInput[]
    OR?: WorkScheduleWhereInput[]
    NOT?: WorkScheduleWhereInput | WorkScheduleWhereInput[]
    workStartTime?: StringFilter<"WorkSchedule"> | string
    workEndTime?: StringFilter<"WorkSchedule"> | string
    isDefault?: BoolFilter<"WorkSchedule"> | boolean
    description?: StringNullableFilter<"WorkSchedule"> | string | null
    createdAt?: DateTimeFilter<"WorkSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkSchedule"> | Date | string
  }, "id">

  export type WorkScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    isDefault?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkScheduleCountOrderByAggregateInput
    _avg?: WorkScheduleAvgOrderByAggregateInput
    _max?: WorkScheduleMaxOrderByAggregateInput
    _min?: WorkScheduleMinOrderByAggregateInput
    _sum?: WorkScheduleSumOrderByAggregateInput
  }

  export type WorkScheduleScalarWhereWithAggregatesInput = {
    AND?: WorkScheduleScalarWhereWithAggregatesInput | WorkScheduleScalarWhereWithAggregatesInput[]
    OR?: WorkScheduleScalarWhereWithAggregatesInput[]
    NOT?: WorkScheduleScalarWhereWithAggregatesInput | WorkScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkSchedule"> | number
    workStartTime?: StringWithAggregatesFilter<"WorkSchedule"> | string
    workEndTime?: StringWithAggregatesFilter<"WorkSchedule"> | string
    isDefault?: BoolWithAggregatesFilter<"WorkSchedule"> | boolean
    description?: StringNullableWithAggregatesFilter<"WorkSchedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkSchedule"> | Date | string
  }

  export type barcodeCounterWhereInput = {
    AND?: barcodeCounterWhereInput | barcodeCounterWhereInput[]
    OR?: barcodeCounterWhereInput[]
    NOT?: barcodeCounterWhereInput | barcodeCounterWhereInput[]
    id?: IntFilter<"barcodeCounter"> | number
    counter?: BigIntFilter<"barcodeCounter"> | bigint | number
    createdAt?: DateTimeFilter<"barcodeCounter"> | Date | string
    updatedAt?: DateTimeFilter<"barcodeCounter"> | Date | string
  }

  export type barcodeCounterOrderByWithRelationInput = {
    id?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barcodeCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: barcodeCounterWhereInput | barcodeCounterWhereInput[]
    OR?: barcodeCounterWhereInput[]
    NOT?: barcodeCounterWhereInput | barcodeCounterWhereInput[]
    counter?: BigIntFilter<"barcodeCounter"> | bigint | number
    createdAt?: DateTimeFilter<"barcodeCounter"> | Date | string
    updatedAt?: DateTimeFilter<"barcodeCounter"> | Date | string
  }, "id">

  export type barcodeCounterOrderByWithAggregationInput = {
    id?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: barcodeCounterCountOrderByAggregateInput
    _avg?: barcodeCounterAvgOrderByAggregateInput
    _max?: barcodeCounterMaxOrderByAggregateInput
    _min?: barcodeCounterMinOrderByAggregateInput
    _sum?: barcodeCounterSumOrderByAggregateInput
  }

  export type barcodeCounterScalarWhereWithAggregatesInput = {
    AND?: barcodeCounterScalarWhereWithAggregatesInput | barcodeCounterScalarWhereWithAggregatesInput[]
    OR?: barcodeCounterScalarWhereWithAggregatesInput[]
    NOT?: barcodeCounterScalarWhereWithAggregatesInput | barcodeCounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"barcodeCounter"> | number
    counter?: BigIntWithAggregatesFilter<"barcodeCounter"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"barcodeCounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"barcodeCounter"> | Date | string
  }

  export type FaceTemplateWhereInput = {
    AND?: FaceTemplateWhereInput | FaceTemplateWhereInput[]
    OR?: FaceTemplateWhereInput[]
    NOT?: FaceTemplateWhereInput | FaceTemplateWhereInput[]
    id?: IntFilter<"FaceTemplate"> | number
    userId?: IntFilter<"FaceTemplate"> | number
    deviceId?: StringNullableFilter<"FaceTemplate"> | string | null
    template?: StringNullableFilter<"FaceTemplate"> | string | null
    vector?: JsonNullableFilter<"FaceTemplate">
    imageUrl?: StringNullableFilter<"FaceTemplate"> | string | null
    createdAt?: DateTimeFilter<"FaceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FaceTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FaceTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    vector?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FaceTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FaceTemplateWhereInput | FaceTemplateWhereInput[]
    OR?: FaceTemplateWhereInput[]
    NOT?: FaceTemplateWhereInput | FaceTemplateWhereInput[]
    userId?: IntFilter<"FaceTemplate"> | number
    deviceId?: StringNullableFilter<"FaceTemplate"> | string | null
    template?: StringNullableFilter<"FaceTemplate"> | string | null
    vector?: JsonNullableFilter<"FaceTemplate">
    imageUrl?: StringNullableFilter<"FaceTemplate"> | string | null
    createdAt?: DateTimeFilter<"FaceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FaceTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FaceTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    vector?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FaceTemplateCountOrderByAggregateInput
    _avg?: FaceTemplateAvgOrderByAggregateInput
    _max?: FaceTemplateMaxOrderByAggregateInput
    _min?: FaceTemplateMinOrderByAggregateInput
    _sum?: FaceTemplateSumOrderByAggregateInput
  }

  export type FaceTemplateScalarWhereWithAggregatesInput = {
    AND?: FaceTemplateScalarWhereWithAggregatesInput | FaceTemplateScalarWhereWithAggregatesInput[]
    OR?: FaceTemplateScalarWhereWithAggregatesInput[]
    NOT?: FaceTemplateScalarWhereWithAggregatesInput | FaceTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FaceTemplate"> | number
    userId?: IntWithAggregatesFilter<"FaceTemplate"> | number
    deviceId?: StringNullableWithAggregatesFilter<"FaceTemplate"> | string | null
    template?: StringNullableWithAggregatesFilter<"FaceTemplate"> | string | null
    vector?: JsonNullableWithAggregatesFilter<"FaceTemplate">
    imageUrl?: StringNullableWithAggregatesFilter<"FaceTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FaceTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FaceTemplate"> | Date | string
  }

  export type AttendanceDayCreateInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceDaysInput
    branch?: BranchCreateNestedOneWithoutAttendanceDaysInput
    events?: AttendanceEventCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayUncheckedCreateInput = {
    id?: number
    userId: number
    branchId?: number | null
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: AttendanceEventUncheckedCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceDaysNestedInput
    branch?: BranchUpdateOneWithoutAttendanceDaysNestedInput
    events?: AttendanceEventUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: AttendanceEventUncheckedUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayCreateManyInput = {
    id?: number
    userId: number
    branchId?: number | null
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceDayUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventCreateInput = {
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceEventsInput
    branch?: BranchCreateNestedOneWithoutAttendanceEventsInput
    day?: AttendanceDayCreateNestedOneWithoutEventsInput
  }

  export type AttendanceEventUncheckedCreateInput = {
    id?: number
    userId: number
    branchId?: number | null
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventUpdateInput = {
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceEventsNestedInput
    branch?: BranchUpdateOneWithoutAttendanceEventsNestedInput
    day?: AttendanceDayUpdateOneWithoutEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventCreateManyInput = {
    id?: number
    userId: number
    branchId?: number | null
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventUpdateManyMutationInput = {
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
  }

  export type UserCreateInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBranchAccessCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllowedBranchesInput
    branch: BranchCreateNestedOneWithoutAllowedUsersInput
  }

  export type UserBranchAccessUncheckedCreateInput = {
    id?: number
    userId: number
    branchId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBranchAccessUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllowedBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutAllowedUsersNestedInput
  }

  export type UserBranchAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBranchAccessCreateManyInput = {
    id?: number
    userId: number
    branchId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBranchAccessUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBranchAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationCreateInput = {
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserLocationsInput
  }

  export type UserLocationUncheckedCreateInput = {
    userId: number
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
  }

  export type UserLocationUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLocationsNestedInput
  }

  export type UserLocationUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationCreateManyInput = {
    userId: number
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
  }

  export type UserLocationUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    category: CategoryCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogCreateInput = {
    quantity: number
    description: string
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
    product: ProductCreateNestedOneWithoutDefectiveLogInput
    user?: UserCreateNestedOneWithoutDefectiveLogsInput
    branch?: BranchCreateNestedOneWithoutDefectiveLogsInput
  }

  export type DefectiveLogUncheckedCreateInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    userId?: number | null
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type DefectiveLogUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutDefectiveLogNestedInput
    user?: UserUpdateOneWithoutDefectiveLogsNestedInput
    branch?: BranchUpdateOneWithoutDefectiveLogsNestedInput
  }

  export type DefectiveLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogCreateManyInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    userId?: number | null
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type DefectiveLogUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerCreateInput = {
    fullName: string
    phone: string
    email?: string | null
    address?: string | null
    passportSeries?: string | null
    jshshir?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    fullName: string
    phone: string
    email?: string | null
    address?: string | null
    passportSeries?: string | null
    jshshir?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    fullName: string
    phone: string
    email?: string | null
    address?: string | null
    passportSeries?: string | null
    jshshir?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemCreateInput = {
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionItemUncheckedCreateInput = {
    id?: number
    transactionId: number
    productId?: number | null
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemCreateManyInput = {
    id?: number
    transactionId: number
    productId?: number | null
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferCreateInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductTransferInput
    fromBranch: BranchCreateNestedOneWithoutFromTransfersInput
    toBranch: BranchCreateNestedOneWithoutToTransfersInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
  }

  export type ProductTransferUncheckedCreateInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductTransferNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutFromTransfersNestedInput
    toBranch?: BranchUpdateOneRequiredWithoutToTransfersNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferCreateManyInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentScheduleCreateInput = {
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    transaction: TransactionCreateNestedOneWithoutPaymentSchedulesInput
    paidBy?: UserCreateNestedOneWithoutPaymentScheduleInput
    repayments?: PaymentRepaymentCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUncheckedCreateInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    repayments?: PaymentRepaymentUncheckedCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUpdateInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: TransactionUpdateOneRequiredWithoutPaymentSchedulesNestedInput
    paidBy?: UserUpdateOneWithoutPaymentScheduleNestedInput
    repayments?: PaymentRepaymentUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    repayments?: PaymentRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleCreateManyInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
  }

  export type PaymentScheduleUpdateManyMutationInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentRepaymentCreateInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutPaymentRepaymentInput
    schedule: PaymentScheduleCreateNestedOneWithoutRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutPaymentRepaymentInput
  }

  export type PaymentRepaymentUncheckedCreateInput = {
    id?: number
    transactionId: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type PaymentRepaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutPaymentRepaymentNestedInput
    schedule?: PaymentScheduleUpdateOneRequiredWithoutRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutPaymentRepaymentNestedInput
  }

  export type PaymentRepaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentCreateManyInput = {
    id?: number
    transactionId: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type PaymentRepaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentCreateInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutDailyRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutDailyRepaymentsInput
    branch?: BranchCreateNestedOneWithoutDailyRepaymentInput
  }

  export type DailyRepaymentUncheckedCreateInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDailyRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutDailyRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutDailyRepaymentNestedInput
  }

  export type DailyRepaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentCreateManyInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentCreateInput = {
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutCreditRepaymentsInput
    schedule?: PaymentScheduleCreateNestedOneWithoutCreditRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutCreditRepaymentsInput
    branch?: BranchCreateNestedOneWithoutCreditRepaymentInput
  }

  export type CreditRepaymentUncheckedCreateInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutCreditRepaymentsNestedInput
    schedule?: PaymentScheduleUpdateOneWithoutCreditRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutCreditRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutCreditRepaymentNestedInput
  }

  export type CreditRepaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentCreateManyInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportCreateInput = {
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutCashierReportsInput
    branch: BranchCreateNestedOneWithoutCashierReportsInput
  }

  export type CashierReportUncheckedCreateInput = {
    id?: number
    cashierId: number
    branchId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierReportUpdateInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutCashierReportsNestedInput
    branch?: BranchUpdateOneRequiredWithoutCashierReportsNestedInput
  }

  export type CashierReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportCreateManyInput = {
    id?: number
    cashierId: number
    branchId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierReportUpdateManyMutationInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateCreateInput = {
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutExchangeRatesInput
    user?: UserCreateNestedOneWithoutExchangeRatesInput
  }

  export type CurrencyExchangeRateUncheckedCreateInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    branchId?: number | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyExchangeRateUpdateInput = {
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutExchangeRatesNestedInput
    user?: UserUpdateOneWithoutExchangeRatesNestedInput
  }

  export type CurrencyExchangeRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateCreateManyInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    branchId?: number | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyExchangeRateUpdateManyMutationInput = {
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusCreateInput = {
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
    createdBy: UserCreateNestedOneWithoutCreatedBonusesInput
    branch?: BranchCreateNestedOneWithoutBonusesInput
    transaction?: TransactionCreateNestedOneWithoutBonusesInput
  }

  export type BonusUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBonusesNestedInput
    branch?: BranchUpdateOneWithoutBonusesNestedInput
    transaction?: TransactionUpdateOneWithoutBonusesNestedInput
  }

  export type BonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusCreateManyInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductCreateInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutBonusProductsInput
    product: ProductCreateNestedOneWithoutBonusProductsInput
  }

  export type TransactionBonusProductUncheckedCreateInput = {
    id?: number
    transactionId: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionBonusProductUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutBonusProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutBonusProductsNestedInput
  }

  export type TransactionBonusProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductCreateManyInput = {
    id?: number
    transactionId: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionBonusProductUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkScheduleCreateInput = {
    workStartTime: string
    workEndTime: string
    isDefault?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkScheduleUncheckedCreateInput = {
    id?: number
    workStartTime: string
    workEndTime: string
    isDefault?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkScheduleUpdateInput = {
    workStartTime?: StringFieldUpdateOperationsInput | string
    workEndTime?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workStartTime?: StringFieldUpdateOperationsInput | string
    workEndTime?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkScheduleCreateManyInput = {
    id?: number
    workStartTime: string
    workEndTime: string
    isDefault?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkScheduleUpdateManyMutationInput = {
    workStartTime?: StringFieldUpdateOperationsInput | string
    workEndTime?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workStartTime?: StringFieldUpdateOperationsInput | string
    workEndTime?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeCounterCreateInput = {
    counter?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type barcodeCounterUncheckedCreateInput = {
    id?: number
    counter?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type barcodeCounterUpdateInput = {
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeCounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeCounterCreateManyInput = {
    id?: number
    counter?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type barcodeCounterUpdateManyMutationInput = {
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeCounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateCreateInput = {
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFaceTemplatesInput
  }

  export type FaceTemplateUncheckedCreateInput = {
    id?: number
    userId: number
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaceTemplateUpdateInput = {
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFaceTemplatesNestedInput
  }

  export type FaceTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateCreateManyInput = {
    id?: number
    userId: number
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaceTemplateUpdateManyMutationInput = {
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumAttendanceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel> | $Enums.AttendanceStatus | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type AttendanceEventListRelationFilter = {
    every?: AttendanceEventWhereInput
    some?: AttendanceEventWhereInput
    none?: AttendanceEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AttendanceEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceDayUserIdDateCompoundUniqueInput = {
    userId: number
    date: Date | string
  }

  export type AttendanceDayCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceDayAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    totalMinutes?: SortOrder
  }

  export type AttendanceDayMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceDayMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceDaySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    totalMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttendanceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceEventType | EnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceEventTypeFilter<$PrismaModel> | $Enums.AttendanceEventType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AttendanceDayNullableScalarRelationFilter = {
    is?: AttendanceDayWhereInput | null
    isNot?: AttendanceDayWhereInput | null
  }

  export type AttendanceEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    dayId?: SortOrder
    eventType?: SortOrder
    occurredAt?: SortOrder
    deviceId?: SortOrder
    similarity?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    dayId?: SortOrder
    similarity?: SortOrder
  }

  export type AttendanceEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    dayId?: SortOrder
    eventType?: SortOrder
    occurredAt?: SortOrder
    deviceId?: SortOrder
    similarity?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    dayId?: SortOrder
    eventType?: SortOrder
    occurredAt?: SortOrder
    deviceId?: SortOrder
    similarity?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    dayId?: SortOrder
    similarity?: SortOrder
  }

  export type EnumAttendanceEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceEventType | EnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceEventTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceEventTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumBranchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchStatus | EnumBranchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchStatusFilter<$PrismaModel> | $Enums.BranchStatus
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserBranchAccessListRelationFilter = {
    every?: UserBranchAccessWhereInput
    some?: UserBranchAccessWhereInput
    none?: UserBranchAccessWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductTransferListRelationFilter = {
    every?: ProductTransferWhereInput
    some?: ProductTransferWhereInput
    none?: ProductTransferWhereInput
  }

  export type DefectiveLogListRelationFilter = {
    every?: DefectiveLogWhereInput
    some?: DefectiveLogWhereInput
    none?: DefectiveLogWhereInput
  }

  export type CurrencyExchangeRateListRelationFilter = {
    every?: CurrencyExchangeRateWhereInput
    some?: CurrencyExchangeRateWhereInput
    none?: CurrencyExchangeRateWhereInput
  }

  export type CashierReportListRelationFilter = {
    every?: CashierReportWhereInput
    some?: CashierReportWhereInput
    none?: CashierReportWhereInput
  }

  export type DailyRepaymentListRelationFilter = {
    every?: DailyRepaymentWhereInput
    some?: DailyRepaymentWhereInput
    none?: DailyRepaymentWhereInput
  }

  export type CreditRepaymentListRelationFilter = {
    every?: CreditRepaymentWhereInput
    some?: CreditRepaymentWhereInput
    none?: CreditRepaymentWhereInput
  }

  export type BonusListRelationFilter = {
    every?: BonusWhereInput
    some?: BonusWhereInput
    none?: BonusWhereInput
  }

  export type AttendanceDayListRelationFilter = {
    every?: AttendanceDayWhereInput
    some?: AttendanceDayWhereInput
    none?: AttendanceDayWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBranchAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefectiveLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyExchangeRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashierReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRepaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditRepaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
    cashBalance?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
    cashBalance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumBranchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchStatus | EnumBranchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BranchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchStatusFilter<$PrismaModel>
    _max?: NestedEnumBranchStatusFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type UserLocationListRelationFilter = {
    every?: UserLocationWhereInput
    some?: UserLocationWhereInput
    none?: UserLocationWhereInput
  }

  export type PaymentScheduleListRelationFilter = {
    every?: PaymentScheduleWhereInput
    some?: PaymentScheduleWhereInput
    none?: PaymentScheduleWhereInput
  }

  export type PaymentRepaymentListRelationFilter = {
    every?: PaymentRepaymentWhereInput
    some?: PaymentRepaymentWhereInput
    none?: PaymentRepaymentWhereInput
  }

  export type FaceTemplateListRelationFilter = {
    every?: FaceTemplateWhereInput
    some?: FaceTemplateWhereInput
    none?: FaceTemplateWhereInput
  }

  export type UserLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentRepaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FaceTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    workShift?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    workShift?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    workShift?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type UserBranchAccessUserIdBranchIdCompoundUniqueInput = {
    userId: number
    branchId: number
  }

  export type UserBranchAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBranchAccessAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
  }

  export type UserBranchAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBranchAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBranchAccessSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserLocationCountOrderByAggregateInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLocationAvgOrderByAggregateInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type UserLocationMaxOrderByAggregateInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLocationMinOrderByAggregateInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLocationSumOrderByAggregateInput = {
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type EnumProductSizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductSizeType | EnumProductSizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductSizeTypeFilter<$PrismaModel> | $Enums.ProductSizeType
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type TransactionItemListRelationFilter = {
    every?: TransactionItemWhereInput
    some?: TransactionItemWhereInput
    none?: TransactionItemWhereInput
  }

  export type TransactionBonusProductListRelationFilter = {
    every?: TransactionBonusProductWhereInput
    some?: TransactionBonusProductWhereInput
    none?: TransactionBonusProductWhereInput
  }

  export type TransactionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionBonusProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductBarcode_branchIdCompoundUniqueInput = {
    barcode: string
    branchId: number
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    model?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrder
    bonusPercentage?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeType?: SortOrder
    sizeLabel?: SortOrder
    sizeNumber?: SortOrder
    areaSqm?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrder
    bonusPercentage?: SortOrder
    sizeNumber?: SortOrder
    areaSqm?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    model?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrder
    bonusPercentage?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeType?: SortOrder
    sizeLabel?: SortOrder
    sizeNumber?: SortOrder
    areaSqm?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    model?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrder
    bonusPercentage?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeType?: SortOrder
    sizeLabel?: SortOrder
    sizeNumber?: SortOrder
    areaSqm?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    defectiveQuantity?: SortOrder
    returnedQuantity?: SortOrder
    exchangedQuantity?: SortOrder
    initialQuantity?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    marketPrice?: SortOrder
    bonusPercentage?: SortOrder
    sizeNumber?: SortOrder
    areaSqm?: SortOrder
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type EnumProductSizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductSizeType | EnumProductSizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductSizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductSizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductSizeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductSizeTypeFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DefectiveLogCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    cashAmount?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    exchangeWithProductId?: SortOrder
    replacementQuantity?: SortOrder
    replacementUnitPrice?: SortOrder
    replacementTransactionId?: SortOrder
  }

  export type DefectiveLogAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    cashAmount?: SortOrder
    exchangeWithProductId?: SortOrder
    replacementQuantity?: SortOrder
    replacementUnitPrice?: SortOrder
    replacementTransactionId?: SortOrder
  }

  export type DefectiveLogMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    cashAmount?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    exchangeWithProductId?: SortOrder
    replacementQuantity?: SortOrder
    replacementUnitPrice?: SortOrder
    replacementTransactionId?: SortOrder
  }

  export type DefectiveLogMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    cashAmount?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    exchangeWithProductId?: SortOrder
    replacementQuantity?: SortOrder
    replacementUnitPrice?: SortOrder
    replacementTransactionId?: SortOrder
  }

  export type DefectiveLogSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    cashAmount?: SortOrder
    exchangeWithProductId?: SortOrder
    replacementQuantity?: SortOrder
    replacementUnitPrice?: SortOrder
    replacementTransactionId?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    passportSeries?: SortOrder
    jshshir?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    passportSeries?: SortOrder
    jshshir?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    passportSeries?: SortOrder
    jshshir?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type EnumPaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeNullableFilter<$PrismaModel> | $Enums.PaymentType | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    soldByUserId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    type?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    paymentType?: SortOrder
    upfrontPaymentType?: SortOrder
    termUnit?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    deliveryAddress?: SortOrder
    amountPaid?: SortOrder
    downPayment?: SortOrder
    remainingBalance?: SortOrder
    receiptId?: SortOrder
    description?: SortOrder
    updatedById?: SortOrder
    creditRepaymentAmount?: SortOrder
    lastRepaymentDate?: SortOrder
    extraProfit?: SortOrder
    days?: SortOrder
    months?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    soldByUserId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    amountPaid?: SortOrder
    downPayment?: SortOrder
    remainingBalance?: SortOrder
    updatedById?: SortOrder
    creditRepaymentAmount?: SortOrder
    extraProfit?: SortOrder
    days?: SortOrder
    months?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    soldByUserId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    type?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    paymentType?: SortOrder
    upfrontPaymentType?: SortOrder
    termUnit?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    deliveryAddress?: SortOrder
    amountPaid?: SortOrder
    downPayment?: SortOrder
    remainingBalance?: SortOrder
    receiptId?: SortOrder
    description?: SortOrder
    updatedById?: SortOrder
    creditRepaymentAmount?: SortOrder
    lastRepaymentDate?: SortOrder
    extraProfit?: SortOrder
    days?: SortOrder
    months?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    soldByUserId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    type?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    paymentType?: SortOrder
    upfrontPaymentType?: SortOrder
    termUnit?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    deliveryAddress?: SortOrder
    amountPaid?: SortOrder
    downPayment?: SortOrder
    remainingBalance?: SortOrder
    receiptId?: SortOrder
    description?: SortOrder
    updatedById?: SortOrder
    creditRepaymentAmount?: SortOrder
    lastRepaymentDate?: SortOrder
    extraProfit?: SortOrder
    days?: SortOrder
    months?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    soldByUserId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    finalTotal?: SortOrder
    amountPaid?: SortOrder
    downPayment?: SortOrder
    remainingBalance?: SortOrder
    updatedById?: SortOrder
    creditRepaymentAmount?: SortOrder
    extraProfit?: SortOrder
    days?: SortOrder
    months?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type TransactionItemCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrder
    originalPrice?: SortOrder
    total?: SortOrder
    creditMonth?: SortOrder
    creditPercent?: SortOrder
    monthlyPayment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrder
    originalPrice?: SortOrder
    total?: SortOrder
    creditMonth?: SortOrder
    creditPercent?: SortOrder
    monthlyPayment?: SortOrder
  }

  export type TransactionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrder
    originalPrice?: SortOrder
    total?: SortOrder
    creditMonth?: SortOrder
    creditPercent?: SortOrder
    monthlyPayment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionItemMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrder
    originalPrice?: SortOrder
    total?: SortOrder
    creditMonth?: SortOrder
    creditPercent?: SortOrder
    monthlyPayment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionItemSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sellingPrice?: SortOrder
    originalPrice?: SortOrder
    total?: SortOrder
    creditMonth?: SortOrder
    creditPercent?: SortOrder
    monthlyPayment?: SortOrder
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type ProductTransferCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductTransferAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ProductTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductTransferMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductTransferSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type PaymentScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    paidChannel?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    creditRepaymentAmount?: SortOrder
    repaymentDate?: SortOrder
    rating?: SortOrder
    dueDate?: SortOrder
    isDailyInstallment?: SortOrder
    daysCount?: SortOrder
    installmentType?: SortOrder
    totalDays?: SortOrder
    remainingDays?: SortOrder
    totalMonths?: SortOrder
    remainingMonths?: SortOrder
  }

  export type PaymentScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    paidAmount?: SortOrder
    paidByUserId?: SortOrder
    creditRepaymentAmount?: SortOrder
    daysCount?: SortOrder
    totalDays?: SortOrder
    remainingDays?: SortOrder
    totalMonths?: SortOrder
    remainingMonths?: SortOrder
  }

  export type PaymentScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    paidChannel?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    creditRepaymentAmount?: SortOrder
    repaymentDate?: SortOrder
    rating?: SortOrder
    dueDate?: SortOrder
    isDailyInstallment?: SortOrder
    daysCount?: SortOrder
    installmentType?: SortOrder
    totalDays?: SortOrder
    remainingDays?: SortOrder
    totalMonths?: SortOrder
    remainingMonths?: SortOrder
  }

  export type PaymentScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    paidChannel?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    creditRepaymentAmount?: SortOrder
    repaymentDate?: SortOrder
    rating?: SortOrder
    dueDate?: SortOrder
    isDailyInstallment?: SortOrder
    daysCount?: SortOrder
    installmentType?: SortOrder
    totalDays?: SortOrder
    remainingDays?: SortOrder
    totalMonths?: SortOrder
    remainingMonths?: SortOrder
  }

  export type PaymentScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    month?: SortOrder
    payment?: SortOrder
    remainingBalance?: SortOrder
    paidAmount?: SortOrder
    paidByUserId?: SortOrder
    creditRepaymentAmount?: SortOrder
    daysCount?: SortOrder
    totalDays?: SortOrder
    remainingDays?: SortOrder
    totalMonths?: SortOrder
    remainingMonths?: SortOrder
  }

  export type PaymentScheduleScalarRelationFilter = {
    is?: PaymentScheduleWhereInput
    isNot?: PaymentScheduleWhereInput
  }

  export type PaymentRepaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentRepaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    paidByUserId?: SortOrder
  }

  export type PaymentRepaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentRepaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentRepaymentSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    paidByUserId?: SortOrder
  }

  export type DailyRepaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRepaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
  }

  export type DailyRepaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRepaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRepaymentSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
  }

  export type PaymentScheduleNullableScalarRelationFilter = {
    is?: PaymentScheduleWhereInput | null
    isNot?: PaymentScheduleWhereInput | null
  }

  export type CreditRepaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    month?: SortOrder
    monthNumber?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditRepaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    monthNumber?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
  }

  export type CreditRepaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    month?: SortOrder
    monthNumber?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditRepaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    month?: SortOrder
    monthNumber?: SortOrder
    paidAt?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditRepaymentSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    scheduleId?: SortOrder
    amount?: SortOrder
    monthNumber?: SortOrder
    paidByUserId?: SortOrder
    branchId?: SortOrder
  }

  export type CashierReportCashierIdBranchIdReportDateCompoundUniqueInput = {
    cashierId: number
    branchId: number
    reportDate: Date | string
  }

  export type CashierReportCountOrderByAggregateInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    reportDate?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashierReportAvgOrderByAggregateInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
  }

  export type CashierReportMaxOrderByAggregateInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    reportDate?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashierReportMinOrderByAggregateInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    reportDate?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashierReportSumOrderByAggregateInput = {
    id?: SortOrder
    cashierId?: SortOrder
    branchId?: SortOrder
    cashTotal?: SortOrder
    cardTotal?: SortOrder
    creditTotal?: SortOrder
    installmentTotal?: SortOrder
    upfrontTotal?: SortOrder
    upfrontCash?: SortOrder
    upfrontCard?: SortOrder
    soldQuantity?: SortOrder
    soldAmount?: SortOrder
    repaymentTotal?: SortOrder
    defectivePlus?: SortOrder
    defectiveMinus?: SortOrder
  }

  export type CurrencyExchangeRateFromCurrencyToCurrencyBranchIdCompoundUniqueInput = {
    fromCurrency: string
    toCurrency: string
    branchId: number
  }

  export type CurrencyExchangeRateCountOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    branchId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyExchangeRateAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    branchId?: SortOrder
    createdBy?: SortOrder
  }

  export type CurrencyExchangeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    branchId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyExchangeRateMinOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    branchId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyExchangeRateSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    branchId?: SortOrder
    createdBy?: SortOrder
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type BonusCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    bonusProducts?: SortOrder
    bonusDate?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BonusAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrder
    transactionId?: SortOrder
  }

  export type BonusMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    bonusDate?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BonusMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    bonusDate?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BonusSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    branchId?: SortOrder
    transactionId?: SortOrder
  }

  export type TransactionBonusProductCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionBonusProductAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionBonusProductMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionBonusProductMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionBonusProductSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WorkScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    isDefault?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    isDefault?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    workStartTime?: SortOrder
    workEndTime?: SortOrder
    isDefault?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkScheduleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type barcodeCounterCountOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barcodeCounterAvgOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type barcodeCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barcodeCounterMinOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barcodeCounterSumOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FaceTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    template?: SortOrder
    vector?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaceTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FaceTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    template?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaceTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    template?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaceTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserCreateNestedOneWithoutAttendanceDaysInput = {
    create?: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceDaysInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAttendanceDaysInput = {
    create?: XOR<BranchCreateWithoutAttendanceDaysInput, BranchUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAttendanceDaysInput
    connect?: BranchWhereUniqueInput
  }

  export type AttendanceEventCreateNestedManyWithoutDayInput = {
    create?: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput> | AttendanceEventCreateWithoutDayInput[] | AttendanceEventUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDayInput | AttendanceEventCreateOrConnectWithoutDayInput[]
    createMany?: AttendanceEventCreateManyDayInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutDayInput = {
    create?: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput> | AttendanceEventCreateWithoutDayInput[] | AttendanceEventUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDayInput | AttendanceEventCreateOrConnectWithoutDayInput[]
    createMany?: AttendanceEventCreateManyDayInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutAttendanceDaysNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceDaysInput
    upsert?: UserUpsertWithoutAttendanceDaysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceDaysInput, UserUpdateWithoutAttendanceDaysInput>, UserUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type BranchUpdateOneWithoutAttendanceDaysNestedInput = {
    create?: XOR<BranchCreateWithoutAttendanceDaysInput, BranchUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAttendanceDaysInput
    upsert?: BranchUpsertWithoutAttendanceDaysInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAttendanceDaysInput, BranchUpdateWithoutAttendanceDaysInput>, BranchUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type AttendanceEventUpdateManyWithoutDayNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput> | AttendanceEventCreateWithoutDayInput[] | AttendanceEventUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDayInput | AttendanceEventCreateOrConnectWithoutDayInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutDayInput | AttendanceEventUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: AttendanceEventCreateManyDayInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutDayInput | AttendanceEventUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutDayInput | AttendanceEventUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AttendanceEventUncheckedUpdateManyWithoutDayNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput> | AttendanceEventCreateWithoutDayInput[] | AttendanceEventUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDayInput | AttendanceEventCreateOrConnectWithoutDayInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutDayInput | AttendanceEventUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: AttendanceEventCreateManyDayInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutDayInput | AttendanceEventUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutDayInput | AttendanceEventUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceEventsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<BranchCreateWithoutAttendanceEventsInput, BranchUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAttendanceEventsInput
    connect?: BranchWhereUniqueInput
  }

  export type AttendanceDayCreateNestedOneWithoutEventsInput = {
    create?: XOR<AttendanceDayCreateWithoutEventsInput, AttendanceDayUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutEventsInput
    connect?: AttendanceDayWhereUniqueInput
  }

  export type EnumAttendanceEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceEventType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAttendanceEventsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceEventsInput
    upsert?: UserUpsertWithoutAttendanceEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceEventsInput, UserUpdateWithoutAttendanceEventsInput>, UserUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type BranchUpdateOneWithoutAttendanceEventsNestedInput = {
    create?: XOR<BranchCreateWithoutAttendanceEventsInput, BranchUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAttendanceEventsInput
    upsert?: BranchUpsertWithoutAttendanceEventsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAttendanceEventsInput, BranchUpdateWithoutAttendanceEventsInput>, BranchUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type AttendanceDayUpdateOneWithoutEventsNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutEventsInput, AttendanceDayUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutEventsInput
    upsert?: AttendanceDayUpsertWithoutEventsInput
    disconnect?: AttendanceDayWhereInput | boolean
    delete?: AttendanceDayWhereInput | boolean
    connect?: AttendanceDayWhereUniqueInput
    update?: XOR<XOR<AttendanceDayUpdateToOneWithWhereWithoutEventsInput, AttendanceDayUpdateWithoutEventsInput>, AttendanceDayUncheckedUpdateWithoutEventsInput>
  }

  export type ProductCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput> | TransactionCreateWithoutFromBranchInput[] | TransactionUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromBranchInput | TransactionCreateOrConnectWithoutFromBranchInput[]
    createMany?: TransactionCreateManyFromBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutToBranchInput = {
    create?: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput> | TransactionCreateWithoutToBranchInput[] | TransactionUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToBranchInput | TransactionCreateOrConnectWithoutToBranchInput[]
    createMany?: TransactionCreateManyToBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserBranchAccessCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput> | UserBranchAccessCreateWithoutBranchInput[] | UserBranchAccessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutBranchInput | UserBranchAccessCreateOrConnectWithoutBranchInput[]
    createMany?: UserBranchAccessCreateManyBranchInputEnvelope
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutBranchInput = {
    create?: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput> | CategoryCreateWithoutBranchInput[] | CategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBranchInput | CategoryCreateOrConnectWithoutBranchInput[]
    createMany?: CategoryCreateManyBranchInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductTransferCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput> | ProductTransferCreateWithoutFromBranchInput[] | ProductTransferUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutFromBranchInput | ProductTransferCreateOrConnectWithoutFromBranchInput[]
    createMany?: ProductTransferCreateManyFromBranchInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type ProductTransferCreateNestedManyWithoutToBranchInput = {
    create?: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput> | ProductTransferCreateWithoutToBranchInput[] | ProductTransferUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutToBranchInput | ProductTransferCreateOrConnectWithoutToBranchInput[]
    createMany?: ProductTransferCreateManyToBranchInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type DefectiveLogCreateNestedManyWithoutBranchInput = {
    create?: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput> | DefectiveLogCreateWithoutBranchInput[] | DefectiveLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutBranchInput | DefectiveLogCreateOrConnectWithoutBranchInput[]
    createMany?: DefectiveLogCreateManyBranchInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type CurrencyExchangeRateCreateNestedManyWithoutBranchInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput> | CurrencyExchangeRateCreateWithoutBranchInput[] | CurrencyExchangeRateUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutBranchInput | CurrencyExchangeRateCreateOrConnectWithoutBranchInput[]
    createMany?: CurrencyExchangeRateCreateManyBranchInputEnvelope
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
  }

  export type CashierReportCreateNestedManyWithoutBranchInput = {
    create?: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput> | CashierReportCreateWithoutBranchInput[] | CashierReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutBranchInput | CashierReportCreateOrConnectWithoutBranchInput[]
    createMany?: CashierReportCreateManyBranchInputEnvelope
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
  }

  export type DailyRepaymentCreateNestedManyWithoutBranchInput = {
    create?: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput> | DailyRepaymentCreateWithoutBranchInput[] | DailyRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutBranchInput | DailyRepaymentCreateOrConnectWithoutBranchInput[]
    createMany?: DailyRepaymentCreateManyBranchInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentCreateNestedManyWithoutBranchInput = {
    create?: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput> | CreditRepaymentCreateWithoutBranchInput[] | CreditRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutBranchInput | CreditRepaymentCreateOrConnectWithoutBranchInput[]
    createMany?: CreditRepaymentCreateManyBranchInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type BonusCreateNestedManyWithoutBranchInput = {
    create?: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput> | BonusCreateWithoutBranchInput[] | BonusUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutBranchInput | BonusCreateOrConnectWithoutBranchInput[]
    createMany?: BonusCreateManyBranchInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type AttendanceDayCreateNestedManyWithoutBranchInput = {
    create?: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput> | AttendanceDayCreateWithoutBranchInput[] | AttendanceDayUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutBranchInput | AttendanceDayCreateOrConnectWithoutBranchInput[]
    createMany?: AttendanceDayCreateManyBranchInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutBranchInput = {
    create?: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput> | AttendanceEventCreateWithoutBranchInput[] | AttendanceEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutBranchInput | AttendanceEventCreateOrConnectWithoutBranchInput[]
    createMany?: AttendanceEventCreateManyBranchInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput> | TransactionCreateWithoutFromBranchInput[] | TransactionUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromBranchInput | TransactionCreateOrConnectWithoutFromBranchInput[]
    createMany?: TransactionCreateManyFromBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutToBranchInput = {
    create?: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput> | TransactionCreateWithoutToBranchInput[] | TransactionUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToBranchInput | TransactionCreateOrConnectWithoutToBranchInput[]
    createMany?: TransactionCreateManyToBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput> | UserBranchAccessCreateWithoutBranchInput[] | UserBranchAccessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutBranchInput | UserBranchAccessCreateOrConnectWithoutBranchInput[]
    createMany?: UserBranchAccessCreateManyBranchInputEnvelope
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput> | CategoryCreateWithoutBranchInput[] | CategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBranchInput | CategoryCreateOrConnectWithoutBranchInput[]
    createMany?: CategoryCreateManyBranchInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput> | ProductTransferCreateWithoutFromBranchInput[] | ProductTransferUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutFromBranchInput | ProductTransferCreateOrConnectWithoutFromBranchInput[]
    createMany?: ProductTransferCreateManyFromBranchInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type ProductTransferUncheckedCreateNestedManyWithoutToBranchInput = {
    create?: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput> | ProductTransferCreateWithoutToBranchInput[] | ProductTransferUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutToBranchInput | ProductTransferCreateOrConnectWithoutToBranchInput[]
    createMany?: ProductTransferCreateManyToBranchInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type DefectiveLogUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput> | DefectiveLogCreateWithoutBranchInput[] | DefectiveLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutBranchInput | DefectiveLogCreateOrConnectWithoutBranchInput[]
    createMany?: DefectiveLogCreateManyBranchInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput> | CurrencyExchangeRateCreateWithoutBranchInput[] | CurrencyExchangeRateUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutBranchInput | CurrencyExchangeRateCreateOrConnectWithoutBranchInput[]
    createMany?: CurrencyExchangeRateCreateManyBranchInputEnvelope
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
  }

  export type CashierReportUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput> | CashierReportCreateWithoutBranchInput[] | CashierReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutBranchInput | CashierReportCreateOrConnectWithoutBranchInput[]
    createMany?: CashierReportCreateManyBranchInputEnvelope
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
  }

  export type DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput> | DailyRepaymentCreateWithoutBranchInput[] | DailyRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutBranchInput | DailyRepaymentCreateOrConnectWithoutBranchInput[]
    createMany?: DailyRepaymentCreateManyBranchInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput> | CreditRepaymentCreateWithoutBranchInput[] | CreditRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutBranchInput | CreditRepaymentCreateOrConnectWithoutBranchInput[]
    createMany?: CreditRepaymentCreateManyBranchInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type BonusUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput> | BonusCreateWithoutBranchInput[] | BonusUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutBranchInput | BonusCreateOrConnectWithoutBranchInput[]
    createMany?: BonusCreateManyBranchInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type AttendanceDayUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput> | AttendanceDayCreateWithoutBranchInput[] | AttendanceDayUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutBranchInput | AttendanceDayCreateOrConnectWithoutBranchInput[]
    createMany?: AttendanceDayCreateManyBranchInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput> | AttendanceEventCreateWithoutBranchInput[] | AttendanceEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutBranchInput | AttendanceEventCreateOrConnectWithoutBranchInput[]
    createMany?: AttendanceEventCreateManyBranchInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumBranchTypeFieldUpdateOperationsInput = {
    set?: $Enums.BranchType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBranchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BranchStatus
  }

  export type ProductUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput> | TransactionCreateWithoutFromBranchInput[] | TransactionUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromBranchInput | TransactionCreateOrConnectWithoutFromBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromBranchInput | TransactionUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: TransactionCreateManyFromBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromBranchInput | TransactionUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromBranchInput | TransactionUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput> | TransactionCreateWithoutToBranchInput[] | TransactionUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToBranchInput | TransactionCreateOrConnectWithoutToBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToBranchInput | TransactionUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: TransactionCreateManyToBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToBranchInput | TransactionUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToBranchInput | TransactionUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserBranchAccessUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput> | UserBranchAccessCreateWithoutBranchInput[] | UserBranchAccessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutBranchInput | UserBranchAccessCreateOrConnectWithoutBranchInput[]
    upsert?: UserBranchAccessUpsertWithWhereUniqueWithoutBranchInput | UserBranchAccessUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserBranchAccessCreateManyBranchInputEnvelope
    set?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    disconnect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    delete?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    update?: UserBranchAccessUpdateWithWhereUniqueWithoutBranchInput | UserBranchAccessUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserBranchAccessUpdateManyWithWhereWithoutBranchInput | UserBranchAccessUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput> | CategoryCreateWithoutBranchInput[] | CategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBranchInput | CategoryCreateOrConnectWithoutBranchInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBranchInput | CategoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CategoryCreateManyBranchInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBranchInput | CategoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBranchInput | CategoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductTransferUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput> | ProductTransferCreateWithoutFromBranchInput[] | ProductTransferUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutFromBranchInput | ProductTransferCreateOrConnectWithoutFromBranchInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutFromBranchInput | ProductTransferUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: ProductTransferCreateManyFromBranchInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutFromBranchInput | ProductTransferUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutFromBranchInput | ProductTransferUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type ProductTransferUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput> | ProductTransferCreateWithoutToBranchInput[] | ProductTransferUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutToBranchInput | ProductTransferCreateOrConnectWithoutToBranchInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutToBranchInput | ProductTransferUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: ProductTransferCreateManyToBranchInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutToBranchInput | ProductTransferUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutToBranchInput | ProductTransferUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type DefectiveLogUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput> | DefectiveLogCreateWithoutBranchInput[] | DefectiveLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutBranchInput | DefectiveLogCreateOrConnectWithoutBranchInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutBranchInput | DefectiveLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DefectiveLogCreateManyBranchInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutBranchInput | DefectiveLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutBranchInput | DefectiveLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type CurrencyExchangeRateUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput> | CurrencyExchangeRateCreateWithoutBranchInput[] | CurrencyExchangeRateUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutBranchInput | CurrencyExchangeRateCreateOrConnectWithoutBranchInput[]
    upsert?: CurrencyExchangeRateUpsertWithWhereUniqueWithoutBranchInput | CurrencyExchangeRateUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CurrencyExchangeRateCreateManyBranchInputEnvelope
    set?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    disconnect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    delete?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    update?: CurrencyExchangeRateUpdateWithWhereUniqueWithoutBranchInput | CurrencyExchangeRateUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CurrencyExchangeRateUpdateManyWithWhereWithoutBranchInput | CurrencyExchangeRateUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
  }

  export type CashierReportUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput> | CashierReportCreateWithoutBranchInput[] | CashierReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutBranchInput | CashierReportCreateOrConnectWithoutBranchInput[]
    upsert?: CashierReportUpsertWithWhereUniqueWithoutBranchInput | CashierReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CashierReportCreateManyBranchInputEnvelope
    set?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    disconnect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    delete?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    update?: CashierReportUpdateWithWhereUniqueWithoutBranchInput | CashierReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CashierReportUpdateManyWithWhereWithoutBranchInput | CashierReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
  }

  export type DailyRepaymentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput> | DailyRepaymentCreateWithoutBranchInput[] | DailyRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutBranchInput | DailyRepaymentCreateOrConnectWithoutBranchInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutBranchInput | DailyRepaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DailyRepaymentCreateManyBranchInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutBranchInput | DailyRepaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutBranchInput | DailyRepaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput> | CreditRepaymentCreateWithoutBranchInput[] | CreditRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutBranchInput | CreditRepaymentCreateOrConnectWithoutBranchInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutBranchInput | CreditRepaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CreditRepaymentCreateManyBranchInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutBranchInput | CreditRepaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutBranchInput | CreditRepaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type BonusUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput> | BonusCreateWithoutBranchInput[] | BonusUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutBranchInput | BonusCreateOrConnectWithoutBranchInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutBranchInput | BonusUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BonusCreateManyBranchInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutBranchInput | BonusUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutBranchInput | BonusUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type AttendanceDayUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput> | AttendanceDayCreateWithoutBranchInput[] | AttendanceDayUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutBranchInput | AttendanceDayCreateOrConnectWithoutBranchInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutBranchInput | AttendanceDayUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AttendanceDayCreateManyBranchInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutBranchInput | AttendanceDayUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutBranchInput | AttendanceDayUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput> | AttendanceEventCreateWithoutBranchInput[] | AttendanceEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutBranchInput | AttendanceEventCreateOrConnectWithoutBranchInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutBranchInput | AttendanceEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AttendanceEventCreateManyBranchInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutBranchInput | AttendanceEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutBranchInput | AttendanceEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput> | TransactionCreateWithoutFromBranchInput[] | TransactionUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromBranchInput | TransactionCreateOrConnectWithoutFromBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromBranchInput | TransactionUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: TransactionCreateManyFromBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromBranchInput | TransactionUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromBranchInput | TransactionUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput> | TransactionCreateWithoutToBranchInput[] | TransactionUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToBranchInput | TransactionCreateOrConnectWithoutToBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToBranchInput | TransactionUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: TransactionCreateManyToBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToBranchInput | TransactionUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToBranchInput | TransactionUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput> | UserBranchAccessCreateWithoutBranchInput[] | UserBranchAccessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutBranchInput | UserBranchAccessCreateOrConnectWithoutBranchInput[]
    upsert?: UserBranchAccessUpsertWithWhereUniqueWithoutBranchInput | UserBranchAccessUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserBranchAccessCreateManyBranchInputEnvelope
    set?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    disconnect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    delete?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    update?: UserBranchAccessUpdateWithWhereUniqueWithoutBranchInput | UserBranchAccessUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserBranchAccessUpdateManyWithWhereWithoutBranchInput | UserBranchAccessUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput> | CategoryCreateWithoutBranchInput[] | CategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBranchInput | CategoryCreateOrConnectWithoutBranchInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBranchInput | CategoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CategoryCreateManyBranchInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBranchInput | CategoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBranchInput | CategoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput> | ProductTransferCreateWithoutFromBranchInput[] | ProductTransferUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutFromBranchInput | ProductTransferCreateOrConnectWithoutFromBranchInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutFromBranchInput | ProductTransferUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: ProductTransferCreateManyFromBranchInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutFromBranchInput | ProductTransferUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutFromBranchInput | ProductTransferUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput> | ProductTransferCreateWithoutToBranchInput[] | ProductTransferUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutToBranchInput | ProductTransferCreateOrConnectWithoutToBranchInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutToBranchInput | ProductTransferUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: ProductTransferCreateManyToBranchInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutToBranchInput | ProductTransferUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutToBranchInput | ProductTransferUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput> | DefectiveLogCreateWithoutBranchInput[] | DefectiveLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutBranchInput | DefectiveLogCreateOrConnectWithoutBranchInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutBranchInput | DefectiveLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DefectiveLogCreateManyBranchInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutBranchInput | DefectiveLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutBranchInput | DefectiveLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput> | CurrencyExchangeRateCreateWithoutBranchInput[] | CurrencyExchangeRateUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutBranchInput | CurrencyExchangeRateCreateOrConnectWithoutBranchInput[]
    upsert?: CurrencyExchangeRateUpsertWithWhereUniqueWithoutBranchInput | CurrencyExchangeRateUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CurrencyExchangeRateCreateManyBranchInputEnvelope
    set?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    disconnect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    delete?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    update?: CurrencyExchangeRateUpdateWithWhereUniqueWithoutBranchInput | CurrencyExchangeRateUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CurrencyExchangeRateUpdateManyWithWhereWithoutBranchInput | CurrencyExchangeRateUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
  }

  export type CashierReportUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput> | CashierReportCreateWithoutBranchInput[] | CashierReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutBranchInput | CashierReportCreateOrConnectWithoutBranchInput[]
    upsert?: CashierReportUpsertWithWhereUniqueWithoutBranchInput | CashierReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CashierReportCreateManyBranchInputEnvelope
    set?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    disconnect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    delete?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    update?: CashierReportUpdateWithWhereUniqueWithoutBranchInput | CashierReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CashierReportUpdateManyWithWhereWithoutBranchInput | CashierReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput> | DailyRepaymentCreateWithoutBranchInput[] | DailyRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutBranchInput | DailyRepaymentCreateOrConnectWithoutBranchInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutBranchInput | DailyRepaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DailyRepaymentCreateManyBranchInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutBranchInput | DailyRepaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutBranchInput | DailyRepaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput> | CreditRepaymentCreateWithoutBranchInput[] | CreditRepaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutBranchInput | CreditRepaymentCreateOrConnectWithoutBranchInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutBranchInput | CreditRepaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CreditRepaymentCreateManyBranchInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutBranchInput | CreditRepaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutBranchInput | CreditRepaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type BonusUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput> | BonusCreateWithoutBranchInput[] | BonusUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutBranchInput | BonusCreateOrConnectWithoutBranchInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutBranchInput | BonusUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BonusCreateManyBranchInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutBranchInput | BonusUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutBranchInput | BonusUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput> | AttendanceDayCreateWithoutBranchInput[] | AttendanceDayUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutBranchInput | AttendanceDayCreateOrConnectWithoutBranchInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutBranchInput | AttendanceDayUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AttendanceDayCreateManyBranchInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutBranchInput | AttendanceDayUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutBranchInput | AttendanceDayUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput> | AttendanceEventCreateWithoutBranchInput[] | AttendanceEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutBranchInput | AttendanceEventCreateOrConnectWithoutBranchInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutBranchInput | AttendanceEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AttendanceEventCreateManyBranchInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutBranchInput | AttendanceEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutBranchInput | AttendanceEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type UserBranchAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput> | UserBranchAccessCreateWithoutUserInput[] | UserBranchAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutUserInput | UserBranchAccessCreateOrConnectWithoutUserInput[]
    createMany?: UserBranchAccessCreateManyUserInputEnvelope
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSoldByInput = {
    create?: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput> | TransactionCreateWithoutSoldByInput[] | TransactionUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSoldByInput | TransactionCreateOrConnectWithoutSoldByInput[]
    createMany?: TransactionCreateManySoldByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProductTransferCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput> | ProductTransferCreateWithoutInitiatedByInput[] | ProductTransferUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutInitiatedByInput | ProductTransferCreateOrConnectWithoutInitiatedByInput[]
    createMany?: ProductTransferCreateManyInitiatedByInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type ProductTransferCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput> | ProductTransferCreateWithoutApprovedByInput[] | ProductTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutApprovedByInput | ProductTransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: ProductTransferCreateManyApprovedByInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type UserLocationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type DefectiveLogCreateNestedManyWithoutUserInput = {
    create?: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput> | DefectiveLogCreateWithoutUserInput[] | DefectiveLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutUserInput | DefectiveLogCreateOrConnectWithoutUserInput[]
    createMany?: DefectiveLogCreateManyUserInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type PaymentScheduleCreateNestedManyWithoutPaidByInput = {
    create?: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput> | PaymentScheduleCreateWithoutPaidByInput[] | PaymentScheduleUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutPaidByInput | PaymentScheduleCreateOrConnectWithoutPaidByInput[]
    createMany?: PaymentScheduleCreateManyPaidByInputEnvelope
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
  }

  export type PaymentRepaymentCreateNestedManyWithoutPaidByInput = {
    create?: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput> | PaymentRepaymentCreateWithoutPaidByInput[] | PaymentRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutPaidByInput | PaymentRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: PaymentRepaymentCreateManyPaidByInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type DailyRepaymentCreateNestedManyWithoutPaidByInput = {
    create?: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput> | DailyRepaymentCreateWithoutPaidByInput[] | DailyRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutPaidByInput | DailyRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: DailyRepaymentCreateManyPaidByInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentCreateNestedManyWithoutPaidByInput = {
    create?: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput> | CreditRepaymentCreateWithoutPaidByInput[] | CreditRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutPaidByInput | CreditRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: CreditRepaymentCreateManyPaidByInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type CashierReportCreateNestedManyWithoutCashierInput = {
    create?: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput> | CashierReportCreateWithoutCashierInput[] | CashierReportUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutCashierInput | CashierReportCreateOrConnectWithoutCashierInput[]
    createMany?: CashierReportCreateManyCashierInputEnvelope
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
  }

  export type CurrencyExchangeRateCreateNestedManyWithoutUserInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput> | CurrencyExchangeRateCreateWithoutUserInput[] | CurrencyExchangeRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutUserInput | CurrencyExchangeRateCreateOrConnectWithoutUserInput[]
    createMany?: CurrencyExchangeRateCreateManyUserInputEnvelope
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
  }

  export type BonusCreateNestedManyWithoutUserInput = {
    create?: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput> | BonusCreateWithoutUserInput[] | BonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutUserInput | BonusCreateOrConnectWithoutUserInput[]
    createMany?: BonusCreateManyUserInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type BonusCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput> | BonusCreateWithoutCreatedByInput[] | BonusUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutCreatedByInput | BonusCreateOrConnectWithoutCreatedByInput[]
    createMany?: BonusCreateManyCreatedByInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type AttendanceDayCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput> | AttendanceEventCreateWithoutUserInput[] | AttendanceEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutUserInput | AttendanceEventCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceEventCreateManyUserInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type FaceTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput> | FaceTemplateCreateWithoutUserInput[] | FaceTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FaceTemplateCreateOrConnectWithoutUserInput | FaceTemplateCreateOrConnectWithoutUserInput[]
    createMany?: FaceTemplateCreateManyUserInputEnvelope
    connect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput> | TransactionCreateWithoutUpdatedByInput[] | TransactionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUpdatedByInput | TransactionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TransactionCreateManyUpdatedByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserBranchAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput> | UserBranchAccessCreateWithoutUserInput[] | UserBranchAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutUserInput | UserBranchAccessCreateOrConnectWithoutUserInput[]
    createMany?: UserBranchAccessCreateManyUserInputEnvelope
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSoldByInput = {
    create?: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput> | TransactionCreateWithoutSoldByInput[] | TransactionUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSoldByInput | TransactionCreateOrConnectWithoutSoldByInput[]
    createMany?: TransactionCreateManySoldByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput> | ProductTransferCreateWithoutInitiatedByInput[] | ProductTransferUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutInitiatedByInput | ProductTransferCreateOrConnectWithoutInitiatedByInput[]
    createMany?: ProductTransferCreateManyInitiatedByInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput> | ProductTransferCreateWithoutApprovedByInput[] | ProductTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutApprovedByInput | ProductTransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: ProductTransferCreateManyApprovedByInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type UserLocationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type DefectiveLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput> | DefectiveLogCreateWithoutUserInput[] | DefectiveLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutUserInput | DefectiveLogCreateOrConnectWithoutUserInput[]
    createMany?: DefectiveLogCreateManyUserInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput> | PaymentScheduleCreateWithoutPaidByInput[] | PaymentScheduleUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutPaidByInput | PaymentScheduleCreateOrConnectWithoutPaidByInput[]
    createMany?: PaymentScheduleCreateManyPaidByInputEnvelope
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
  }

  export type PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput> | PaymentRepaymentCreateWithoutPaidByInput[] | PaymentRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutPaidByInput | PaymentRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: PaymentRepaymentCreateManyPaidByInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput> | DailyRepaymentCreateWithoutPaidByInput[] | DailyRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutPaidByInput | DailyRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: DailyRepaymentCreateManyPaidByInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput> | CreditRepaymentCreateWithoutPaidByInput[] | CreditRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutPaidByInput | CreditRepaymentCreateOrConnectWithoutPaidByInput[]
    createMany?: CreditRepaymentCreateManyPaidByInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type CashierReportUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput> | CashierReportCreateWithoutCashierInput[] | CashierReportUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutCashierInput | CashierReportCreateOrConnectWithoutCashierInput[]
    createMany?: CashierReportCreateManyCashierInputEnvelope
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
  }

  export type CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput> | CurrencyExchangeRateCreateWithoutUserInput[] | CurrencyExchangeRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutUserInput | CurrencyExchangeRateCreateOrConnectWithoutUserInput[]
    createMany?: CurrencyExchangeRateCreateManyUserInputEnvelope
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
  }

  export type BonusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput> | BonusCreateWithoutUserInput[] | BonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutUserInput | BonusCreateOrConnectWithoutUserInput[]
    createMany?: BonusCreateManyUserInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type BonusUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput> | BonusCreateWithoutCreatedByInput[] | BonusUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutCreatedByInput | BonusCreateOrConnectWithoutCreatedByInput[]
    createMany?: BonusCreateManyCreatedByInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type AttendanceDayUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput> | AttendanceEventCreateWithoutUserInput[] | AttendanceEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutUserInput | AttendanceEventCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceEventCreateManyUserInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type FaceTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput> | FaceTemplateCreateWithoutUserInput[] | FaceTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FaceTemplateCreateOrConnectWithoutUserInput | FaceTemplateCreateOrConnectWithoutUserInput[]
    createMany?: FaceTemplateCreateManyUserInputEnvelope
    connect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput> | TransactionCreateWithoutUpdatedByInput[] | TransactionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUpdatedByInput | TransactionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TransactionCreateManyUpdatedByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type UserBranchAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput> | UserBranchAccessCreateWithoutUserInput[] | UserBranchAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutUserInput | UserBranchAccessCreateOrConnectWithoutUserInput[]
    upsert?: UserBranchAccessUpsertWithWhereUniqueWithoutUserInput | UserBranchAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBranchAccessCreateManyUserInputEnvelope
    set?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    disconnect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    delete?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    update?: UserBranchAccessUpdateWithWhereUniqueWithoutUserInput | UserBranchAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBranchAccessUpdateManyWithWhereWithoutUserInput | UserBranchAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSoldByNestedInput = {
    create?: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput> | TransactionCreateWithoutSoldByInput[] | TransactionUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSoldByInput | TransactionCreateOrConnectWithoutSoldByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSoldByInput | TransactionUpsertWithWhereUniqueWithoutSoldByInput[]
    createMany?: TransactionCreateManySoldByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSoldByInput | TransactionUpdateWithWhereUniqueWithoutSoldByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSoldByInput | TransactionUpdateManyWithWhereWithoutSoldByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProductTransferUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput> | ProductTransferCreateWithoutInitiatedByInput[] | ProductTransferUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutInitiatedByInput | ProductTransferCreateOrConnectWithoutInitiatedByInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutInitiatedByInput | ProductTransferUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: ProductTransferCreateManyInitiatedByInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutInitiatedByInput | ProductTransferUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutInitiatedByInput | ProductTransferUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type ProductTransferUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput> | ProductTransferCreateWithoutApprovedByInput[] | ProductTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutApprovedByInput | ProductTransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutApprovedByInput | ProductTransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ProductTransferCreateManyApprovedByInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutApprovedByInput | ProductTransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutApprovedByInput | ProductTransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type UserLocationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutUserInput | UserLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutUserInput | UserLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutUserInput | UserLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type DefectiveLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput> | DefectiveLogCreateWithoutUserInput[] | DefectiveLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutUserInput | DefectiveLogCreateOrConnectWithoutUserInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutUserInput | DefectiveLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DefectiveLogCreateManyUserInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutUserInput | DefectiveLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutUserInput | DefectiveLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type PaymentScheduleUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput> | PaymentScheduleCreateWithoutPaidByInput[] | PaymentScheduleUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutPaidByInput | PaymentScheduleCreateOrConnectWithoutPaidByInput[]
    upsert?: PaymentScheduleUpsertWithWhereUniqueWithoutPaidByInput | PaymentScheduleUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: PaymentScheduleCreateManyPaidByInputEnvelope
    set?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    disconnect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    delete?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    update?: PaymentScheduleUpdateWithWhereUniqueWithoutPaidByInput | PaymentScheduleUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: PaymentScheduleUpdateManyWithWhereWithoutPaidByInput | PaymentScheduleUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
  }

  export type PaymentRepaymentUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput> | PaymentRepaymentCreateWithoutPaidByInput[] | PaymentRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutPaidByInput | PaymentRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutPaidByInput | PaymentRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: PaymentRepaymentCreateManyPaidByInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutPaidByInput | PaymentRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutPaidByInput | PaymentRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type DailyRepaymentUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput> | DailyRepaymentCreateWithoutPaidByInput[] | DailyRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutPaidByInput | DailyRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutPaidByInput | DailyRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: DailyRepaymentCreateManyPaidByInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutPaidByInput | DailyRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutPaidByInput | DailyRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput> | CreditRepaymentCreateWithoutPaidByInput[] | CreditRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutPaidByInput | CreditRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutPaidByInput | CreditRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: CreditRepaymentCreateManyPaidByInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutPaidByInput | CreditRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutPaidByInput | CreditRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type CashierReportUpdateManyWithoutCashierNestedInput = {
    create?: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput> | CashierReportCreateWithoutCashierInput[] | CashierReportUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutCashierInput | CashierReportCreateOrConnectWithoutCashierInput[]
    upsert?: CashierReportUpsertWithWhereUniqueWithoutCashierInput | CashierReportUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: CashierReportCreateManyCashierInputEnvelope
    set?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    disconnect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    delete?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    update?: CashierReportUpdateWithWhereUniqueWithoutCashierInput | CashierReportUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: CashierReportUpdateManyWithWhereWithoutCashierInput | CashierReportUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
  }

  export type CurrencyExchangeRateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput> | CurrencyExchangeRateCreateWithoutUserInput[] | CurrencyExchangeRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutUserInput | CurrencyExchangeRateCreateOrConnectWithoutUserInput[]
    upsert?: CurrencyExchangeRateUpsertWithWhereUniqueWithoutUserInput | CurrencyExchangeRateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurrencyExchangeRateCreateManyUserInputEnvelope
    set?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    disconnect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    delete?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    update?: CurrencyExchangeRateUpdateWithWhereUniqueWithoutUserInput | CurrencyExchangeRateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurrencyExchangeRateUpdateManyWithWhereWithoutUserInput | CurrencyExchangeRateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
  }

  export type BonusUpdateManyWithoutUserNestedInput = {
    create?: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput> | BonusCreateWithoutUserInput[] | BonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutUserInput | BonusCreateOrConnectWithoutUserInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutUserInput | BonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BonusCreateManyUserInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutUserInput | BonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutUserInput | BonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type BonusUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput> | BonusCreateWithoutCreatedByInput[] | BonusUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutCreatedByInput | BonusCreateOrConnectWithoutCreatedByInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutCreatedByInput | BonusUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BonusCreateManyCreatedByInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutCreatedByInput | BonusUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutCreatedByInput | BonusUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type AttendanceDayUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutUserInput | AttendanceDayUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutUserInput | AttendanceDayUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutUserInput | AttendanceDayUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput> | AttendanceEventCreateWithoutUserInput[] | AttendanceEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutUserInput | AttendanceEventCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutUserInput | AttendanceEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceEventCreateManyUserInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutUserInput | AttendanceEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutUserInput | AttendanceEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type FaceTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput> | FaceTemplateCreateWithoutUserInput[] | FaceTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FaceTemplateCreateOrConnectWithoutUserInput | FaceTemplateCreateOrConnectWithoutUserInput[]
    upsert?: FaceTemplateUpsertWithWhereUniqueWithoutUserInput | FaceTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FaceTemplateCreateManyUserInputEnvelope
    set?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    disconnect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    delete?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    connect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    update?: FaceTemplateUpdateWithWhereUniqueWithoutUserInput | FaceTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FaceTemplateUpdateManyWithWhereWithoutUserInput | FaceTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FaceTemplateScalarWhereInput | FaceTemplateScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput> | TransactionCreateWithoutUpdatedByInput[] | TransactionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUpdatedByInput | TransactionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUpdatedByInput | TransactionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TransactionCreateManyUpdatedByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUpdatedByInput | TransactionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUpdatedByInput | TransactionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput> | UserBranchAccessCreateWithoutUserInput[] | UserBranchAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBranchAccessCreateOrConnectWithoutUserInput | UserBranchAccessCreateOrConnectWithoutUserInput[]
    upsert?: UserBranchAccessUpsertWithWhereUniqueWithoutUserInput | UserBranchAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBranchAccessCreateManyUserInputEnvelope
    set?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    disconnect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    delete?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    connect?: UserBranchAccessWhereUniqueInput | UserBranchAccessWhereUniqueInput[]
    update?: UserBranchAccessUpdateWithWhereUniqueWithoutUserInput | UserBranchAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBranchAccessUpdateManyWithWhereWithoutUserInput | UserBranchAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSoldByNestedInput = {
    create?: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput> | TransactionCreateWithoutSoldByInput[] | TransactionUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSoldByInput | TransactionCreateOrConnectWithoutSoldByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSoldByInput | TransactionUpsertWithWhereUniqueWithoutSoldByInput[]
    createMany?: TransactionCreateManySoldByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSoldByInput | TransactionUpdateWithWhereUniqueWithoutSoldByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSoldByInput | TransactionUpdateManyWithWhereWithoutSoldByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput> | ProductTransferCreateWithoutInitiatedByInput[] | ProductTransferUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutInitiatedByInput | ProductTransferCreateOrConnectWithoutInitiatedByInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutInitiatedByInput | ProductTransferUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: ProductTransferCreateManyInitiatedByInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutInitiatedByInput | ProductTransferUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutInitiatedByInput | ProductTransferUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput> | ProductTransferCreateWithoutApprovedByInput[] | ProductTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutApprovedByInput | ProductTransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutApprovedByInput | ProductTransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ProductTransferCreateManyApprovedByInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutApprovedByInput | ProductTransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutApprovedByInput | ProductTransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type UserLocationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutUserInput | UserLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutUserInput | UserLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutUserInput | UserLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type DefectiveLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput> | DefectiveLogCreateWithoutUserInput[] | DefectiveLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutUserInput | DefectiveLogCreateOrConnectWithoutUserInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutUserInput | DefectiveLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DefectiveLogCreateManyUserInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutUserInput | DefectiveLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutUserInput | DefectiveLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput> | PaymentScheduleCreateWithoutPaidByInput[] | PaymentScheduleUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutPaidByInput | PaymentScheduleCreateOrConnectWithoutPaidByInput[]
    upsert?: PaymentScheduleUpsertWithWhereUniqueWithoutPaidByInput | PaymentScheduleUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: PaymentScheduleCreateManyPaidByInputEnvelope
    set?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    disconnect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    delete?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    update?: PaymentScheduleUpdateWithWhereUniqueWithoutPaidByInput | PaymentScheduleUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: PaymentScheduleUpdateManyWithWhereWithoutPaidByInput | PaymentScheduleUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput> | PaymentRepaymentCreateWithoutPaidByInput[] | PaymentRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutPaidByInput | PaymentRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutPaidByInput | PaymentRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: PaymentRepaymentCreateManyPaidByInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutPaidByInput | PaymentRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutPaidByInput | PaymentRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput> | DailyRepaymentCreateWithoutPaidByInput[] | DailyRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutPaidByInput | DailyRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutPaidByInput | DailyRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: DailyRepaymentCreateManyPaidByInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutPaidByInput | DailyRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutPaidByInput | DailyRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput> | CreditRepaymentCreateWithoutPaidByInput[] | CreditRepaymentUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutPaidByInput | CreditRepaymentCreateOrConnectWithoutPaidByInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutPaidByInput | CreditRepaymentUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: CreditRepaymentCreateManyPaidByInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutPaidByInput | CreditRepaymentUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutPaidByInput | CreditRepaymentUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type CashierReportUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput> | CashierReportCreateWithoutCashierInput[] | CashierReportUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: CashierReportCreateOrConnectWithoutCashierInput | CashierReportCreateOrConnectWithoutCashierInput[]
    upsert?: CashierReportUpsertWithWhereUniqueWithoutCashierInput | CashierReportUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: CashierReportCreateManyCashierInputEnvelope
    set?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    disconnect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    delete?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    connect?: CashierReportWhereUniqueInput | CashierReportWhereUniqueInput[]
    update?: CashierReportUpdateWithWhereUniqueWithoutCashierInput | CashierReportUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: CashierReportUpdateManyWithWhereWithoutCashierInput | CashierReportUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
  }

  export type CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput> | CurrencyExchangeRateCreateWithoutUserInput[] | CurrencyExchangeRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrencyExchangeRateCreateOrConnectWithoutUserInput | CurrencyExchangeRateCreateOrConnectWithoutUserInput[]
    upsert?: CurrencyExchangeRateUpsertWithWhereUniqueWithoutUserInput | CurrencyExchangeRateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurrencyExchangeRateCreateManyUserInputEnvelope
    set?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    disconnect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    delete?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    connect?: CurrencyExchangeRateWhereUniqueInput | CurrencyExchangeRateWhereUniqueInput[]
    update?: CurrencyExchangeRateUpdateWithWhereUniqueWithoutUserInput | CurrencyExchangeRateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurrencyExchangeRateUpdateManyWithWhereWithoutUserInput | CurrencyExchangeRateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
  }

  export type BonusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput> | BonusCreateWithoutUserInput[] | BonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutUserInput | BonusCreateOrConnectWithoutUserInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutUserInput | BonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BonusCreateManyUserInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutUserInput | BonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutUserInput | BonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type BonusUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput> | BonusCreateWithoutCreatedByInput[] | BonusUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutCreatedByInput | BonusCreateOrConnectWithoutCreatedByInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutCreatedByInput | BonusUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BonusCreateManyCreatedByInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutCreatedByInput | BonusUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutCreatedByInput | BonusUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type AttendanceDayUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutUserInput | AttendanceDayUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutUserInput | AttendanceDayUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutUserInput | AttendanceDayUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput> | AttendanceEventCreateWithoutUserInput[] | AttendanceEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutUserInput | AttendanceEventCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutUserInput | AttendanceEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceEventCreateManyUserInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutUserInput | AttendanceEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutUserInput | AttendanceEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type FaceTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput> | FaceTemplateCreateWithoutUserInput[] | FaceTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FaceTemplateCreateOrConnectWithoutUserInput | FaceTemplateCreateOrConnectWithoutUserInput[]
    upsert?: FaceTemplateUpsertWithWhereUniqueWithoutUserInput | FaceTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FaceTemplateCreateManyUserInputEnvelope
    set?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    disconnect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    delete?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    connect?: FaceTemplateWhereUniqueInput | FaceTemplateWhereUniqueInput[]
    update?: FaceTemplateUpdateWithWhereUniqueWithoutUserInput | FaceTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FaceTemplateUpdateManyWithWhereWithoutUserInput | FaceTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FaceTemplateScalarWhereInput | FaceTemplateScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput> | TransactionCreateWithoutUpdatedByInput[] | TransactionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUpdatedByInput | TransactionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUpdatedByInput | TransactionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TransactionCreateManyUpdatedByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUpdatedByInput | TransactionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUpdatedByInput | TransactionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAllowedBranchesInput = {
    create?: XOR<UserCreateWithoutAllowedBranchesInput, UserUncheckedCreateWithoutAllowedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllowedBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAllowedUsersInput = {
    create?: XOR<BranchCreateWithoutAllowedUsersInput, BranchUncheckedCreateWithoutAllowedUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAllowedUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAllowedBranchesNestedInput = {
    create?: XOR<UserCreateWithoutAllowedBranchesInput, UserUncheckedCreateWithoutAllowedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllowedBranchesInput
    upsert?: UserUpsertWithoutAllowedBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAllowedBranchesInput, UserUpdateWithoutAllowedBranchesInput>, UserUncheckedUpdateWithoutAllowedBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutAllowedUsersNestedInput = {
    create?: XOR<BranchCreateWithoutAllowedUsersInput, BranchUncheckedCreateWithoutAllowedUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAllowedUsersInput
    upsert?: BranchUpsertWithoutAllowedUsersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAllowedUsersInput, BranchUpdateWithoutAllowedUsersInput>, BranchUncheckedUpdateWithoutAllowedUsersInput>
  }

  export type UserCreateNestedOneWithoutUserLocationsInput = {
    create?: XOR<UserCreateWithoutUserLocationsInput, UserUncheckedCreateWithoutUserLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLocationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutUserLocationsNestedInput = {
    create?: XOR<UserCreateWithoutUserLocationsInput, UserUncheckedCreateWithoutUserLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLocationsInput
    upsert?: UserUpsertWithoutUserLocationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLocationsInput, UserUpdateWithoutUserLocationsInput>, UserUncheckedUpdateWithoutUserLocationsInput>
  }

  export type BranchCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BranchCreateWithoutCategoriesInput, BranchUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCategoriesInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<BranchCreateWithoutCategoriesInput, BranchUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCategoriesInput
    upsert?: BranchUpsertWithoutCategoriesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCategoriesInput, BranchUpdateWithoutCategoriesInput>, BranchUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutProductsInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    connect?: BranchWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type DefectiveLogCreateNestedManyWithoutProductInput = {
    create?: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput> | DefectiveLogCreateWithoutProductInput[] | DefectiveLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutProductInput | DefectiveLogCreateOrConnectWithoutProductInput[]
    createMany?: DefectiveLogCreateManyProductInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type ProductTransferCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput> | ProductTransferCreateWithoutProductInput[] | ProductTransferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutProductInput | ProductTransferCreateOrConnectWithoutProductInput[]
    createMany?: ProductTransferCreateManyProductInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type TransactionBonusProductCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput> | TransactionBonusProductCreateWithoutProductInput[] | TransactionBonusProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutProductInput | TransactionBonusProductCreateOrConnectWithoutProductInput[]
    createMany?: TransactionBonusProductCreateManyProductInputEnvelope
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type DefectiveLogUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput> | DefectiveLogCreateWithoutProductInput[] | DefectiveLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutProductInput | DefectiveLogCreateOrConnectWithoutProductInput[]
    createMany?: DefectiveLogCreateManyProductInputEnvelope
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
  }

  export type ProductTransferUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput> | ProductTransferCreateWithoutProductInput[] | ProductTransferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutProductInput | ProductTransferCreateOrConnectWithoutProductInput[]
    createMany?: ProductTransferCreateManyProductInputEnvelope
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
  }

  export type TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput> | TransactionBonusProductCreateWithoutProductInput[] | TransactionBonusProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutProductInput | TransactionBonusProductCreateOrConnectWithoutProductInput[]
    createMany?: TransactionBonusProductCreateManyProductInputEnvelope
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type EnumProductSizeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductSizeType
  }

  export type BranchUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    upsert?: BranchUpsertWithoutProductsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProductsInput, BranchUpdateWithoutProductsInput>, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type TransactionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type DefectiveLogUpdateManyWithoutProductNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput> | DefectiveLogCreateWithoutProductInput[] | DefectiveLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutProductInput | DefectiveLogCreateOrConnectWithoutProductInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutProductInput | DefectiveLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DefectiveLogCreateManyProductInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutProductInput | DefectiveLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutProductInput | DefectiveLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type ProductTransferUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput> | ProductTransferCreateWithoutProductInput[] | ProductTransferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutProductInput | ProductTransferCreateOrConnectWithoutProductInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutProductInput | ProductTransferUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTransferCreateManyProductInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutProductInput | ProductTransferUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutProductInput | ProductTransferUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type TransactionBonusProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput> | TransactionBonusProductCreateWithoutProductInput[] | TransactionBonusProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutProductInput | TransactionBonusProductCreateOrConnectWithoutProductInput[]
    upsert?: TransactionBonusProductUpsertWithWhereUniqueWithoutProductInput | TransactionBonusProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionBonusProductCreateManyProductInputEnvelope
    set?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    disconnect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    delete?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    update?: TransactionBonusProductUpdateWithWhereUniqueWithoutProductInput | TransactionBonusProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionBonusProductUpdateManyWithWhereWithoutProductInput | TransactionBonusProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type DefectiveLogUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput> | DefectiveLogCreateWithoutProductInput[] | DefectiveLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DefectiveLogCreateOrConnectWithoutProductInput | DefectiveLogCreateOrConnectWithoutProductInput[]
    upsert?: DefectiveLogUpsertWithWhereUniqueWithoutProductInput | DefectiveLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DefectiveLogCreateManyProductInputEnvelope
    set?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    disconnect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    delete?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    connect?: DefectiveLogWhereUniqueInput | DefectiveLogWhereUniqueInput[]
    update?: DefectiveLogUpdateWithWhereUniqueWithoutProductInput | DefectiveLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DefectiveLogUpdateManyWithWhereWithoutProductInput | DefectiveLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
  }

  export type ProductTransferUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput> | ProductTransferCreateWithoutProductInput[] | ProductTransferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTransferCreateOrConnectWithoutProductInput | ProductTransferCreateOrConnectWithoutProductInput[]
    upsert?: ProductTransferUpsertWithWhereUniqueWithoutProductInput | ProductTransferUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTransferCreateManyProductInputEnvelope
    set?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    disconnect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    delete?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    connect?: ProductTransferWhereUniqueInput | ProductTransferWhereUniqueInput[]
    update?: ProductTransferUpdateWithWhereUniqueWithoutProductInput | ProductTransferUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTransferUpdateManyWithWhereWithoutProductInput | ProductTransferUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
  }

  export type TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput> | TransactionBonusProductCreateWithoutProductInput[] | TransactionBonusProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutProductInput | TransactionBonusProductCreateOrConnectWithoutProductInput[]
    upsert?: TransactionBonusProductUpsertWithWhereUniqueWithoutProductInput | TransactionBonusProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionBonusProductCreateManyProductInputEnvelope
    set?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    disconnect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    delete?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    update?: TransactionBonusProductUpdateWithWhereUniqueWithoutProductInput | TransactionBonusProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionBonusProductUpdateManyWithWhereWithoutProductInput | TransactionBonusProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutDefectiveLogInput = {
    create?: XOR<ProductCreateWithoutDefectiveLogInput, ProductUncheckedCreateWithoutDefectiveLogInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDefectiveLogInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDefectiveLogsInput = {
    create?: XOR<UserCreateWithoutDefectiveLogsInput, UserUncheckedCreateWithoutDefectiveLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefectiveLogsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDefectiveLogsInput = {
    create?: XOR<BranchCreateWithoutDefectiveLogsInput, BranchUncheckedCreateWithoutDefectiveLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDefectiveLogsInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutDefectiveLogNestedInput = {
    create?: XOR<ProductCreateWithoutDefectiveLogInput, ProductUncheckedCreateWithoutDefectiveLogInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDefectiveLogInput
    upsert?: ProductUpsertWithoutDefectiveLogInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutDefectiveLogInput, ProductUpdateWithoutDefectiveLogInput>, ProductUncheckedUpdateWithoutDefectiveLogInput>
  }

  export type UserUpdateOneWithoutDefectiveLogsNestedInput = {
    create?: XOR<UserCreateWithoutDefectiveLogsInput, UserUncheckedCreateWithoutDefectiveLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefectiveLogsInput
    upsert?: UserUpsertWithoutDefectiveLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDefectiveLogsInput, UserUpdateWithoutDefectiveLogsInput>, UserUncheckedUpdateWithoutDefectiveLogsInput>
  }

  export type BranchUpdateOneWithoutDefectiveLogsNestedInput = {
    create?: XOR<BranchCreateWithoutDefectiveLogsInput, BranchUncheckedCreateWithoutDefectiveLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDefectiveLogsInput
    upsert?: BranchUpsertWithoutDefectiveLogsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDefectiveLogsInput, BranchUpdateWithoutDefectiveLogsInput>, BranchUncheckedUpdateWithoutDefectiveLogsInput>
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTransactionsInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSoldTransactionsInput = {
    create?: XOR<UserCreateWithoutSoldTransactionsInput, UserUncheckedCreateWithoutSoldTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutToTransactionsInput = {
    create?: XOR<BranchCreateWithoutToTransactionsInput, BranchUncheckedCreateWithoutToTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutToTransactionsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionItemCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PaymentScheduleCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput> | PaymentScheduleCreateWithoutTransactionInput[] | PaymentScheduleUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutTransactionInput | PaymentScheduleCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentScheduleCreateManyTransactionInputEnvelope
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
  }

  export type PaymentRepaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput> | PaymentRepaymentCreateWithoutTransactionInput[] | PaymentRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutTransactionInput | PaymentRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentRepaymentCreateManyTransactionInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type DailyRepaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput> | DailyRepaymentCreateWithoutTransactionInput[] | DailyRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutTransactionInput | DailyRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: DailyRepaymentCreateManyTransactionInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput> | CreditRepaymentCreateWithoutTransactionInput[] | CreditRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutTransactionInput | CreditRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: CreditRepaymentCreateManyTransactionInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type TransactionBonusProductCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput> | TransactionBonusProductCreateWithoutTransactionInput[] | TransactionBonusProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutTransactionInput | TransactionBonusProductCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionBonusProductCreateManyTransactionInputEnvelope
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
  }

  export type BonusCreateNestedManyWithoutTransactionInput = {
    create?: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput> | BonusCreateWithoutTransactionInput[] | BonusUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutTransactionInput | BonusCreateOrConnectWithoutTransactionInput[]
    createMany?: BonusCreateManyTransactionInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput> | PaymentScheduleCreateWithoutTransactionInput[] | PaymentScheduleUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutTransactionInput | PaymentScheduleCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentScheduleCreateManyTransactionInputEnvelope
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
  }

  export type PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput> | PaymentRepaymentCreateWithoutTransactionInput[] | PaymentRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutTransactionInput | PaymentRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentRepaymentCreateManyTransactionInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput> | DailyRepaymentCreateWithoutTransactionInput[] | DailyRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutTransactionInput | DailyRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: DailyRepaymentCreateManyTransactionInputEnvelope
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput> | CreditRepaymentCreateWithoutTransactionInput[] | CreditRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutTransactionInput | CreditRepaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: CreditRepaymentCreateManyTransactionInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput> | TransactionBonusProductCreateWithoutTransactionInput[] | TransactionBonusProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutTransactionInput | TransactionBonusProductCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionBonusProductCreateManyTransactionInputEnvelope
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
  }

  export type BonusUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput> | BonusCreateWithoutTransactionInput[] | BonusUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutTransactionInput | BonusCreateOrConnectWithoutTransactionInput[]
    createMany?: BonusCreateManyTransactionInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type NullableEnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType | null
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneWithoutCreatedTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    upsert?: UserUpsertWithoutCreatedTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTransactionsInput, UserUpdateWithoutCreatedTransactionsInput>, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type UserUpdateOneWithoutSoldTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutSoldTransactionsInput, UserUncheckedCreateWithoutSoldTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldTransactionsInput
    upsert?: UserUpsertWithoutSoldTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoldTransactionsInput, UserUpdateWithoutSoldTransactionsInput>, UserUncheckedUpdateWithoutSoldTransactionsInput>
  }

  export type BranchUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionsInput
    upsert?: BranchUpsertWithoutTransactionsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTransactionsInput, BranchUpdateWithoutTransactionsInput>, BranchUncheckedUpdateWithoutTransactionsInput>
  }

  export type BranchUpdateOneWithoutToTransactionsNestedInput = {
    create?: XOR<BranchCreateWithoutToTransactionsInput, BranchUncheckedCreateWithoutToTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutToTransactionsInput
    upsert?: BranchUpsertWithoutToTransactionsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutToTransactionsInput, BranchUpdateWithoutToTransactionsInput>, BranchUncheckedUpdateWithoutToTransactionsInput>
  }

  export type UserUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionItemUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PaymentScheduleUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput> | PaymentScheduleCreateWithoutTransactionInput[] | PaymentScheduleUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutTransactionInput | PaymentScheduleCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentScheduleUpsertWithWhereUniqueWithoutTransactionInput | PaymentScheduleUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentScheduleCreateManyTransactionInputEnvelope
    set?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    disconnect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    delete?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    update?: PaymentScheduleUpdateWithWhereUniqueWithoutTransactionInput | PaymentScheduleUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentScheduleUpdateManyWithWhereWithoutTransactionInput | PaymentScheduleUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
  }

  export type PaymentRepaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput> | PaymentRepaymentCreateWithoutTransactionInput[] | PaymentRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutTransactionInput | PaymentRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutTransactionInput | PaymentRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentRepaymentCreateManyTransactionInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutTransactionInput | PaymentRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutTransactionInput | PaymentRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type DailyRepaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput> | DailyRepaymentCreateWithoutTransactionInput[] | DailyRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutTransactionInput | DailyRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutTransactionInput | DailyRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: DailyRepaymentCreateManyTransactionInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutTransactionInput | DailyRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutTransactionInput | DailyRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput> | CreditRepaymentCreateWithoutTransactionInput[] | CreditRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutTransactionInput | CreditRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutTransactionInput | CreditRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: CreditRepaymentCreateManyTransactionInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutTransactionInput | CreditRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutTransactionInput | CreditRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type TransactionBonusProductUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput> | TransactionBonusProductCreateWithoutTransactionInput[] | TransactionBonusProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutTransactionInput | TransactionBonusProductCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionBonusProductUpsertWithWhereUniqueWithoutTransactionInput | TransactionBonusProductUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionBonusProductCreateManyTransactionInputEnvelope
    set?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    disconnect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    delete?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    update?: TransactionBonusProductUpdateWithWhereUniqueWithoutTransactionInput | TransactionBonusProductUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionBonusProductUpdateManyWithWhereWithoutTransactionInput | TransactionBonusProductUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
  }

  export type BonusUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput> | BonusCreateWithoutTransactionInput[] | BonusUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutTransactionInput | BonusCreateOrConnectWithoutTransactionInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutTransactionInput | BonusUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: BonusCreateManyTransactionInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutTransactionInput | BonusUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutTransactionInput | BonusUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput> | PaymentScheduleCreateWithoutTransactionInput[] | PaymentScheduleUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutTransactionInput | PaymentScheduleCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentScheduleUpsertWithWhereUniqueWithoutTransactionInput | PaymentScheduleUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentScheduleCreateManyTransactionInputEnvelope
    set?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    disconnect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    delete?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    connect?: PaymentScheduleWhereUniqueInput | PaymentScheduleWhereUniqueInput[]
    update?: PaymentScheduleUpdateWithWhereUniqueWithoutTransactionInput | PaymentScheduleUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentScheduleUpdateManyWithWhereWithoutTransactionInput | PaymentScheduleUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput> | PaymentRepaymentCreateWithoutTransactionInput[] | PaymentRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutTransactionInput | PaymentRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutTransactionInput | PaymentRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentRepaymentCreateManyTransactionInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutTransactionInput | PaymentRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutTransactionInput | PaymentRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput> | DailyRepaymentCreateWithoutTransactionInput[] | DailyRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: DailyRepaymentCreateOrConnectWithoutTransactionInput | DailyRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: DailyRepaymentUpsertWithWhereUniqueWithoutTransactionInput | DailyRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: DailyRepaymentCreateManyTransactionInputEnvelope
    set?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    disconnect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    delete?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    connect?: DailyRepaymentWhereUniqueInput | DailyRepaymentWhereUniqueInput[]
    update?: DailyRepaymentUpdateWithWhereUniqueWithoutTransactionInput | DailyRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: DailyRepaymentUpdateManyWithWhereWithoutTransactionInput | DailyRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput> | CreditRepaymentCreateWithoutTransactionInput[] | CreditRepaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutTransactionInput | CreditRepaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutTransactionInput | CreditRepaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: CreditRepaymentCreateManyTransactionInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutTransactionInput | CreditRepaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutTransactionInput | CreditRepaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput> | TransactionBonusProductCreateWithoutTransactionInput[] | TransactionBonusProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionBonusProductCreateOrConnectWithoutTransactionInput | TransactionBonusProductCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionBonusProductUpsertWithWhereUniqueWithoutTransactionInput | TransactionBonusProductUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionBonusProductCreateManyTransactionInputEnvelope
    set?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    disconnect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    delete?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    connect?: TransactionBonusProductWhereUniqueInput | TransactionBonusProductWhereUniqueInput[]
    update?: TransactionBonusProductUpdateWithWhereUniqueWithoutTransactionInput | TransactionBonusProductUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionBonusProductUpdateManyWithWhereWithoutTransactionInput | TransactionBonusProductUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
  }

  export type BonusUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput> | BonusCreateWithoutTransactionInput[] | BonusUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutTransactionInput | BonusCreateOrConnectWithoutTransactionInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutTransactionInput | BonusUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: BonusCreateManyTransactionInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutTransactionInput | BonusUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutTransactionInput | BonusUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutItemsInput
    connect?: TransactionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutItemsInput
    upsert?: TransactionUpsertWithoutItemsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutItemsInput, TransactionUpdateWithoutItemsInput>, TransactionUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput
    upsert?: ProductUpsertWithoutTransactionsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransactionsInput, ProductUpdateWithoutTransactionsInput>, ProductUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductCreateNestedOneWithoutProductTransferInput = {
    create?: XOR<ProductCreateWithoutProductTransferInput, ProductUncheckedCreateWithoutProductTransferInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductTransferInput
    connect?: ProductWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutFromTransfersInput = {
    create?: XOR<BranchCreateWithoutFromTransfersInput, BranchUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFromTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutToTransfersInput = {
    create?: XOR<BranchCreateWithoutToTransfersInput, BranchUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutToTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInitiatedTransfersInput = {
    create?: XOR<UserCreateWithoutInitiatedTransfersInput, UserUncheckedCreateWithoutInitiatedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedTransfersInput = {
    create?: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type ProductUpdateOneRequiredWithoutProductTransferNestedInput = {
    create?: XOR<ProductCreateWithoutProductTransferInput, ProductUncheckedCreateWithoutProductTransferInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductTransferInput
    upsert?: ProductUpsertWithoutProductTransferInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductTransferInput, ProductUpdateWithoutProductTransferInput>, ProductUncheckedUpdateWithoutProductTransferInput>
  }

  export type BranchUpdateOneRequiredWithoutFromTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutFromTransfersInput, BranchUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFromTransfersInput
    upsert?: BranchUpsertWithoutFromTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFromTransfersInput, BranchUpdateWithoutFromTransfersInput>, BranchUncheckedUpdateWithoutFromTransfersInput>
  }

  export type BranchUpdateOneRequiredWithoutToTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutToTransfersInput, BranchUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutToTransfersInput
    upsert?: BranchUpsertWithoutToTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutToTransfersInput, BranchUpdateWithoutToTransfersInput>, BranchUncheckedUpdateWithoutToTransfersInput>
  }

  export type UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutInitiatedTransfersInput, UserUncheckedCreateWithoutInitiatedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedTransfersInput
    upsert?: UserUpsertWithoutInitiatedTransfersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiatedTransfersInput, UserUpdateWithoutInitiatedTransfersInput>, UserUncheckedUpdateWithoutInitiatedTransfersInput>
  }

  export type UserUpdateOneWithoutApprovedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedTransfersInput
    upsert?: UserUpsertWithoutApprovedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedTransfersInput, UserUpdateWithoutApprovedTransfersInput>, UserUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type TransactionCreateNestedOneWithoutPaymentSchedulesInput = {
    create?: XOR<TransactionCreateWithoutPaymentSchedulesInput, TransactionUncheckedCreateWithoutPaymentSchedulesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentSchedulesInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentScheduleInput = {
    create?: XOR<UserCreateWithoutPaymentScheduleInput, UserUncheckedCreateWithoutPaymentScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentScheduleInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentRepaymentCreateNestedManyWithoutScheduleInput = {
    create?: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput> | PaymentRepaymentCreateWithoutScheduleInput[] | PaymentRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutScheduleInput | PaymentRepaymentCreateOrConnectWithoutScheduleInput[]
    createMany?: PaymentRepaymentCreateManyScheduleInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentCreateNestedManyWithoutScheduleInput = {
    create?: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput> | CreditRepaymentCreateWithoutScheduleInput[] | CreditRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutScheduleInput | CreditRepaymentCreateOrConnectWithoutScheduleInput[]
    createMany?: CreditRepaymentCreateManyScheduleInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type PaymentRepaymentUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput> | PaymentRepaymentCreateWithoutScheduleInput[] | PaymentRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutScheduleInput | PaymentRepaymentCreateOrConnectWithoutScheduleInput[]
    createMany?: PaymentRepaymentCreateManyScheduleInputEnvelope
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
  }

  export type CreditRepaymentUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput> | CreditRepaymentCreateWithoutScheduleInput[] | CreditRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutScheduleInput | CreditRepaymentCreateOrConnectWithoutScheduleInput[]
    createMany?: CreditRepaymentCreateManyScheduleInputEnvelope
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
  }

  export type TransactionUpdateOneRequiredWithoutPaymentSchedulesNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentSchedulesInput, TransactionUncheckedCreateWithoutPaymentSchedulesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentSchedulesInput
    upsert?: TransactionUpsertWithoutPaymentSchedulesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentSchedulesInput, TransactionUpdateWithoutPaymentSchedulesInput>, TransactionUncheckedUpdateWithoutPaymentSchedulesInput>
  }

  export type UserUpdateOneWithoutPaymentScheduleNestedInput = {
    create?: XOR<UserCreateWithoutPaymentScheduleInput, UserUncheckedCreateWithoutPaymentScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentScheduleInput
    upsert?: UserUpsertWithoutPaymentScheduleInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentScheduleInput, UserUpdateWithoutPaymentScheduleInput>, UserUncheckedUpdateWithoutPaymentScheduleInput>
  }

  export type PaymentRepaymentUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput> | PaymentRepaymentCreateWithoutScheduleInput[] | PaymentRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutScheduleInput | PaymentRepaymentCreateOrConnectWithoutScheduleInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutScheduleInput | PaymentRepaymentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: PaymentRepaymentCreateManyScheduleInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutScheduleInput | PaymentRepaymentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutScheduleInput | PaymentRepaymentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput> | CreditRepaymentCreateWithoutScheduleInput[] | CreditRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutScheduleInput | CreditRepaymentCreateOrConnectWithoutScheduleInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutScheduleInput | CreditRepaymentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: CreditRepaymentCreateManyScheduleInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutScheduleInput | CreditRepaymentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutScheduleInput | CreditRepaymentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput> | PaymentRepaymentCreateWithoutScheduleInput[] | PaymentRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: PaymentRepaymentCreateOrConnectWithoutScheduleInput | PaymentRepaymentCreateOrConnectWithoutScheduleInput[]
    upsert?: PaymentRepaymentUpsertWithWhereUniqueWithoutScheduleInput | PaymentRepaymentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: PaymentRepaymentCreateManyScheduleInputEnvelope
    set?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    disconnect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    delete?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    connect?: PaymentRepaymentWhereUniqueInput | PaymentRepaymentWhereUniqueInput[]
    update?: PaymentRepaymentUpdateWithWhereUniqueWithoutScheduleInput | PaymentRepaymentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: PaymentRepaymentUpdateManyWithWhereWithoutScheduleInput | PaymentRepaymentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput> | CreditRepaymentCreateWithoutScheduleInput[] | CreditRepaymentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: CreditRepaymentCreateOrConnectWithoutScheduleInput | CreditRepaymentCreateOrConnectWithoutScheduleInput[]
    upsert?: CreditRepaymentUpsertWithWhereUniqueWithoutScheduleInput | CreditRepaymentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: CreditRepaymentCreateManyScheduleInputEnvelope
    set?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    disconnect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    delete?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    connect?: CreditRepaymentWhereUniqueInput | CreditRepaymentWhereUniqueInput[]
    update?: CreditRepaymentUpdateWithWhereUniqueWithoutScheduleInput | CreditRepaymentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: CreditRepaymentUpdateManyWithWhereWithoutScheduleInput | CreditRepaymentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutPaymentRepaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentRepaymentInput, TransactionUncheckedCreateWithoutPaymentRepaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentRepaymentInput
    connect?: TransactionWhereUniqueInput
  }

  export type PaymentScheduleCreateNestedOneWithoutRepaymentsInput = {
    create?: XOR<PaymentScheduleCreateWithoutRepaymentsInput, PaymentScheduleUncheckedCreateWithoutRepaymentsInput>
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutRepaymentsInput
    connect?: PaymentScheduleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentRepaymentInput = {
    create?: XOR<UserCreateWithoutPaymentRepaymentInput, UserUncheckedCreateWithoutPaymentRepaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentRepaymentInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutPaymentRepaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentRepaymentInput, TransactionUncheckedCreateWithoutPaymentRepaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentRepaymentInput
    upsert?: TransactionUpsertWithoutPaymentRepaymentInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentRepaymentInput, TransactionUpdateWithoutPaymentRepaymentInput>, TransactionUncheckedUpdateWithoutPaymentRepaymentInput>
  }

  export type PaymentScheduleUpdateOneRequiredWithoutRepaymentsNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutRepaymentsInput, PaymentScheduleUncheckedCreateWithoutRepaymentsInput>
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutRepaymentsInput
    upsert?: PaymentScheduleUpsertWithoutRepaymentsInput
    connect?: PaymentScheduleWhereUniqueInput
    update?: XOR<XOR<PaymentScheduleUpdateToOneWithWhereWithoutRepaymentsInput, PaymentScheduleUpdateWithoutRepaymentsInput>, PaymentScheduleUncheckedUpdateWithoutRepaymentsInput>
  }

  export type UserUpdateOneWithoutPaymentRepaymentNestedInput = {
    create?: XOR<UserCreateWithoutPaymentRepaymentInput, UserUncheckedCreateWithoutPaymentRepaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentRepaymentInput
    upsert?: UserUpsertWithoutPaymentRepaymentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentRepaymentInput, UserUpdateWithoutPaymentRepaymentInput>, UserUncheckedUpdateWithoutPaymentRepaymentInput>
  }

  export type TransactionCreateNestedOneWithoutDailyRepaymentsInput = {
    create?: XOR<TransactionCreateWithoutDailyRepaymentsInput, TransactionUncheckedCreateWithoutDailyRepaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDailyRepaymentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDailyRepaymentsInput = {
    create?: XOR<UserCreateWithoutDailyRepaymentsInput, UserUncheckedCreateWithoutDailyRepaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRepaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDailyRepaymentInput = {
    create?: XOR<BranchCreateWithoutDailyRepaymentInput, BranchUncheckedCreateWithoutDailyRepaymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDailyRepaymentInput
    connect?: BranchWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutDailyRepaymentsNestedInput = {
    create?: XOR<TransactionCreateWithoutDailyRepaymentsInput, TransactionUncheckedCreateWithoutDailyRepaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDailyRepaymentsInput
    upsert?: TransactionUpsertWithoutDailyRepaymentsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutDailyRepaymentsInput, TransactionUpdateWithoutDailyRepaymentsInput>, TransactionUncheckedUpdateWithoutDailyRepaymentsInput>
  }

  export type UserUpdateOneWithoutDailyRepaymentsNestedInput = {
    create?: XOR<UserCreateWithoutDailyRepaymentsInput, UserUncheckedCreateWithoutDailyRepaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRepaymentsInput
    upsert?: UserUpsertWithoutDailyRepaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyRepaymentsInput, UserUpdateWithoutDailyRepaymentsInput>, UserUncheckedUpdateWithoutDailyRepaymentsInput>
  }

  export type BranchUpdateOneWithoutDailyRepaymentNestedInput = {
    create?: XOR<BranchCreateWithoutDailyRepaymentInput, BranchUncheckedCreateWithoutDailyRepaymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDailyRepaymentInput
    upsert?: BranchUpsertWithoutDailyRepaymentInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDailyRepaymentInput, BranchUpdateWithoutDailyRepaymentInput>, BranchUncheckedUpdateWithoutDailyRepaymentInput>
  }

  export type TransactionCreateNestedOneWithoutCreditRepaymentsInput = {
    create?: XOR<TransactionCreateWithoutCreditRepaymentsInput, TransactionUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditRepaymentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type PaymentScheduleCreateNestedOneWithoutCreditRepaymentsInput = {
    create?: XOR<PaymentScheduleCreateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutCreditRepaymentsInput
    connect?: PaymentScheduleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreditRepaymentsInput = {
    create?: XOR<UserCreateWithoutCreditRepaymentsInput, UserUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditRepaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutCreditRepaymentInput = {
    create?: XOR<BranchCreateWithoutCreditRepaymentInput, BranchUncheckedCreateWithoutCreditRepaymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCreditRepaymentInput
    connect?: BranchWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutCreditRepaymentsNestedInput = {
    create?: XOR<TransactionCreateWithoutCreditRepaymentsInput, TransactionUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditRepaymentsInput
    upsert?: TransactionUpsertWithoutCreditRepaymentsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutCreditRepaymentsInput, TransactionUpdateWithoutCreditRepaymentsInput>, TransactionUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type PaymentScheduleUpdateOneWithoutCreditRepaymentsNestedInput = {
    create?: XOR<PaymentScheduleCreateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: PaymentScheduleCreateOrConnectWithoutCreditRepaymentsInput
    upsert?: PaymentScheduleUpsertWithoutCreditRepaymentsInput
    disconnect?: PaymentScheduleWhereInput | boolean
    delete?: PaymentScheduleWhereInput | boolean
    connect?: PaymentScheduleWhereUniqueInput
    update?: XOR<XOR<PaymentScheduleUpdateToOneWithWhereWithoutCreditRepaymentsInput, PaymentScheduleUpdateWithoutCreditRepaymentsInput>, PaymentScheduleUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type UserUpdateOneWithoutCreditRepaymentsNestedInput = {
    create?: XOR<UserCreateWithoutCreditRepaymentsInput, UserUncheckedCreateWithoutCreditRepaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditRepaymentsInput
    upsert?: UserUpsertWithoutCreditRepaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditRepaymentsInput, UserUpdateWithoutCreditRepaymentsInput>, UserUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type BranchUpdateOneWithoutCreditRepaymentNestedInput = {
    create?: XOR<BranchCreateWithoutCreditRepaymentInput, BranchUncheckedCreateWithoutCreditRepaymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCreditRepaymentInput
    upsert?: BranchUpsertWithoutCreditRepaymentInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCreditRepaymentInput, BranchUpdateWithoutCreditRepaymentInput>, BranchUncheckedUpdateWithoutCreditRepaymentInput>
  }

  export type UserCreateNestedOneWithoutCashierReportsInput = {
    create?: XOR<UserCreateWithoutCashierReportsInput, UserUncheckedCreateWithoutCashierReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashierReportsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutCashierReportsInput = {
    create?: XOR<BranchCreateWithoutCashierReportsInput, BranchUncheckedCreateWithoutCashierReportsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCashierReportsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCashierReportsNestedInput = {
    create?: XOR<UserCreateWithoutCashierReportsInput, UserUncheckedCreateWithoutCashierReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashierReportsInput
    upsert?: UserUpsertWithoutCashierReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashierReportsInput, UserUpdateWithoutCashierReportsInput>, UserUncheckedUpdateWithoutCashierReportsInput>
  }

  export type BranchUpdateOneRequiredWithoutCashierReportsNestedInput = {
    create?: XOR<BranchCreateWithoutCashierReportsInput, BranchUncheckedCreateWithoutCashierReportsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCashierReportsInput
    upsert?: BranchUpsertWithoutCashierReportsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCashierReportsInput, BranchUpdateWithoutCashierReportsInput>, BranchUncheckedUpdateWithoutCashierReportsInput>
  }

  export type BranchCreateNestedOneWithoutExchangeRatesInput = {
    create?: XOR<BranchCreateWithoutExchangeRatesInput, BranchUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExchangeRatesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExchangeRatesInput = {
    create?: XOR<UserCreateWithoutExchangeRatesInput, UserUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExchangeRatesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneWithoutExchangeRatesNestedInput = {
    create?: XOR<BranchCreateWithoutExchangeRatesInput, BranchUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExchangeRatesInput
    upsert?: BranchUpsertWithoutExchangeRatesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutExchangeRatesInput, BranchUpdateWithoutExchangeRatesInput>, BranchUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type UserUpdateOneWithoutExchangeRatesNestedInput = {
    create?: XOR<UserCreateWithoutExchangeRatesInput, UserUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExchangeRatesInput
    upsert?: UserUpsertWithoutExchangeRatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExchangeRatesInput, UserUpdateWithoutExchangeRatesInput>, UserUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type UserCreateNestedOneWithoutBonusesInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedBonusesInput = {
    create?: XOR<UserCreateWithoutCreatedBonusesInput, UserUncheckedCreateWithoutCreatedBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutBonusesInput = {
    create?: XOR<BranchCreateWithoutBonusesInput, BranchUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBonusesInput
    connect?: BranchWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutBonusesInput = {
    create?: XOR<TransactionCreateWithoutBonusesInput, TransactionUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBonusesInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBonusesNestedInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    upsert?: UserUpsertWithoutBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBonusesInput, UserUpdateWithoutBonusesInput>, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedBonusesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBonusesInput, UserUncheckedCreateWithoutCreatedBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBonusesInput
    upsert?: UserUpsertWithoutCreatedBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBonusesInput, UserUpdateWithoutCreatedBonusesInput>, UserUncheckedUpdateWithoutCreatedBonusesInput>
  }

  export type BranchUpdateOneWithoutBonusesNestedInput = {
    create?: XOR<BranchCreateWithoutBonusesInput, BranchUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBonusesInput
    upsert?: BranchUpsertWithoutBonusesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBonusesInput, BranchUpdateWithoutBonusesInput>, BranchUncheckedUpdateWithoutBonusesInput>
  }

  export type TransactionUpdateOneWithoutBonusesNestedInput = {
    create?: XOR<TransactionCreateWithoutBonusesInput, TransactionUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBonusesInput
    upsert?: TransactionUpsertWithoutBonusesInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutBonusesInput, TransactionUpdateWithoutBonusesInput>, TransactionUncheckedUpdateWithoutBonusesInput>
  }

  export type TransactionCreateNestedOneWithoutBonusProductsInput = {
    create?: XOR<TransactionCreateWithoutBonusProductsInput, TransactionUncheckedCreateWithoutBonusProductsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBonusProductsInput
    connect?: TransactionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBonusProductsInput = {
    create?: XOR<ProductCreateWithoutBonusProductsInput, ProductUncheckedCreateWithoutBonusProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBonusProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutBonusProductsNestedInput = {
    create?: XOR<TransactionCreateWithoutBonusProductsInput, TransactionUncheckedCreateWithoutBonusProductsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBonusProductsInput
    upsert?: TransactionUpsertWithoutBonusProductsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutBonusProductsInput, TransactionUpdateWithoutBonusProductsInput>, TransactionUncheckedUpdateWithoutBonusProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutBonusProductsNestedInput = {
    create?: XOR<ProductCreateWithoutBonusProductsInput, ProductUncheckedCreateWithoutBonusProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBonusProductsInput
    upsert?: ProductUpsertWithoutBonusProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBonusProductsInput, ProductUpdateWithoutBonusProductsInput>, ProductUncheckedUpdateWithoutBonusProductsInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserCreateNestedOneWithoutFaceTemplatesInput = {
    create?: XOR<UserCreateWithoutFaceTemplatesInput, UserUncheckedCreateWithoutFaceTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFaceTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFaceTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutFaceTemplatesInput, UserUncheckedCreateWithoutFaceTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFaceTemplatesInput
    upsert?: UserUpsertWithoutFaceTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFaceTemplatesInput, UserUpdateWithoutFaceTemplatesInput>, UserUncheckedUpdateWithoutFaceTemplatesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAttendanceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel> | $Enums.AttendanceStatus | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttendanceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceEventType | EnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceEventTypeFilter<$PrismaModel> | $Enums.AttendanceEventType
  }

  export type NestedEnumAttendanceEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceEventType | EnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceEventType[] | ListEnumAttendanceEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceEventTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceEventTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type NestedEnumBranchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchStatus | EnumBranchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchStatusFilter<$PrismaModel> | $Enums.BranchStatus
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBranchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchStatus | EnumBranchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchStatus[] | ListEnumBranchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BranchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchStatusFilter<$PrismaModel>
    _max?: NestedEnumBranchStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedEnumProductSizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductSizeType | EnumProductSizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductSizeTypeFilter<$PrismaModel> | $Enums.ProductSizeType
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumProductSizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductSizeType | EnumProductSizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductSizeType[] | ListEnumProductSizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductSizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductSizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductSizeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductSizeTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumPaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeNullableFilter<$PrismaModel> | $Enums.PaymentType | null
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutAttendanceDaysInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAttendanceDaysInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAttendanceDaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
  }

  export type BranchCreateWithoutAttendanceDaysInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAttendanceDaysInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAttendanceDaysInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAttendanceDaysInput, BranchUncheckedCreateWithoutAttendanceDaysInput>
  }

  export type AttendanceEventCreateWithoutDayInput = {
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceEventsInput
    branch?: BranchCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutDayInput = {
    id?: number
    userId: number
    branchId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventCreateOrConnectWithoutDayInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput>
  }

  export type AttendanceEventCreateManyDayInputEnvelope = {
    data: AttendanceEventCreateManyDayInput | AttendanceEventCreateManyDayInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAttendanceDaysInput = {
    update: XOR<UserUpdateWithoutAttendanceDaysInput, UserUncheckedUpdateWithoutAttendanceDaysInput>
    create: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceDaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceDaysInput, UserUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type UserUpdateWithoutAttendanceDaysInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutAttendanceDaysInput = {
    update: XOR<BranchUpdateWithoutAttendanceDaysInput, BranchUncheckedUpdateWithoutAttendanceDaysInput>
    create: XOR<BranchCreateWithoutAttendanceDaysInput, BranchUncheckedCreateWithoutAttendanceDaysInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAttendanceDaysInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAttendanceDaysInput, BranchUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type BranchUpdateWithoutAttendanceDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAttendanceDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutDayInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutDayInput, AttendanceEventUncheckedUpdateWithoutDayInput>
    create: XOR<AttendanceEventCreateWithoutDayInput, AttendanceEventUncheckedCreateWithoutDayInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutDayInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutDayInput, AttendanceEventUncheckedUpdateWithoutDayInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutDayInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutDayInput>
  }

  export type AttendanceEventScalarWhereInput = {
    AND?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    OR?: AttendanceEventScalarWhereInput[]
    NOT?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    id?: IntFilter<"AttendanceEvent"> | number
    userId?: IntFilter<"AttendanceEvent"> | number
    branchId?: IntNullableFilter<"AttendanceEvent"> | number | null
    dayId?: IntNullableFilter<"AttendanceEvent"> | number | null
    eventType?: EnumAttendanceEventTypeFilter<"AttendanceEvent"> | $Enums.AttendanceEventType
    occurredAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    similarity?: FloatNullableFilter<"AttendanceEvent"> | number | null
    payload?: JsonNullableFilter<"AttendanceEvent">
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
  }

  export type UserCreateWithoutAttendanceEventsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAttendanceEventsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAttendanceEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type BranchCreateWithoutAttendanceEventsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAttendanceEventsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAttendanceEventsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAttendanceEventsInput, BranchUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type AttendanceDayCreateWithoutEventsInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceDaysInput
    branch?: BranchCreateNestedOneWithoutAttendanceDaysInput
  }

  export type AttendanceDayUncheckedCreateWithoutEventsInput = {
    id?: number
    userId: number
    branchId?: number | null
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceDayCreateOrConnectWithoutEventsInput = {
    where: AttendanceDayWhereUniqueInput
    create: XOR<AttendanceDayCreateWithoutEventsInput, AttendanceDayUncheckedCreateWithoutEventsInput>
  }

  export type UserUpsertWithoutAttendanceEventsInput = {
    update: XOR<UserUpdateWithoutAttendanceEventsInput, UserUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceEventsInput, UserUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type UserUpdateWithoutAttendanceEventsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutAttendanceEventsInput = {
    update: XOR<BranchUpdateWithoutAttendanceEventsInput, BranchUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<BranchCreateWithoutAttendanceEventsInput, BranchUncheckedCreateWithoutAttendanceEventsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAttendanceEventsInput, BranchUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type BranchUpdateWithoutAttendanceEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AttendanceDayUpsertWithoutEventsInput = {
    update: XOR<AttendanceDayUpdateWithoutEventsInput, AttendanceDayUncheckedUpdateWithoutEventsInput>
    create: XOR<AttendanceDayCreateWithoutEventsInput, AttendanceDayUncheckedCreateWithoutEventsInput>
    where?: AttendanceDayWhereInput
  }

  export type AttendanceDayUpdateToOneWithWhereWithoutEventsInput = {
    where?: AttendanceDayWhereInput
    data: XOR<AttendanceDayUpdateWithoutEventsInput, AttendanceDayUncheckedUpdateWithoutEventsInput>
  }

  export type AttendanceDayUpdateWithoutEventsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceDaysNestedInput
    branch?: BranchUpdateOneWithoutAttendanceDaysNestedInput
  }

  export type AttendanceDayUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutBranchInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    category: CategoryCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBranchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductCreateManyBranchInputEnvelope = {
    data: ProductCreateManyBranchInput | ProductCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutFromBranchInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutFromBranchInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutFromBranchInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput>
  }

  export type TransactionCreateManyFromBranchInputEnvelope = {
    data: TransactionCreateManyFromBranchInput | TransactionCreateManyFromBranchInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutToBranchInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutToBranchInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutToBranchInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput>
  }

  export type TransactionCreateManyToBranchInputEnvelope = {
    data: TransactionCreateManyToBranchInput | TransactionCreateManyToBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBranchInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserBranchAccessCreateWithoutBranchInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllowedBranchesInput
  }

  export type UserBranchAccessUncheckedCreateWithoutBranchInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBranchAccessCreateOrConnectWithoutBranchInput = {
    where: UserBranchAccessWhereUniqueInput
    create: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput>
  }

  export type UserBranchAccessCreateManyBranchInputEnvelope = {
    data: UserBranchAccessCreateManyBranchInput | UserBranchAccessCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutBranchInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBranchInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput>
  }

  export type CategoryCreateManyBranchInputEnvelope = {
    data: CategoryCreateManyBranchInput | CategoryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransferCreateWithoutFromBranchInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductTransferInput
    toBranch: BranchCreateNestedOneWithoutToTransfersInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
  }

  export type ProductTransferUncheckedCreateWithoutFromBranchInput = {
    id?: number
    productId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateOrConnectWithoutFromBranchInput = {
    where: ProductTransferWhereUniqueInput
    create: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput>
  }

  export type ProductTransferCreateManyFromBranchInputEnvelope = {
    data: ProductTransferCreateManyFromBranchInput | ProductTransferCreateManyFromBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransferCreateWithoutToBranchInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductTransferInput
    fromBranch: BranchCreateNestedOneWithoutFromTransfersInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
  }

  export type ProductTransferUncheckedCreateWithoutToBranchInput = {
    id?: number
    productId: number
    fromBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateOrConnectWithoutToBranchInput = {
    where: ProductTransferWhereUniqueInput
    create: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput>
  }

  export type ProductTransferCreateManyToBranchInputEnvelope = {
    data: ProductTransferCreateManyToBranchInput | ProductTransferCreateManyToBranchInput[]
    skipDuplicates?: boolean
  }

  export type DefectiveLogCreateWithoutBranchInput = {
    quantity: number
    description: string
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
    product: ProductCreateNestedOneWithoutDefectiveLogInput
    user?: UserCreateNestedOneWithoutDefectiveLogsInput
  }

  export type DefectiveLogUncheckedCreateWithoutBranchInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    userId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type DefectiveLogCreateOrConnectWithoutBranchInput = {
    where: DefectiveLogWhereUniqueInput
    create: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput>
  }

  export type DefectiveLogCreateManyBranchInputEnvelope = {
    data: DefectiveLogCreateManyBranchInput | DefectiveLogCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CurrencyExchangeRateCreateWithoutBranchInput = {
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutExchangeRatesInput
  }

  export type CurrencyExchangeRateUncheckedCreateWithoutBranchInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyExchangeRateCreateOrConnectWithoutBranchInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    create: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput>
  }

  export type CurrencyExchangeRateCreateManyBranchInputEnvelope = {
    data: CurrencyExchangeRateCreateManyBranchInput | CurrencyExchangeRateCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CashierReportCreateWithoutBranchInput = {
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutCashierReportsInput
  }

  export type CashierReportUncheckedCreateWithoutBranchInput = {
    id?: number
    cashierId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierReportCreateOrConnectWithoutBranchInput = {
    where: CashierReportWhereUniqueInput
    create: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput>
  }

  export type CashierReportCreateManyBranchInputEnvelope = {
    data: CashierReportCreateManyBranchInput | CashierReportCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DailyRepaymentCreateWithoutBranchInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutDailyRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutDailyRepaymentsInput
  }

  export type DailyRepaymentUncheckedCreateWithoutBranchInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentCreateOrConnectWithoutBranchInput = {
    where: DailyRepaymentWhereUniqueInput
    create: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput>
  }

  export type DailyRepaymentCreateManyBranchInputEnvelope = {
    data: DailyRepaymentCreateManyBranchInput | DailyRepaymentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CreditRepaymentCreateWithoutBranchInput = {
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutCreditRepaymentsInput
    schedule?: PaymentScheduleCreateNestedOneWithoutCreditRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutCreditRepaymentsInput
  }

  export type CreditRepaymentUncheckedCreateWithoutBranchInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateOrConnectWithoutBranchInput = {
    where: CreditRepaymentWhereUniqueInput
    create: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput>
  }

  export type CreditRepaymentCreateManyBranchInputEnvelope = {
    data: CreditRepaymentCreateManyBranchInput | CreditRepaymentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BonusCreateWithoutBranchInput = {
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
    createdBy: UserCreateNestedOneWithoutCreatedBonusesInput
    transaction?: TransactionCreateNestedOneWithoutBonusesInput
  }

  export type BonusUncheckedCreateWithoutBranchInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateOrConnectWithoutBranchInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput>
  }

  export type BonusCreateManyBranchInputEnvelope = {
    data: BonusCreateManyBranchInput | BonusCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDayCreateWithoutBranchInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceDaysInput
    events?: AttendanceEventCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayUncheckedCreateWithoutBranchInput = {
    id?: number
    userId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: AttendanceEventUncheckedCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayCreateOrConnectWithoutBranchInput = {
    where: AttendanceDayWhereUniqueInput
    create: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput>
  }

  export type AttendanceDayCreateManyBranchInputEnvelope = {
    data: AttendanceDayCreateManyBranchInput | AttendanceDayCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutBranchInput = {
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceEventsInput
    day?: AttendanceDayCreateNestedOneWithoutEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutBranchInput = {
    id?: number
    userId: number
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventCreateOrConnectWithoutBranchInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput>
  }

  export type AttendanceEventCreateManyBranchInputEnvelope = {
    data: AttendanceEventCreateManyBranchInput | AttendanceEventCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
  }

  export type ProductUpdateManyWithWhereWithoutBranchInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    defectiveQuantity?: IntFilter<"Product"> | number
    returnedQuantity?: IntFilter<"Product"> | number
    exchangedQuantity?: IntFilter<"Product"> | number
    initialQuantity?: IntFilter<"Product"> | number
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    marketPrice?: FloatNullableFilter<"Product"> | number | null
    bonusPercentage?: FloatNullableFilter<"Product"> | number | null
    isDeleted?: BoolFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    sizeType?: EnumProductSizeTypeFilter<"Product"> | $Enums.ProductSizeType
    sizeLabel?: StringNullableFilter<"Product"> | string | null
    sizeNumber?: FloatNullableFilter<"Product"> | number | null
    areaSqm?: FloatNullableFilter<"Product"> | number | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutFromBranchInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFromBranchInput, TransactionUncheckedUpdateWithoutFromBranchInput>
    create: XOR<TransactionCreateWithoutFromBranchInput, TransactionUncheckedCreateWithoutFromBranchInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFromBranchInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFromBranchInput, TransactionUncheckedUpdateWithoutFromBranchInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFromBranchInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFromBranchInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    customerId?: IntNullableFilter<"Transaction"> | number | null
    userId?: IntNullableFilter<"Transaction"> | number | null
    soldByUserId?: IntNullableFilter<"Transaction"> | number | null
    fromBranchId?: IntNullableFilter<"Transaction"> | number | null
    toBranchId?: IntNullableFilter<"Transaction"> | number | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transactionType?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    finalTotal?: FloatFilter<"Transaction"> | number
    paymentType?: EnumPaymentTypeNullableFilter<"Transaction"> | $Enums.PaymentType | null
    upfrontPaymentType?: StringNullableFilter<"Transaction"> | string | null
    termUnit?: StringNullableFilter<"Transaction"> | string | null
    deliveryMethod?: StringNullableFilter<"Transaction"> | string | null
    deliveryType?: StringNullableFilter<"Transaction"> | string | null
    deliveryAddress?: StringNullableFilter<"Transaction"> | string | null
    amountPaid?: FloatNullableFilter<"Transaction"> | number | null
    downPayment?: FloatNullableFilter<"Transaction"> | number | null
    remainingBalance?: FloatNullableFilter<"Transaction"> | number | null
    receiptId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: IntNullableFilter<"Transaction"> | number | null
    creditRepaymentAmount?: FloatNullableFilter<"Transaction"> | number | null
    lastRepaymentDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    extraProfit?: FloatNullableFilter<"Transaction"> | number | null
    days?: IntNullableFilter<"Transaction"> | number | null
    months?: IntNullableFilter<"Transaction"> | number | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutToBranchInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutToBranchInput, TransactionUncheckedUpdateWithoutToBranchInput>
    create: XOR<TransactionCreateWithoutToBranchInput, TransactionUncheckedCreateWithoutToBranchInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutToBranchInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutToBranchInput, TransactionUncheckedUpdateWithoutToBranchInput>
  }

  export type TransactionUpdateManyWithWhereWithoutToBranchInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutToBranchInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    workStartTime?: StringNullableFilter<"User"> | string | null
    workEndTime?: StringNullableFilter<"User"> | string | null
    workShift?: StringNullableFilter<"User"> | string | null
  }

  export type UserBranchAccessUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserBranchAccessWhereUniqueInput
    update: XOR<UserBranchAccessUpdateWithoutBranchInput, UserBranchAccessUncheckedUpdateWithoutBranchInput>
    create: XOR<UserBranchAccessCreateWithoutBranchInput, UserBranchAccessUncheckedCreateWithoutBranchInput>
  }

  export type UserBranchAccessUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserBranchAccessWhereUniqueInput
    data: XOR<UserBranchAccessUpdateWithoutBranchInput, UserBranchAccessUncheckedUpdateWithoutBranchInput>
  }

  export type UserBranchAccessUpdateManyWithWhereWithoutBranchInput = {
    where: UserBranchAccessScalarWhereInput
    data: XOR<UserBranchAccessUpdateManyMutationInput, UserBranchAccessUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserBranchAccessScalarWhereInput = {
    AND?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
    OR?: UserBranchAccessScalarWhereInput[]
    NOT?: UserBranchAccessScalarWhereInput | UserBranchAccessScalarWhereInput[]
    id?: IntFilter<"UserBranchAccess"> | number
    userId?: IntFilter<"UserBranchAccess"> | number
    branchId?: IntFilter<"UserBranchAccess"> | number
    createdAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserBranchAccess"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutBranchInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutBranchInput, CategoryUncheckedUpdateWithoutBranchInput>
    create: XOR<CategoryCreateWithoutBranchInput, CategoryUncheckedCreateWithoutBranchInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutBranchInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutBranchInput, CategoryUncheckedUpdateWithoutBranchInput>
  }

  export type CategoryUpdateManyWithWhereWithoutBranchInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutBranchInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    branchId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type ProductTransferUpsertWithWhereUniqueWithoutFromBranchInput = {
    where: ProductTransferWhereUniqueInput
    update: XOR<ProductTransferUpdateWithoutFromBranchInput, ProductTransferUncheckedUpdateWithoutFromBranchInput>
    create: XOR<ProductTransferCreateWithoutFromBranchInput, ProductTransferUncheckedCreateWithoutFromBranchInput>
  }

  export type ProductTransferUpdateWithWhereUniqueWithoutFromBranchInput = {
    where: ProductTransferWhereUniqueInput
    data: XOR<ProductTransferUpdateWithoutFromBranchInput, ProductTransferUncheckedUpdateWithoutFromBranchInput>
  }

  export type ProductTransferUpdateManyWithWhereWithoutFromBranchInput = {
    where: ProductTransferScalarWhereInput
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyWithoutFromBranchInput>
  }

  export type ProductTransferScalarWhereInput = {
    AND?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
    OR?: ProductTransferScalarWhereInput[]
    NOT?: ProductTransferScalarWhereInput | ProductTransferScalarWhereInput[]
    id?: IntFilter<"ProductTransfer"> | number
    productId?: IntFilter<"ProductTransfer"> | number
    fromBranchId?: IntFilter<"ProductTransfer"> | number
    toBranchId?: IntFilter<"ProductTransfer"> | number
    quantity?: IntFilter<"ProductTransfer"> | number
    status?: EnumTransferStatusFilter<"ProductTransfer"> | $Enums.TransferStatus
    initiatedById?: IntFilter<"ProductTransfer"> | number
    approvedById?: IntNullableFilter<"ProductTransfer"> | number | null
    transferDate?: DateTimeFilter<"ProductTransfer"> | Date | string
    createdAt?: DateTimeFilter<"ProductTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTransfer"> | Date | string
  }

  export type ProductTransferUpsertWithWhereUniqueWithoutToBranchInput = {
    where: ProductTransferWhereUniqueInput
    update: XOR<ProductTransferUpdateWithoutToBranchInput, ProductTransferUncheckedUpdateWithoutToBranchInput>
    create: XOR<ProductTransferCreateWithoutToBranchInput, ProductTransferUncheckedCreateWithoutToBranchInput>
  }

  export type ProductTransferUpdateWithWhereUniqueWithoutToBranchInput = {
    where: ProductTransferWhereUniqueInput
    data: XOR<ProductTransferUpdateWithoutToBranchInput, ProductTransferUncheckedUpdateWithoutToBranchInput>
  }

  export type ProductTransferUpdateManyWithWhereWithoutToBranchInput = {
    where: ProductTransferScalarWhereInput
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyWithoutToBranchInput>
  }

  export type DefectiveLogUpsertWithWhereUniqueWithoutBranchInput = {
    where: DefectiveLogWhereUniqueInput
    update: XOR<DefectiveLogUpdateWithoutBranchInput, DefectiveLogUncheckedUpdateWithoutBranchInput>
    create: XOR<DefectiveLogCreateWithoutBranchInput, DefectiveLogUncheckedCreateWithoutBranchInput>
  }

  export type DefectiveLogUpdateWithWhereUniqueWithoutBranchInput = {
    where: DefectiveLogWhereUniqueInput
    data: XOR<DefectiveLogUpdateWithoutBranchInput, DefectiveLogUncheckedUpdateWithoutBranchInput>
  }

  export type DefectiveLogUpdateManyWithWhereWithoutBranchInput = {
    where: DefectiveLogScalarWhereInput
    data: XOR<DefectiveLogUpdateManyMutationInput, DefectiveLogUncheckedUpdateManyWithoutBranchInput>
  }

  export type DefectiveLogScalarWhereInput = {
    AND?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
    OR?: DefectiveLogScalarWhereInput[]
    NOT?: DefectiveLogScalarWhereInput | DefectiveLogScalarWhereInput[]
    id?: IntFilter<"DefectiveLog"> | number
    productId?: IntFilter<"DefectiveLog"> | number
    quantity?: IntFilter<"DefectiveLog"> | number
    description?: StringFilter<"DefectiveLog"> | string
    userId?: IntNullableFilter<"DefectiveLog"> | number | null
    branchId?: IntNullableFilter<"DefectiveLog"> | number | null
    cashAmount?: FloatFilter<"DefectiveLog"> | number
    actionType?: StringFilter<"DefectiveLog"> | string
    createdAt?: DateTimeFilter<"DefectiveLog"> | Date | string
    exchangeWithProductId?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementQuantity?: IntNullableFilter<"DefectiveLog"> | number | null
    replacementUnitPrice?: FloatNullableFilter<"DefectiveLog"> | number | null
    replacementTransactionId?: IntNullableFilter<"DefectiveLog"> | number | null
  }

  export type CurrencyExchangeRateUpsertWithWhereUniqueWithoutBranchInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    update: XOR<CurrencyExchangeRateUpdateWithoutBranchInput, CurrencyExchangeRateUncheckedUpdateWithoutBranchInput>
    create: XOR<CurrencyExchangeRateCreateWithoutBranchInput, CurrencyExchangeRateUncheckedCreateWithoutBranchInput>
  }

  export type CurrencyExchangeRateUpdateWithWhereUniqueWithoutBranchInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    data: XOR<CurrencyExchangeRateUpdateWithoutBranchInput, CurrencyExchangeRateUncheckedUpdateWithoutBranchInput>
  }

  export type CurrencyExchangeRateUpdateManyWithWhereWithoutBranchInput = {
    where: CurrencyExchangeRateScalarWhereInput
    data: XOR<CurrencyExchangeRateUpdateManyMutationInput, CurrencyExchangeRateUncheckedUpdateManyWithoutBranchInput>
  }

  export type CurrencyExchangeRateScalarWhereInput = {
    AND?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
    OR?: CurrencyExchangeRateScalarWhereInput[]
    NOT?: CurrencyExchangeRateScalarWhereInput | CurrencyExchangeRateScalarWhereInput[]
    id?: IntFilter<"CurrencyExchangeRate"> | number
    fromCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    toCurrency?: StringFilter<"CurrencyExchangeRate"> | string
    rate?: FloatFilter<"CurrencyExchangeRate"> | number
    isActive?: BoolFilter<"CurrencyExchangeRate"> | boolean
    branchId?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdBy?: IntNullableFilter<"CurrencyExchangeRate"> | number | null
    createdAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
    updatedAt?: DateTimeFilter<"CurrencyExchangeRate"> | Date | string
  }

  export type CashierReportUpsertWithWhereUniqueWithoutBranchInput = {
    where: CashierReportWhereUniqueInput
    update: XOR<CashierReportUpdateWithoutBranchInput, CashierReportUncheckedUpdateWithoutBranchInput>
    create: XOR<CashierReportCreateWithoutBranchInput, CashierReportUncheckedCreateWithoutBranchInput>
  }

  export type CashierReportUpdateWithWhereUniqueWithoutBranchInput = {
    where: CashierReportWhereUniqueInput
    data: XOR<CashierReportUpdateWithoutBranchInput, CashierReportUncheckedUpdateWithoutBranchInput>
  }

  export type CashierReportUpdateManyWithWhereWithoutBranchInput = {
    where: CashierReportScalarWhereInput
    data: XOR<CashierReportUpdateManyMutationInput, CashierReportUncheckedUpdateManyWithoutBranchInput>
  }

  export type CashierReportScalarWhereInput = {
    AND?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
    OR?: CashierReportScalarWhereInput[]
    NOT?: CashierReportScalarWhereInput | CashierReportScalarWhereInput[]
    id?: IntFilter<"CashierReport"> | number
    cashierId?: IntFilter<"CashierReport"> | number
    branchId?: IntFilter<"CashierReport"> | number
    reportDate?: DateTimeFilter<"CashierReport"> | Date | string
    cashTotal?: FloatFilter<"CashierReport"> | number
    cardTotal?: FloatFilter<"CashierReport"> | number
    creditTotal?: FloatFilter<"CashierReport"> | number
    installmentTotal?: FloatFilter<"CashierReport"> | number
    upfrontTotal?: FloatFilter<"CashierReport"> | number
    upfrontCash?: FloatFilter<"CashierReport"> | number
    upfrontCard?: FloatFilter<"CashierReport"> | number
    soldQuantity?: IntFilter<"CashierReport"> | number
    soldAmount?: FloatFilter<"CashierReport"> | number
    repaymentTotal?: FloatFilter<"CashierReport"> | number
    defectivePlus?: FloatFilter<"CashierReport"> | number
    defectiveMinus?: FloatFilter<"CashierReport"> | number
    createdAt?: DateTimeFilter<"CashierReport"> | Date | string
    updatedAt?: DateTimeFilter<"CashierReport"> | Date | string
  }

  export type DailyRepaymentUpsertWithWhereUniqueWithoutBranchInput = {
    where: DailyRepaymentWhereUniqueInput
    update: XOR<DailyRepaymentUpdateWithoutBranchInput, DailyRepaymentUncheckedUpdateWithoutBranchInput>
    create: XOR<DailyRepaymentCreateWithoutBranchInput, DailyRepaymentUncheckedCreateWithoutBranchInput>
  }

  export type DailyRepaymentUpdateWithWhereUniqueWithoutBranchInput = {
    where: DailyRepaymentWhereUniqueInput
    data: XOR<DailyRepaymentUpdateWithoutBranchInput, DailyRepaymentUncheckedUpdateWithoutBranchInput>
  }

  export type DailyRepaymentUpdateManyWithWhereWithoutBranchInput = {
    where: DailyRepaymentScalarWhereInput
    data: XOR<DailyRepaymentUpdateManyMutationInput, DailyRepaymentUncheckedUpdateManyWithoutBranchInput>
  }

  export type DailyRepaymentScalarWhereInput = {
    AND?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
    OR?: DailyRepaymentScalarWhereInput[]
    NOT?: DailyRepaymentScalarWhereInput | DailyRepaymentScalarWhereInput[]
    id?: IntFilter<"DailyRepayment"> | number
    transactionId?: IntFilter<"DailyRepayment"> | number
    amount?: FloatFilter<"DailyRepayment"> | number
    channel?: StringFilter<"DailyRepayment"> | string
    paidAt?: DateTimeFilter<"DailyRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"DailyRepayment"> | number | null
    branchId?: IntNullableFilter<"DailyRepayment"> | number | null
    createdAt?: DateTimeFilter<"DailyRepayment"> | Date | string
  }

  export type CreditRepaymentUpsertWithWhereUniqueWithoutBranchInput = {
    where: CreditRepaymentWhereUniqueInput
    update: XOR<CreditRepaymentUpdateWithoutBranchInput, CreditRepaymentUncheckedUpdateWithoutBranchInput>
    create: XOR<CreditRepaymentCreateWithoutBranchInput, CreditRepaymentUncheckedCreateWithoutBranchInput>
  }

  export type CreditRepaymentUpdateWithWhereUniqueWithoutBranchInput = {
    where: CreditRepaymentWhereUniqueInput
    data: XOR<CreditRepaymentUpdateWithoutBranchInput, CreditRepaymentUncheckedUpdateWithoutBranchInput>
  }

  export type CreditRepaymentUpdateManyWithWhereWithoutBranchInput = {
    where: CreditRepaymentScalarWhereInput
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyWithoutBranchInput>
  }

  export type CreditRepaymentScalarWhereInput = {
    AND?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
    OR?: CreditRepaymentScalarWhereInput[]
    NOT?: CreditRepaymentScalarWhereInput | CreditRepaymentScalarWhereInput[]
    id?: IntFilter<"CreditRepayment"> | number
    transactionId?: IntFilter<"CreditRepayment"> | number
    scheduleId?: IntNullableFilter<"CreditRepayment"> | number | null
    amount?: FloatFilter<"CreditRepayment"> | number
    channel?: StringFilter<"CreditRepayment"> | string
    month?: StringNullableFilter<"CreditRepayment"> | string | null
    monthNumber?: IntNullableFilter<"CreditRepayment"> | number | null
    paidAt?: DateTimeFilter<"CreditRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"CreditRepayment"> | number | null
    branchId?: IntNullableFilter<"CreditRepayment"> | number | null
    createdAt?: DateTimeFilter<"CreditRepayment"> | Date | string
  }

  export type BonusUpsertWithWhereUniqueWithoutBranchInput = {
    where: BonusWhereUniqueInput
    update: XOR<BonusUpdateWithoutBranchInput, BonusUncheckedUpdateWithoutBranchInput>
    create: XOR<BonusCreateWithoutBranchInput, BonusUncheckedCreateWithoutBranchInput>
  }

  export type BonusUpdateWithWhereUniqueWithoutBranchInput = {
    where: BonusWhereUniqueInput
    data: XOR<BonusUpdateWithoutBranchInput, BonusUncheckedUpdateWithoutBranchInput>
  }

  export type BonusUpdateManyWithWhereWithoutBranchInput = {
    where: BonusScalarWhereInput
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyWithoutBranchInput>
  }

  export type BonusScalarWhereInput = {
    AND?: BonusScalarWhereInput | BonusScalarWhereInput[]
    OR?: BonusScalarWhereInput[]
    NOT?: BonusScalarWhereInput | BonusScalarWhereInput[]
    id?: IntFilter<"Bonus"> | number
    userId?: IntFilter<"Bonus"> | number
    amount?: FloatFilter<"Bonus"> | number
    reason?: StringFilter<"Bonus"> | string
    description?: StringNullableFilter<"Bonus"> | string | null
    bonusProducts?: JsonNullableFilter<"Bonus">
    bonusDate?: DateTimeFilter<"Bonus"> | Date | string
    createdById?: IntFilter<"Bonus"> | number
    branchId?: IntNullableFilter<"Bonus"> | number | null
    transactionId?: IntNullableFilter<"Bonus"> | number | null
    createdAt?: DateTimeFilter<"Bonus"> | Date | string
    updatedAt?: DateTimeFilter<"Bonus"> | Date | string
  }

  export type AttendanceDayUpsertWithWhereUniqueWithoutBranchInput = {
    where: AttendanceDayWhereUniqueInput
    update: XOR<AttendanceDayUpdateWithoutBranchInput, AttendanceDayUncheckedUpdateWithoutBranchInput>
    create: XOR<AttendanceDayCreateWithoutBranchInput, AttendanceDayUncheckedCreateWithoutBranchInput>
  }

  export type AttendanceDayUpdateWithWhereUniqueWithoutBranchInput = {
    where: AttendanceDayWhereUniqueInput
    data: XOR<AttendanceDayUpdateWithoutBranchInput, AttendanceDayUncheckedUpdateWithoutBranchInput>
  }

  export type AttendanceDayUpdateManyWithWhereWithoutBranchInput = {
    where: AttendanceDayScalarWhereInput
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyWithoutBranchInput>
  }

  export type AttendanceDayScalarWhereInput = {
    AND?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
    OR?: AttendanceDayScalarWhereInput[]
    NOT?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
    id?: IntFilter<"AttendanceDay"> | number
    userId?: IntFilter<"AttendanceDay"> | number
    branchId?: IntNullableFilter<"AttendanceDay"> | number | null
    date?: DateTimeFilter<"AttendanceDay"> | Date | string
    checkInAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"AttendanceDay"> | Date | string | null
    totalMinutes?: IntNullableFilter<"AttendanceDay"> | number | null
    status?: EnumAttendanceStatusNullableFilter<"AttendanceDay"> | $Enums.AttendanceStatus | null
    deviceId?: StringNullableFilter<"AttendanceDay"> | string | null
    notes?: StringNullableFilter<"AttendanceDay"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutBranchInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutBranchInput, AttendanceEventUncheckedUpdateWithoutBranchInput>
    create: XOR<AttendanceEventCreateWithoutBranchInput, AttendanceEventUncheckedCreateWithoutBranchInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutBranchInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutBranchInput, AttendanceEventUncheckedUpdateWithoutBranchInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutBranchInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserBranchAccessCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAllowedUsersInput
  }

  export type UserBranchAccessUncheckedCreateWithoutUserInput = {
    id?: number
    branchId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBranchAccessCreateOrConnectWithoutUserInput = {
    where: UserBranchAccessWhereUniqueInput
    create: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput>
  }

  export type UserBranchAccessCreateManyUserInputEnvelope = {
    data: UserBranchAccessCreateManyUserInput | UserBranchAccessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutUsersInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type TransactionCreateWithoutUserInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    customerId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutSoldByInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSoldByInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutSoldByInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput>
  }

  export type TransactionCreateManySoldByInputEnvelope = {
    data: TransactionCreateManySoldByInput | TransactionCreateManySoldByInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransferCreateWithoutInitiatedByInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductTransferInput
    fromBranch: BranchCreateNestedOneWithoutFromTransfersInput
    toBranch: BranchCreateNestedOneWithoutToTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
  }

  export type ProductTransferUncheckedCreateWithoutInitiatedByInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateOrConnectWithoutInitiatedByInput = {
    where: ProductTransferWhereUniqueInput
    create: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput>
  }

  export type ProductTransferCreateManyInitiatedByInputEnvelope = {
    data: ProductTransferCreateManyInitiatedByInput | ProductTransferCreateManyInitiatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransferCreateWithoutApprovedByInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductTransferInput
    fromBranch: BranchCreateNestedOneWithoutFromTransfersInput
    toBranch: BranchCreateNestedOneWithoutToTransfersInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedTransfersInput
  }

  export type ProductTransferUncheckedCreateWithoutApprovedByInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateOrConnectWithoutApprovedByInput = {
    where: ProductTransferWhereUniqueInput
    create: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput>
  }

  export type ProductTransferCreateManyApprovedByInputEnvelope = {
    data: ProductTransferCreateManyApprovedByInput | ProductTransferCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type UserLocationCreateWithoutUserInput = {
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
  }

  export type UserLocationUncheckedCreateWithoutUserInput = {
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
  }

  export type UserLocationCreateOrConnectWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationCreateManyUserInputEnvelope = {
    data: UserLocationCreateManyUserInput | UserLocationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DefectiveLogCreateWithoutUserInput = {
    quantity: number
    description: string
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
    product: ProductCreateNestedOneWithoutDefectiveLogInput
    branch?: BranchCreateNestedOneWithoutDefectiveLogsInput
  }

  export type DefectiveLogUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type DefectiveLogCreateOrConnectWithoutUserInput = {
    where: DefectiveLogWhereUniqueInput
    create: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput>
  }

  export type DefectiveLogCreateManyUserInputEnvelope = {
    data: DefectiveLogCreateManyUserInput | DefectiveLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentScheduleCreateWithoutPaidByInput = {
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    transaction: TransactionCreateNestedOneWithoutPaymentSchedulesInput
    repayments?: PaymentRepaymentCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUncheckedCreateWithoutPaidByInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    repayments?: PaymentRepaymentUncheckedCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleCreateOrConnectWithoutPaidByInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput>
  }

  export type PaymentScheduleCreateManyPaidByInputEnvelope = {
    data: PaymentScheduleCreateManyPaidByInput | PaymentScheduleCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentRepaymentCreateWithoutPaidByInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutPaymentRepaymentInput
    schedule: PaymentScheduleCreateNestedOneWithoutRepaymentsInput
  }

  export type PaymentRepaymentUncheckedCreateWithoutPaidByInput = {
    id?: number
    transactionId: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
  }

  export type PaymentRepaymentCreateOrConnectWithoutPaidByInput = {
    where: PaymentRepaymentWhereUniqueInput
    create: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type PaymentRepaymentCreateManyPaidByInputEnvelope = {
    data: PaymentRepaymentCreateManyPaidByInput | PaymentRepaymentCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type DailyRepaymentCreateWithoutPaidByInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutDailyRepaymentsInput
    branch?: BranchCreateNestedOneWithoutDailyRepaymentInput
  }

  export type DailyRepaymentUncheckedCreateWithoutPaidByInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    branchId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentCreateOrConnectWithoutPaidByInput = {
    where: DailyRepaymentWhereUniqueInput
    create: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type DailyRepaymentCreateManyPaidByInputEnvelope = {
    data: DailyRepaymentCreateManyPaidByInput | DailyRepaymentCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type CreditRepaymentCreateWithoutPaidByInput = {
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutCreditRepaymentsInput
    schedule?: PaymentScheduleCreateNestedOneWithoutCreditRepaymentsInput
    branch?: BranchCreateNestedOneWithoutCreditRepaymentInput
  }

  export type CreditRepaymentUncheckedCreateWithoutPaidByInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateOrConnectWithoutPaidByInput = {
    where: CreditRepaymentWhereUniqueInput
    create: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type CreditRepaymentCreateManyPaidByInputEnvelope = {
    data: CreditRepaymentCreateManyPaidByInput | CreditRepaymentCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type CashierReportCreateWithoutCashierInput = {
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutCashierReportsInput
  }

  export type CashierReportUncheckedCreateWithoutCashierInput = {
    id?: number
    branchId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierReportCreateOrConnectWithoutCashierInput = {
    where: CashierReportWhereUniqueInput
    create: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput>
  }

  export type CashierReportCreateManyCashierInputEnvelope = {
    data: CashierReportCreateManyCashierInput | CashierReportCreateManyCashierInput[]
    skipDuplicates?: boolean
  }

  export type CurrencyExchangeRateCreateWithoutUserInput = {
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutExchangeRatesInput
  }

  export type CurrencyExchangeRateUncheckedCreateWithoutUserInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyExchangeRateCreateOrConnectWithoutUserInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    create: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput>
  }

  export type CurrencyExchangeRateCreateManyUserInputEnvelope = {
    data: CurrencyExchangeRateCreateManyUserInput | CurrencyExchangeRateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BonusCreateWithoutUserInput = {
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedBonusesInput
    branch?: BranchCreateNestedOneWithoutBonusesInput
    transaction?: TransactionCreateNestedOneWithoutBonusesInput
  }

  export type BonusUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateOrConnectWithoutUserInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput>
  }

  export type BonusCreateManyUserInputEnvelope = {
    data: BonusCreateManyUserInput | BonusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BonusCreateWithoutCreatedByInput = {
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
    branch?: BranchCreateNestedOneWithoutBonusesInput
    transaction?: TransactionCreateNestedOneWithoutBonusesInput
  }

  export type BonusUncheckedCreateWithoutCreatedByInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateOrConnectWithoutCreatedByInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput>
  }

  export type BonusCreateManyCreatedByInputEnvelope = {
    data: BonusCreateManyCreatedByInput | BonusCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDayCreateWithoutUserInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAttendanceDaysInput
    events?: AttendanceEventCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayUncheckedCreateWithoutUserInput = {
    id?: number
    branchId?: number | null
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: AttendanceEventUncheckedCreateNestedManyWithoutDayInput
  }

  export type AttendanceDayCreateOrConnectWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    create: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDayCreateManyUserInputEnvelope = {
    data: AttendanceDayCreateManyUserInput | AttendanceDayCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutUserInput = {
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAttendanceEventsInput
    day?: AttendanceDayCreateNestedOneWithoutEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutUserInput = {
    id?: number
    branchId?: number | null
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventCreateOrConnectWithoutUserInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput>
  }

  export type AttendanceEventCreateManyUserInputEnvelope = {
    data: AttendanceEventCreateManyUserInput | AttendanceEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FaceTemplateCreateWithoutUserInput = {
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaceTemplateUncheckedCreateWithoutUserInput = {
    id?: number
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaceTemplateCreateOrConnectWithoutUserInput = {
    where: FaceTemplateWhereUniqueInput
    create: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput>
  }

  export type FaceTemplateCreateManyUserInputEnvelope = {
    data: FaceTemplateCreateManyUserInput | FaceTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUpdatedByInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUpdatedByInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput>
  }

  export type TransactionCreateManyUpdatedByInputEnvelope = {
    data: TransactionCreateManyUpdatedByInput | TransactionCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserBranchAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBranchAccessWhereUniqueInput
    update: XOR<UserBranchAccessUpdateWithoutUserInput, UserBranchAccessUncheckedUpdateWithoutUserInput>
    create: XOR<UserBranchAccessCreateWithoutUserInput, UserBranchAccessUncheckedCreateWithoutUserInput>
  }

  export type UserBranchAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBranchAccessWhereUniqueInput
    data: XOR<UserBranchAccessUpdateWithoutUserInput, UserBranchAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserBranchAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserBranchAccessScalarWhereInput
    data: XOR<UserBranchAccessUpdateManyMutationInput, UserBranchAccessUncheckedUpdateManyWithoutUserInput>
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutSoldByInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSoldByInput, TransactionUncheckedUpdateWithoutSoldByInput>
    create: XOR<TransactionCreateWithoutSoldByInput, TransactionUncheckedCreateWithoutSoldByInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSoldByInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSoldByInput, TransactionUncheckedUpdateWithoutSoldByInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSoldByInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSoldByInput>
  }

  export type ProductTransferUpsertWithWhereUniqueWithoutInitiatedByInput = {
    where: ProductTransferWhereUniqueInput
    update: XOR<ProductTransferUpdateWithoutInitiatedByInput, ProductTransferUncheckedUpdateWithoutInitiatedByInput>
    create: XOR<ProductTransferCreateWithoutInitiatedByInput, ProductTransferUncheckedCreateWithoutInitiatedByInput>
  }

  export type ProductTransferUpdateWithWhereUniqueWithoutInitiatedByInput = {
    where: ProductTransferWhereUniqueInput
    data: XOR<ProductTransferUpdateWithoutInitiatedByInput, ProductTransferUncheckedUpdateWithoutInitiatedByInput>
  }

  export type ProductTransferUpdateManyWithWhereWithoutInitiatedByInput = {
    where: ProductTransferScalarWhereInput
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyWithoutInitiatedByInput>
  }

  export type ProductTransferUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ProductTransferWhereUniqueInput
    update: XOR<ProductTransferUpdateWithoutApprovedByInput, ProductTransferUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ProductTransferCreateWithoutApprovedByInput, ProductTransferUncheckedCreateWithoutApprovedByInput>
  }

  export type ProductTransferUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ProductTransferWhereUniqueInput
    data: XOR<ProductTransferUpdateWithoutApprovedByInput, ProductTransferUncheckedUpdateWithoutApprovedByInput>
  }

  export type ProductTransferUpdateManyWithWhereWithoutApprovedByInput = {
    where: ProductTransferScalarWhereInput
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type UserLocationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    update: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    data: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
  }

  export type UserLocationUpdateManyWithWhereWithoutUserInput = {
    where: UserLocationScalarWhereInput
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLocationScalarWhereInput = {
    AND?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
    OR?: UserLocationScalarWhereInput[]
    NOT?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
    userId?: IntFilter<"UserLocation"> | number
    latitude?: FloatFilter<"UserLocation"> | number
    longitude?: FloatFilter<"UserLocation"> | number
    address?: StringNullableFilter<"UserLocation"> | string | null
    isOnline?: BoolFilter<"UserLocation"> | boolean
    lastSeen?: DateTimeFilter<"UserLocation"> | Date | string
    updatedAt?: DateTimeFilter<"UserLocation"> | Date | string
  }

  export type DefectiveLogUpsertWithWhereUniqueWithoutUserInput = {
    where: DefectiveLogWhereUniqueInput
    update: XOR<DefectiveLogUpdateWithoutUserInput, DefectiveLogUncheckedUpdateWithoutUserInput>
    create: XOR<DefectiveLogCreateWithoutUserInput, DefectiveLogUncheckedCreateWithoutUserInput>
  }

  export type DefectiveLogUpdateWithWhereUniqueWithoutUserInput = {
    where: DefectiveLogWhereUniqueInput
    data: XOR<DefectiveLogUpdateWithoutUserInput, DefectiveLogUncheckedUpdateWithoutUserInput>
  }

  export type DefectiveLogUpdateManyWithWhereWithoutUserInput = {
    where: DefectiveLogScalarWhereInput
    data: XOR<DefectiveLogUpdateManyMutationInput, DefectiveLogUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScheduleUpsertWithWhereUniqueWithoutPaidByInput = {
    where: PaymentScheduleWhereUniqueInput
    update: XOR<PaymentScheduleUpdateWithoutPaidByInput, PaymentScheduleUncheckedUpdateWithoutPaidByInput>
    create: XOR<PaymentScheduleCreateWithoutPaidByInput, PaymentScheduleUncheckedCreateWithoutPaidByInput>
  }

  export type PaymentScheduleUpdateWithWhereUniqueWithoutPaidByInput = {
    where: PaymentScheduleWhereUniqueInput
    data: XOR<PaymentScheduleUpdateWithoutPaidByInput, PaymentScheduleUncheckedUpdateWithoutPaidByInput>
  }

  export type PaymentScheduleUpdateManyWithWhereWithoutPaidByInput = {
    where: PaymentScheduleScalarWhereInput
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyWithoutPaidByInput>
  }

  export type PaymentScheduleScalarWhereInput = {
    AND?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
    OR?: PaymentScheduleScalarWhereInput[]
    NOT?: PaymentScheduleScalarWhereInput | PaymentScheduleScalarWhereInput[]
    id?: IntFilter<"PaymentSchedule"> | number
    transactionId?: IntFilter<"PaymentSchedule"> | number
    month?: IntFilter<"PaymentSchedule"> | number
    payment?: FloatFilter<"PaymentSchedule"> | number
    remainingBalance?: FloatFilter<"PaymentSchedule"> | number
    isPaid?: BoolFilter<"PaymentSchedule"> | boolean
    paidAmount?: FloatFilter<"PaymentSchedule"> | number
    paidAt?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    paidChannel?: StringNullableFilter<"PaymentSchedule"> | string | null
    paidByUserId?: IntNullableFilter<"PaymentSchedule"> | number | null
    createdAt?: DateTimeFilter<"PaymentSchedule"> | Date | string
    creditRepaymentAmount?: FloatNullableFilter<"PaymentSchedule"> | number | null
    repaymentDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    rating?: StringNullableFilter<"PaymentSchedule"> | string | null
    dueDate?: DateTimeNullableFilter<"PaymentSchedule"> | Date | string | null
    isDailyInstallment?: BoolFilter<"PaymentSchedule"> | boolean
    daysCount?: IntNullableFilter<"PaymentSchedule"> | number | null
    installmentType?: StringNullableFilter<"PaymentSchedule"> | string | null
    totalDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingDays?: IntNullableFilter<"PaymentSchedule"> | number | null
    totalMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
    remainingMonths?: IntNullableFilter<"PaymentSchedule"> | number | null
  }

  export type PaymentRepaymentUpsertWithWhereUniqueWithoutPaidByInput = {
    where: PaymentRepaymentWhereUniqueInput
    update: XOR<PaymentRepaymentUpdateWithoutPaidByInput, PaymentRepaymentUncheckedUpdateWithoutPaidByInput>
    create: XOR<PaymentRepaymentCreateWithoutPaidByInput, PaymentRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type PaymentRepaymentUpdateWithWhereUniqueWithoutPaidByInput = {
    where: PaymentRepaymentWhereUniqueInput
    data: XOR<PaymentRepaymentUpdateWithoutPaidByInput, PaymentRepaymentUncheckedUpdateWithoutPaidByInput>
  }

  export type PaymentRepaymentUpdateManyWithWhereWithoutPaidByInput = {
    where: PaymentRepaymentScalarWhereInput
    data: XOR<PaymentRepaymentUpdateManyMutationInput, PaymentRepaymentUncheckedUpdateManyWithoutPaidByInput>
  }

  export type PaymentRepaymentScalarWhereInput = {
    AND?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
    OR?: PaymentRepaymentScalarWhereInput[]
    NOT?: PaymentRepaymentScalarWhereInput | PaymentRepaymentScalarWhereInput[]
    id?: IntFilter<"PaymentRepayment"> | number
    transactionId?: IntFilter<"PaymentRepayment"> | number
    scheduleId?: IntFilter<"PaymentRepayment"> | number
    amount?: FloatFilter<"PaymentRepayment"> | number
    channel?: StringFilter<"PaymentRepayment"> | string
    paidAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
    paidByUserId?: IntNullableFilter<"PaymentRepayment"> | number | null
    createdAt?: DateTimeFilter<"PaymentRepayment"> | Date | string
  }

  export type DailyRepaymentUpsertWithWhereUniqueWithoutPaidByInput = {
    where: DailyRepaymentWhereUniqueInput
    update: XOR<DailyRepaymentUpdateWithoutPaidByInput, DailyRepaymentUncheckedUpdateWithoutPaidByInput>
    create: XOR<DailyRepaymentCreateWithoutPaidByInput, DailyRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type DailyRepaymentUpdateWithWhereUniqueWithoutPaidByInput = {
    where: DailyRepaymentWhereUniqueInput
    data: XOR<DailyRepaymentUpdateWithoutPaidByInput, DailyRepaymentUncheckedUpdateWithoutPaidByInput>
  }

  export type DailyRepaymentUpdateManyWithWhereWithoutPaidByInput = {
    where: DailyRepaymentScalarWhereInput
    data: XOR<DailyRepaymentUpdateManyMutationInput, DailyRepaymentUncheckedUpdateManyWithoutPaidByInput>
  }

  export type CreditRepaymentUpsertWithWhereUniqueWithoutPaidByInput = {
    where: CreditRepaymentWhereUniqueInput
    update: XOR<CreditRepaymentUpdateWithoutPaidByInput, CreditRepaymentUncheckedUpdateWithoutPaidByInput>
    create: XOR<CreditRepaymentCreateWithoutPaidByInput, CreditRepaymentUncheckedCreateWithoutPaidByInput>
  }

  export type CreditRepaymentUpdateWithWhereUniqueWithoutPaidByInput = {
    where: CreditRepaymentWhereUniqueInput
    data: XOR<CreditRepaymentUpdateWithoutPaidByInput, CreditRepaymentUncheckedUpdateWithoutPaidByInput>
  }

  export type CreditRepaymentUpdateManyWithWhereWithoutPaidByInput = {
    where: CreditRepaymentScalarWhereInput
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyWithoutPaidByInput>
  }

  export type CashierReportUpsertWithWhereUniqueWithoutCashierInput = {
    where: CashierReportWhereUniqueInput
    update: XOR<CashierReportUpdateWithoutCashierInput, CashierReportUncheckedUpdateWithoutCashierInput>
    create: XOR<CashierReportCreateWithoutCashierInput, CashierReportUncheckedCreateWithoutCashierInput>
  }

  export type CashierReportUpdateWithWhereUniqueWithoutCashierInput = {
    where: CashierReportWhereUniqueInput
    data: XOR<CashierReportUpdateWithoutCashierInput, CashierReportUncheckedUpdateWithoutCashierInput>
  }

  export type CashierReportUpdateManyWithWhereWithoutCashierInput = {
    where: CashierReportScalarWhereInput
    data: XOR<CashierReportUpdateManyMutationInput, CashierReportUncheckedUpdateManyWithoutCashierInput>
  }

  export type CurrencyExchangeRateUpsertWithWhereUniqueWithoutUserInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    update: XOR<CurrencyExchangeRateUpdateWithoutUserInput, CurrencyExchangeRateUncheckedUpdateWithoutUserInput>
    create: XOR<CurrencyExchangeRateCreateWithoutUserInput, CurrencyExchangeRateUncheckedCreateWithoutUserInput>
  }

  export type CurrencyExchangeRateUpdateWithWhereUniqueWithoutUserInput = {
    where: CurrencyExchangeRateWhereUniqueInput
    data: XOR<CurrencyExchangeRateUpdateWithoutUserInput, CurrencyExchangeRateUncheckedUpdateWithoutUserInput>
  }

  export type CurrencyExchangeRateUpdateManyWithWhereWithoutUserInput = {
    where: CurrencyExchangeRateScalarWhereInput
    data: XOR<CurrencyExchangeRateUpdateManyMutationInput, CurrencyExchangeRateUncheckedUpdateManyWithoutUserInput>
  }

  export type BonusUpsertWithWhereUniqueWithoutUserInput = {
    where: BonusWhereUniqueInput
    update: XOR<BonusUpdateWithoutUserInput, BonusUncheckedUpdateWithoutUserInput>
    create: XOR<BonusCreateWithoutUserInput, BonusUncheckedCreateWithoutUserInput>
  }

  export type BonusUpdateWithWhereUniqueWithoutUserInput = {
    where: BonusWhereUniqueInput
    data: XOR<BonusUpdateWithoutUserInput, BonusUncheckedUpdateWithoutUserInput>
  }

  export type BonusUpdateManyWithWhereWithoutUserInput = {
    where: BonusScalarWhereInput
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyWithoutUserInput>
  }

  export type BonusUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BonusWhereUniqueInput
    update: XOR<BonusUpdateWithoutCreatedByInput, BonusUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BonusCreateWithoutCreatedByInput, BonusUncheckedCreateWithoutCreatedByInput>
  }

  export type BonusUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BonusWhereUniqueInput
    data: XOR<BonusUpdateWithoutCreatedByInput, BonusUncheckedUpdateWithoutCreatedByInput>
  }

  export type BonusUpdateManyWithWhereWithoutCreatedByInput = {
    where: BonusScalarWhereInput
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AttendanceDayUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    update: XOR<AttendanceDayUpdateWithoutUserInput, AttendanceDayUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDayUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    data: XOR<AttendanceDayUpdateWithoutUserInput, AttendanceDayUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceDayUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceDayScalarWhereInput
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutUserInput, AttendanceEventUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceEventCreateWithoutUserInput, AttendanceEventUncheckedCreateWithoutUserInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutUserInput, AttendanceEventUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutUserInput>
  }

  export type FaceTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: FaceTemplateWhereUniqueInput
    update: XOR<FaceTemplateUpdateWithoutUserInput, FaceTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<FaceTemplateCreateWithoutUserInput, FaceTemplateUncheckedCreateWithoutUserInput>
  }

  export type FaceTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: FaceTemplateWhereUniqueInput
    data: XOR<FaceTemplateUpdateWithoutUserInput, FaceTemplateUncheckedUpdateWithoutUserInput>
  }

  export type FaceTemplateUpdateManyWithWhereWithoutUserInput = {
    where: FaceTemplateScalarWhereInput
    data: XOR<FaceTemplateUpdateManyMutationInput, FaceTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type FaceTemplateScalarWhereInput = {
    AND?: FaceTemplateScalarWhereInput | FaceTemplateScalarWhereInput[]
    OR?: FaceTemplateScalarWhereInput[]
    NOT?: FaceTemplateScalarWhereInput | FaceTemplateScalarWhereInput[]
    id?: IntFilter<"FaceTemplate"> | number
    userId?: IntFilter<"FaceTemplate"> | number
    deviceId?: StringNullableFilter<"FaceTemplate"> | string | null
    template?: StringNullableFilter<"FaceTemplate"> | string | null
    vector?: JsonNullableFilter<"FaceTemplate">
    imageUrl?: StringNullableFilter<"FaceTemplate"> | string | null
    createdAt?: DateTimeFilter<"FaceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FaceTemplate"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUpdatedByInput, TransactionUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<TransactionCreateWithoutUpdatedByInput, TransactionUncheckedCreateWithoutUpdatedByInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUpdatedByInput, TransactionUncheckedUpdateWithoutUpdatedByInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUpdatedByInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type UserCreateWithoutAllowedBranchesInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAllowedBranchesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAllowedBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAllowedBranchesInput, UserUncheckedCreateWithoutAllowedBranchesInput>
  }

  export type BranchCreateWithoutAllowedUsersInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAllowedUsersInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAllowedUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAllowedUsersInput, BranchUncheckedCreateWithoutAllowedUsersInput>
  }

  export type UserUpsertWithoutAllowedBranchesInput = {
    update: XOR<UserUpdateWithoutAllowedBranchesInput, UserUncheckedUpdateWithoutAllowedBranchesInput>
    create: XOR<UserCreateWithoutAllowedBranchesInput, UserUncheckedCreateWithoutAllowedBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAllowedBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAllowedBranchesInput, UserUncheckedUpdateWithoutAllowedBranchesInput>
  }

  export type UserUpdateWithoutAllowedBranchesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAllowedBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutAllowedUsersInput = {
    update: XOR<BranchUpdateWithoutAllowedUsersInput, BranchUncheckedUpdateWithoutAllowedUsersInput>
    create: XOR<BranchCreateWithoutAllowedUsersInput, BranchUncheckedCreateWithoutAllowedUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAllowedUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAllowedUsersInput, BranchUncheckedUpdateWithoutAllowedUsersInput>
  }

  export type BranchUpdateWithoutAllowedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAllowedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutUserLocationsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUserLocationsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUserLocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLocationsInput, UserUncheckedCreateWithoutUserLocationsInput>
  }

  export type UserUpsertWithoutUserLocationsInput = {
    update: XOR<UserUpdateWithoutUserLocationsInput, UserUncheckedUpdateWithoutUserLocationsInput>
    create: XOR<UserCreateWithoutUserLocationsInput, UserUncheckedCreateWithoutUserLocationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLocationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLocationsInput, UserUncheckedUpdateWithoutUserLocationsInput>
  }

  export type UserUpdateWithoutUserLocationsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchCreateWithoutCategoriesInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCategoriesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCategoriesInput, BranchUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutCategoriesInput = {
    update: XOR<BranchUpdateWithoutCategoriesInput, BranchUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BranchCreateWithoutCategoriesInput, BranchUncheckedCreateWithoutCategoriesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCategoriesInput, BranchUncheckedUpdateWithoutCategoriesInput>
  }

  export type BranchUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BranchCreateWithoutProductsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProductsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type TransactionItemCreateWithoutProductInput = {
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutItemsInput
  }

  export type TransactionItemUncheckedCreateWithoutProductInput = {
    id?: number
    transactionId: number
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemCreateOrConnectWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemCreateManyProductInputEnvelope = {
    data: TransactionItemCreateManyProductInput | TransactionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DefectiveLogCreateWithoutProductInput = {
    quantity: number
    description: string
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
    user?: UserCreateNestedOneWithoutDefectiveLogsInput
    branch?: BranchCreateNestedOneWithoutDefectiveLogsInput
  }

  export type DefectiveLogUncheckedCreateWithoutProductInput = {
    id?: number
    quantity: number
    description: string
    userId?: number | null
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type DefectiveLogCreateOrConnectWithoutProductInput = {
    where: DefectiveLogWhereUniqueInput
    create: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput>
  }

  export type DefectiveLogCreateManyProductInputEnvelope = {
    data: DefectiveLogCreateManyProductInput | DefectiveLogCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransferCreateWithoutProductInput = {
    quantity: number
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromBranch: BranchCreateNestedOneWithoutFromTransfersInput
    toBranch: BranchCreateNestedOneWithoutToTransfersInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
  }

  export type ProductTransferUncheckedCreateWithoutProductInput = {
    id?: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateOrConnectWithoutProductInput = {
    where: ProductTransferWhereUniqueInput
    create: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput>
  }

  export type ProductTransferCreateManyProductInputEnvelope = {
    data: ProductTransferCreateManyProductInput | ProductTransferCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransactionBonusProductCreateWithoutProductInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutBonusProductsInput
  }

  export type TransactionBonusProductUncheckedCreateWithoutProductInput = {
    id?: number
    transactionId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionBonusProductCreateOrConnectWithoutProductInput = {
    where: TransactionBonusProductWhereUniqueInput
    create: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput>
  }

  export type TransactionBonusProductCreateManyProductInputEnvelope = {
    data: TransactionBonusProductCreateManyProductInput | TransactionBonusProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutProductsInput = {
    update: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProductsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type BranchUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutProductInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionItemScalarWhereInput = {
    AND?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    OR?: TransactionItemScalarWhereInput[]
    NOT?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    id?: IntFilter<"TransactionItem"> | number
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntNullableFilter<"TransactionItem"> | number | null
    quantity?: IntFilter<"TransactionItem"> | number
    price?: FloatFilter<"TransactionItem"> | number
    sellingPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    originalPrice?: FloatNullableFilter<"TransactionItem"> | number | null
    total?: FloatFilter<"TransactionItem"> | number
    creditMonth?: IntNullableFilter<"TransactionItem"> | number | null
    creditPercent?: FloatNullableFilter<"TransactionItem"> | number | null
    monthlyPayment?: FloatNullableFilter<"TransactionItem"> | number | null
    status?: StringNullableFilter<"TransactionItem"> | string | null
    createdAt?: DateTimeFilter<"TransactionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionItem"> | Date | string
  }

  export type DefectiveLogUpsertWithWhereUniqueWithoutProductInput = {
    where: DefectiveLogWhereUniqueInput
    update: XOR<DefectiveLogUpdateWithoutProductInput, DefectiveLogUncheckedUpdateWithoutProductInput>
    create: XOR<DefectiveLogCreateWithoutProductInput, DefectiveLogUncheckedCreateWithoutProductInput>
  }

  export type DefectiveLogUpdateWithWhereUniqueWithoutProductInput = {
    where: DefectiveLogWhereUniqueInput
    data: XOR<DefectiveLogUpdateWithoutProductInput, DefectiveLogUncheckedUpdateWithoutProductInput>
  }

  export type DefectiveLogUpdateManyWithWhereWithoutProductInput = {
    where: DefectiveLogScalarWhereInput
    data: XOR<DefectiveLogUpdateManyMutationInput, DefectiveLogUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductTransferUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTransferWhereUniqueInput
    update: XOR<ProductTransferUpdateWithoutProductInput, ProductTransferUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTransferCreateWithoutProductInput, ProductTransferUncheckedCreateWithoutProductInput>
  }

  export type ProductTransferUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTransferWhereUniqueInput
    data: XOR<ProductTransferUpdateWithoutProductInput, ProductTransferUncheckedUpdateWithoutProductInput>
  }

  export type ProductTransferUpdateManyWithWhereWithoutProductInput = {
    where: ProductTransferScalarWhereInput
    data: XOR<ProductTransferUpdateManyMutationInput, ProductTransferUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionBonusProductUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionBonusProductWhereUniqueInput
    update: XOR<TransactionBonusProductUpdateWithoutProductInput, TransactionBonusProductUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionBonusProductCreateWithoutProductInput, TransactionBonusProductUncheckedCreateWithoutProductInput>
  }

  export type TransactionBonusProductUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionBonusProductWhereUniqueInput
    data: XOR<TransactionBonusProductUpdateWithoutProductInput, TransactionBonusProductUncheckedUpdateWithoutProductInput>
  }

  export type TransactionBonusProductUpdateManyWithWhereWithoutProductInput = {
    where: TransactionBonusProductScalarWhereInput
    data: XOR<TransactionBonusProductUpdateManyMutationInput, TransactionBonusProductUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionBonusProductScalarWhereInput = {
    AND?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
    OR?: TransactionBonusProductScalarWhereInput[]
    NOT?: TransactionBonusProductScalarWhereInput | TransactionBonusProductScalarWhereInput[]
    id?: IntFilter<"TransactionBonusProduct"> | number
    transactionId?: IntFilter<"TransactionBonusProduct"> | number
    productId?: IntFilter<"TransactionBonusProduct"> | number
    quantity?: IntFilter<"TransactionBonusProduct"> | number
    createdAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionBonusProduct"> | Date | string
  }

  export type ProductCreateWithoutDefectiveLogInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    category: CategoryCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDefectiveLogInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDefectiveLogInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDefectiveLogInput, ProductUncheckedCreateWithoutDefectiveLogInput>
  }

  export type UserCreateWithoutDefectiveLogsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutDefectiveLogsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDefectiveLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDefectiveLogsInput, UserUncheckedCreateWithoutDefectiveLogsInput>
  }

  export type BranchCreateWithoutDefectiveLogsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDefectiveLogsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDefectiveLogsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDefectiveLogsInput, BranchUncheckedCreateWithoutDefectiveLogsInput>
  }

  export type ProductUpsertWithoutDefectiveLogInput = {
    update: XOR<ProductUpdateWithoutDefectiveLogInput, ProductUncheckedUpdateWithoutDefectiveLogInput>
    create: XOR<ProductCreateWithoutDefectiveLogInput, ProductUncheckedCreateWithoutDefectiveLogInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutDefectiveLogInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutDefectiveLogInput, ProductUncheckedUpdateWithoutDefectiveLogInput>
  }

  export type ProductUpdateWithoutDefectiveLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDefectiveLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutDefectiveLogsInput = {
    update: XOR<UserUpdateWithoutDefectiveLogsInput, UserUncheckedUpdateWithoutDefectiveLogsInput>
    create: XOR<UserCreateWithoutDefectiveLogsInput, UserUncheckedCreateWithoutDefectiveLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDefectiveLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDefectiveLogsInput, UserUncheckedUpdateWithoutDefectiveLogsInput>
  }

  export type UserUpdateWithoutDefectiveLogsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDefectiveLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutDefectiveLogsInput = {
    update: XOR<BranchUpdateWithoutDefectiveLogsInput, BranchUncheckedUpdateWithoutDefectiveLogsInput>
    create: XOR<BranchCreateWithoutDefectiveLogsInput, BranchUncheckedCreateWithoutDefectiveLogsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDefectiveLogsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDefectiveLogsInput, BranchUncheckedUpdateWithoutDefectiveLogsInput>
  }

  export type BranchUpdateWithoutDefectiveLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDefectiveLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TransactionCreateWithoutCustomerInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: number
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutTransactionsInput = {
    fullName: string
    phone: string
    email?: string | null
    address?: string | null
    passportSeries?: string | null
    jshshir?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: number
    fullName: string
    phone: string
    email?: string | null
    address?: string | null
    passportSeries?: string | null
    jshshir?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutCreatedTransactionsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedTransactionsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
  }

  export type UserCreateWithoutSoldTransactionsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSoldTransactionsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSoldTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoldTransactionsInput, UserUncheckedCreateWithoutSoldTransactionsInput>
  }

  export type BranchCreateWithoutTransactionsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTransactionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
  }

  export type BranchCreateWithoutToTransactionsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutToTransactionsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutToTransactionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutToTransactionsInput, BranchUncheckedCreateWithoutToTransactionsInput>
  }

  export type UserCreateWithoutTransactionInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemCreateWithoutTransactionInput = {
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionItemUncheckedCreateWithoutTransactionInput = {
    id?: number
    productId?: number | null
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemCreateOrConnectWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemCreateManyTransactionInputEnvelope = {
    data: TransactionItemCreateManyTransactionInput | TransactionItemCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentScheduleCreateWithoutTransactionInput = {
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    paidBy?: UserCreateNestedOneWithoutPaymentScheduleInput
    repayments?: PaymentRepaymentCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUncheckedCreateWithoutTransactionInput = {
    id?: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    repayments?: PaymentRepaymentUncheckedCreateNestedManyWithoutScheduleInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleCreateOrConnectWithoutTransactionInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentScheduleCreateManyTransactionInputEnvelope = {
    data: PaymentScheduleCreateManyTransactionInput | PaymentScheduleCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentRepaymentCreateWithoutTransactionInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    schedule: PaymentScheduleCreateNestedOneWithoutRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutPaymentRepaymentInput
  }

  export type PaymentRepaymentUncheckedCreateWithoutTransactionInput = {
    id?: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type PaymentRepaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentRepaymentWhereUniqueInput
    create: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentRepaymentCreateManyTransactionInputEnvelope = {
    data: PaymentRepaymentCreateManyTransactionInput | PaymentRepaymentCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type DailyRepaymentCreateWithoutTransactionInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    paidBy?: UserCreateNestedOneWithoutDailyRepaymentsInput
    branch?: BranchCreateNestedOneWithoutDailyRepaymentInput
  }

  export type DailyRepaymentUncheckedCreateWithoutTransactionInput = {
    id?: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentCreateOrConnectWithoutTransactionInput = {
    where: DailyRepaymentWhereUniqueInput
    create: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type DailyRepaymentCreateManyTransactionInputEnvelope = {
    data: DailyRepaymentCreateManyTransactionInput | DailyRepaymentCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type CreditRepaymentCreateWithoutTransactionInput = {
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    createdAt?: Date | string
    schedule?: PaymentScheduleCreateNestedOneWithoutCreditRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutCreditRepaymentsInput
    branch?: BranchCreateNestedOneWithoutCreditRepaymentInput
  }

  export type CreditRepaymentUncheckedCreateWithoutTransactionInput = {
    id?: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateOrConnectWithoutTransactionInput = {
    where: CreditRepaymentWhereUniqueInput
    create: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type CreditRepaymentCreateManyTransactionInputEnvelope = {
    data: CreditRepaymentCreateManyTransactionInput | CreditRepaymentCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionBonusProductCreateWithoutTransactionInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutBonusProductsInput
  }

  export type TransactionBonusProductUncheckedCreateWithoutTransactionInput = {
    id?: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionBonusProductCreateOrConnectWithoutTransactionInput = {
    where: TransactionBonusProductWhereUniqueInput
    create: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionBonusProductCreateManyTransactionInputEnvelope = {
    data: TransactionBonusProductCreateManyTransactionInput | TransactionBonusProductCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type BonusCreateWithoutTransactionInput = {
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
    createdBy: UserCreateNestedOneWithoutCreatedBonusesInput
    branch?: BranchCreateNestedOneWithoutBonusesInput
  }

  export type BonusUncheckedCreateWithoutTransactionInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateOrConnectWithoutTransactionInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput>
  }

  export type BonusCreateManyTransactionInputEnvelope = {
    data: BonusCreateManyTransactionInput | BonusCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    passportSeries?: NullableStringFieldUpdateOperationsInput | string | null
    jshshir?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedTransactionsInput = {
    update: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type UserUpdateWithoutCreatedTransactionsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutSoldTransactionsInput = {
    update: XOR<UserUpdateWithoutSoldTransactionsInput, UserUncheckedUpdateWithoutSoldTransactionsInput>
    create: XOR<UserCreateWithoutSoldTransactionsInput, UserUncheckedCreateWithoutSoldTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoldTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoldTransactionsInput, UserUncheckedUpdateWithoutSoldTransactionsInput>
  }

  export type UserUpdateWithoutSoldTransactionsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSoldTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutTransactionsInput = {
    update: XOR<BranchUpdateWithoutTransactionsInput, BranchUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTransactionsInput, BranchUncheckedUpdateWithoutTransactionsInput>
  }

  export type BranchUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUpsertWithoutToTransactionsInput = {
    update: XOR<BranchUpdateWithoutToTransactionsInput, BranchUncheckedUpdateWithoutToTransactionsInput>
    create: XOR<BranchCreateWithoutToTransactionsInput, BranchUncheckedCreateWithoutToTransactionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutToTransactionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutToTransactionsInput, BranchUncheckedUpdateWithoutToTransactionsInput>
  }

  export type BranchUpdateWithoutToTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutToTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutTransactionInput>
  }

  export type PaymentScheduleUpsertWithWhereUniqueWithoutTransactionInput = {
    where: PaymentScheduleWhereUniqueInput
    update: XOR<PaymentScheduleUpdateWithoutTransactionInput, PaymentScheduleUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentScheduleCreateWithoutTransactionInput, PaymentScheduleUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentScheduleUpdateWithWhereUniqueWithoutTransactionInput = {
    where: PaymentScheduleWhereUniqueInput
    data: XOR<PaymentScheduleUpdateWithoutTransactionInput, PaymentScheduleUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentScheduleUpdateManyWithWhereWithoutTransactionInput = {
    where: PaymentScheduleScalarWhereInput
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyWithoutTransactionInput>
  }

  export type PaymentRepaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: PaymentRepaymentWhereUniqueInput
    update: XOR<PaymentRepaymentUpdateWithoutTransactionInput, PaymentRepaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentRepaymentCreateWithoutTransactionInput, PaymentRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentRepaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: PaymentRepaymentWhereUniqueInput
    data: XOR<PaymentRepaymentUpdateWithoutTransactionInput, PaymentRepaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentRepaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: PaymentRepaymentScalarWhereInput
    data: XOR<PaymentRepaymentUpdateManyMutationInput, PaymentRepaymentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type DailyRepaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: DailyRepaymentWhereUniqueInput
    update: XOR<DailyRepaymentUpdateWithoutTransactionInput, DailyRepaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<DailyRepaymentCreateWithoutTransactionInput, DailyRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type DailyRepaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: DailyRepaymentWhereUniqueInput
    data: XOR<DailyRepaymentUpdateWithoutTransactionInput, DailyRepaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type DailyRepaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: DailyRepaymentScalarWhereInput
    data: XOR<DailyRepaymentUpdateManyMutationInput, DailyRepaymentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type CreditRepaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: CreditRepaymentWhereUniqueInput
    update: XOR<CreditRepaymentUpdateWithoutTransactionInput, CreditRepaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<CreditRepaymentCreateWithoutTransactionInput, CreditRepaymentUncheckedCreateWithoutTransactionInput>
  }

  export type CreditRepaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: CreditRepaymentWhereUniqueInput
    data: XOR<CreditRepaymentUpdateWithoutTransactionInput, CreditRepaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type CreditRepaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: CreditRepaymentScalarWhereInput
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionBonusProductUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionBonusProductWhereUniqueInput
    update: XOR<TransactionBonusProductUpdateWithoutTransactionInput, TransactionBonusProductUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionBonusProductCreateWithoutTransactionInput, TransactionBonusProductUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionBonusProductUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionBonusProductWhereUniqueInput
    data: XOR<TransactionBonusProductUpdateWithoutTransactionInput, TransactionBonusProductUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionBonusProductUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionBonusProductScalarWhereInput
    data: XOR<TransactionBonusProductUpdateManyMutationInput, TransactionBonusProductUncheckedUpdateManyWithoutTransactionInput>
  }

  export type BonusUpsertWithWhereUniqueWithoutTransactionInput = {
    where: BonusWhereUniqueInput
    update: XOR<BonusUpdateWithoutTransactionInput, BonusUncheckedUpdateWithoutTransactionInput>
    create: XOR<BonusCreateWithoutTransactionInput, BonusUncheckedCreateWithoutTransactionInput>
  }

  export type BonusUpdateWithWhereUniqueWithoutTransactionInput = {
    where: BonusWhereUniqueInput
    data: XOR<BonusUpdateWithoutTransactionInput, BonusUncheckedUpdateWithoutTransactionInput>
  }

  export type BonusUpdateManyWithWhereWithoutTransactionInput = {
    where: BonusScalarWhereInput
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionCreateWithoutItemsInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutItemsInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutItemsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutTransactionsInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    category: CategoryCreateNestedOneWithoutProductsInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransactionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionUpsertWithoutItemsInput = {
    update: XOR<TransactionUpdateWithoutItemsInput, TransactionUncheckedUpdateWithoutItemsInput>
    create: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutItemsInput, TransactionUncheckedUpdateWithoutItemsInput>
  }

  export type TransactionUpdateWithoutItemsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ProductUpsertWithoutTransactionsInput = {
    update: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutProductTransferInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    category: CategoryCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductTransferInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductTransferInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductTransferInput, ProductUncheckedCreateWithoutProductTransferInput>
  }

  export type BranchCreateWithoutFromTransfersInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFromTransfersInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFromTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFromTransfersInput, BranchUncheckedCreateWithoutFromTransfersInput>
  }

  export type BranchCreateWithoutToTransfersInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutToTransfersInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutToTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutToTransfersInput, BranchUncheckedCreateWithoutToTransfersInput>
  }

  export type UserCreateWithoutInitiatedTransfersInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutInitiatedTransfersInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutInitiatedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiatedTransfersInput, UserUncheckedCreateWithoutInitiatedTransfersInput>
  }

  export type UserCreateWithoutApprovedTransfersInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutApprovedTransfersInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutApprovedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
  }

  export type ProductUpsertWithoutProductTransferInput = {
    update: XOR<ProductUpdateWithoutProductTransferInput, ProductUncheckedUpdateWithoutProductTransferInput>
    create: XOR<ProductCreateWithoutProductTransferInput, ProductUncheckedCreateWithoutProductTransferInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductTransferInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductTransferInput, ProductUncheckedUpdateWithoutProductTransferInput>
  }

  export type ProductUpdateWithoutProductTransferInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BranchUpsertWithoutFromTransfersInput = {
    update: XOR<BranchUpdateWithoutFromTransfersInput, BranchUncheckedUpdateWithoutFromTransfersInput>
    create: XOR<BranchCreateWithoutFromTransfersInput, BranchUncheckedCreateWithoutFromTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFromTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFromTransfersInput, BranchUncheckedUpdateWithoutFromTransfersInput>
  }

  export type BranchUpdateWithoutFromTransfersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFromTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUpsertWithoutToTransfersInput = {
    update: XOR<BranchUpdateWithoutToTransfersInput, BranchUncheckedUpdateWithoutToTransfersInput>
    create: XOR<BranchCreateWithoutToTransfersInput, BranchUncheckedCreateWithoutToTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutToTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutToTransfersInput, BranchUncheckedUpdateWithoutToTransfersInput>
  }

  export type BranchUpdateWithoutToTransfersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutToTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutInitiatedTransfersInput = {
    update: XOR<UserUpdateWithoutInitiatedTransfersInput, UserUncheckedUpdateWithoutInitiatedTransfersInput>
    create: XOR<UserCreateWithoutInitiatedTransfersInput, UserUncheckedCreateWithoutInitiatedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiatedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiatedTransfersInput, UserUncheckedUpdateWithoutInitiatedTransfersInput>
  }

  export type UserUpdateWithoutInitiatedTransfersInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiatedTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutApprovedTransfersInput = {
    update: XOR<UserUpdateWithoutApprovedTransfersInput, UserUncheckedUpdateWithoutApprovedTransfersInput>
    create: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedTransfersInput, UserUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type UserUpdateWithoutApprovedTransfersInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type TransactionCreateWithoutPaymentSchedulesInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentSchedulesInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentSchedulesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentSchedulesInput, TransactionUncheckedCreateWithoutPaymentSchedulesInput>
  }

  export type UserCreateWithoutPaymentScheduleInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutPaymentScheduleInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPaymentScheduleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentScheduleInput, UserUncheckedCreateWithoutPaymentScheduleInput>
  }

  export type PaymentRepaymentCreateWithoutScheduleInput = {
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutPaymentRepaymentInput
    paidBy?: UserCreateNestedOneWithoutPaymentRepaymentInput
  }

  export type PaymentRepaymentUncheckedCreateWithoutScheduleInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type PaymentRepaymentCreateOrConnectWithoutScheduleInput = {
    where: PaymentRepaymentWhereUniqueInput
    create: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput>
  }

  export type PaymentRepaymentCreateManyScheduleInputEnvelope = {
    data: PaymentRepaymentCreateManyScheduleInput | PaymentRepaymentCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type CreditRepaymentCreateWithoutScheduleInput = {
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutCreditRepaymentsInput
    paidBy?: UserCreateNestedOneWithoutCreditRepaymentsInput
    branch?: BranchCreateNestedOneWithoutCreditRepaymentInput
  }

  export type CreditRepaymentUncheckedCreateWithoutScheduleInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateOrConnectWithoutScheduleInput = {
    where: CreditRepaymentWhereUniqueInput
    create: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput>
  }

  export type CreditRepaymentCreateManyScheduleInputEnvelope = {
    data: CreditRepaymentCreateManyScheduleInput | CreditRepaymentCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithoutPaymentSchedulesInput = {
    update: XOR<TransactionUpdateWithoutPaymentSchedulesInput, TransactionUncheckedUpdateWithoutPaymentSchedulesInput>
    create: XOR<TransactionCreateWithoutPaymentSchedulesInput, TransactionUncheckedCreateWithoutPaymentSchedulesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentSchedulesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentSchedulesInput, TransactionUncheckedUpdateWithoutPaymentSchedulesInput>
  }

  export type TransactionUpdateWithoutPaymentSchedulesInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserUpsertWithoutPaymentScheduleInput = {
    update: XOR<UserUpdateWithoutPaymentScheduleInput, UserUncheckedUpdateWithoutPaymentScheduleInput>
    create: XOR<UserCreateWithoutPaymentScheduleInput, UserUncheckedCreateWithoutPaymentScheduleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentScheduleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentScheduleInput, UserUncheckedUpdateWithoutPaymentScheduleInput>
  }

  export type UserUpdateWithoutPaymentScheduleInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PaymentRepaymentUpsertWithWhereUniqueWithoutScheduleInput = {
    where: PaymentRepaymentWhereUniqueInput
    update: XOR<PaymentRepaymentUpdateWithoutScheduleInput, PaymentRepaymentUncheckedUpdateWithoutScheduleInput>
    create: XOR<PaymentRepaymentCreateWithoutScheduleInput, PaymentRepaymentUncheckedCreateWithoutScheduleInput>
  }

  export type PaymentRepaymentUpdateWithWhereUniqueWithoutScheduleInput = {
    where: PaymentRepaymentWhereUniqueInput
    data: XOR<PaymentRepaymentUpdateWithoutScheduleInput, PaymentRepaymentUncheckedUpdateWithoutScheduleInput>
  }

  export type PaymentRepaymentUpdateManyWithWhereWithoutScheduleInput = {
    where: PaymentRepaymentScalarWhereInput
    data: XOR<PaymentRepaymentUpdateManyMutationInput, PaymentRepaymentUncheckedUpdateManyWithoutScheduleInput>
  }

  export type CreditRepaymentUpsertWithWhereUniqueWithoutScheduleInput = {
    where: CreditRepaymentWhereUniqueInput
    update: XOR<CreditRepaymentUpdateWithoutScheduleInput, CreditRepaymentUncheckedUpdateWithoutScheduleInput>
    create: XOR<CreditRepaymentCreateWithoutScheduleInput, CreditRepaymentUncheckedCreateWithoutScheduleInput>
  }

  export type CreditRepaymentUpdateWithWhereUniqueWithoutScheduleInput = {
    where: CreditRepaymentWhereUniqueInput
    data: XOR<CreditRepaymentUpdateWithoutScheduleInput, CreditRepaymentUncheckedUpdateWithoutScheduleInput>
  }

  export type CreditRepaymentUpdateManyWithWhereWithoutScheduleInput = {
    where: CreditRepaymentScalarWhereInput
    data: XOR<CreditRepaymentUpdateManyMutationInput, CreditRepaymentUncheckedUpdateManyWithoutScheduleInput>
  }

  export type TransactionCreateWithoutPaymentRepaymentInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentRepaymentInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentRepaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentRepaymentInput, TransactionUncheckedCreateWithoutPaymentRepaymentInput>
  }

  export type PaymentScheduleCreateWithoutRepaymentsInput = {
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    transaction: TransactionCreateNestedOneWithoutPaymentSchedulesInput
    paidBy?: UserCreateNestedOneWithoutPaymentScheduleInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUncheckedCreateWithoutRepaymentsInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleCreateOrConnectWithoutRepaymentsInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutRepaymentsInput, PaymentScheduleUncheckedCreateWithoutRepaymentsInput>
  }

  export type UserCreateWithoutPaymentRepaymentInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutPaymentRepaymentInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPaymentRepaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentRepaymentInput, UserUncheckedCreateWithoutPaymentRepaymentInput>
  }

  export type TransactionUpsertWithoutPaymentRepaymentInput = {
    update: XOR<TransactionUpdateWithoutPaymentRepaymentInput, TransactionUncheckedUpdateWithoutPaymentRepaymentInput>
    create: XOR<TransactionCreateWithoutPaymentRepaymentInput, TransactionUncheckedCreateWithoutPaymentRepaymentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentRepaymentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentRepaymentInput, TransactionUncheckedUpdateWithoutPaymentRepaymentInput>
  }

  export type TransactionUpdateWithoutPaymentRepaymentInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentRepaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentScheduleUpsertWithoutRepaymentsInput = {
    update: XOR<PaymentScheduleUpdateWithoutRepaymentsInput, PaymentScheduleUncheckedUpdateWithoutRepaymentsInput>
    create: XOR<PaymentScheduleCreateWithoutRepaymentsInput, PaymentScheduleUncheckedCreateWithoutRepaymentsInput>
    where?: PaymentScheduleWhereInput
  }

  export type PaymentScheduleUpdateToOneWithWhereWithoutRepaymentsInput = {
    where?: PaymentScheduleWhereInput
    data: XOR<PaymentScheduleUpdateWithoutRepaymentsInput, PaymentScheduleUncheckedUpdateWithoutRepaymentsInput>
  }

  export type PaymentScheduleUpdateWithoutRepaymentsInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: TransactionUpdateOneRequiredWithoutPaymentSchedulesNestedInput
    paidBy?: UserUpdateOneWithoutPaymentScheduleNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type UserUpsertWithoutPaymentRepaymentInput = {
    update: XOR<UserUpdateWithoutPaymentRepaymentInput, UserUncheckedUpdateWithoutPaymentRepaymentInput>
    create: XOR<UserCreateWithoutPaymentRepaymentInput, UserUncheckedCreateWithoutPaymentRepaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentRepaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentRepaymentInput, UserUncheckedUpdateWithoutPaymentRepaymentInput>
  }

  export type UserUpdateWithoutPaymentRepaymentInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentRepaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type TransactionCreateWithoutDailyRepaymentsInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutDailyRepaymentsInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutDailyRepaymentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutDailyRepaymentsInput, TransactionUncheckedCreateWithoutDailyRepaymentsInput>
  }

  export type UserCreateWithoutDailyRepaymentsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutDailyRepaymentsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDailyRepaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyRepaymentsInput, UserUncheckedCreateWithoutDailyRepaymentsInput>
  }

  export type BranchCreateWithoutDailyRepaymentInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDailyRepaymentInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDailyRepaymentInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDailyRepaymentInput, BranchUncheckedCreateWithoutDailyRepaymentInput>
  }

  export type TransactionUpsertWithoutDailyRepaymentsInput = {
    update: XOR<TransactionUpdateWithoutDailyRepaymentsInput, TransactionUncheckedUpdateWithoutDailyRepaymentsInput>
    create: XOR<TransactionCreateWithoutDailyRepaymentsInput, TransactionUncheckedCreateWithoutDailyRepaymentsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutDailyRepaymentsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutDailyRepaymentsInput, TransactionUncheckedUpdateWithoutDailyRepaymentsInput>
  }

  export type TransactionUpdateWithoutDailyRepaymentsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutDailyRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserUpsertWithoutDailyRepaymentsInput = {
    update: XOR<UserUpdateWithoutDailyRepaymentsInput, UserUncheckedUpdateWithoutDailyRepaymentsInput>
    create: XOR<UserCreateWithoutDailyRepaymentsInput, UserUncheckedCreateWithoutDailyRepaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyRepaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyRepaymentsInput, UserUncheckedUpdateWithoutDailyRepaymentsInput>
  }

  export type UserUpdateWithoutDailyRepaymentsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutDailyRepaymentInput = {
    update: XOR<BranchUpdateWithoutDailyRepaymentInput, BranchUncheckedUpdateWithoutDailyRepaymentInput>
    create: XOR<BranchCreateWithoutDailyRepaymentInput, BranchUncheckedCreateWithoutDailyRepaymentInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDailyRepaymentInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDailyRepaymentInput, BranchUncheckedUpdateWithoutDailyRepaymentInput>
  }

  export type BranchUpdateWithoutDailyRepaymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDailyRepaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TransactionCreateWithoutCreditRepaymentsInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCreditRepaymentsInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCreditRepaymentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreditRepaymentsInput, TransactionUncheckedCreateWithoutCreditRepaymentsInput>
  }

  export type PaymentScheduleCreateWithoutCreditRepaymentsInput = {
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    transaction: TransactionCreateNestedOneWithoutPaymentSchedulesInput
    paidBy?: UserCreateNestedOneWithoutPaymentScheduleInput
    repayments?: PaymentRepaymentCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleUncheckedCreateWithoutCreditRepaymentsInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
    repayments?: PaymentRepaymentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type PaymentScheduleCreateOrConnectWithoutCreditRepaymentsInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedCreateWithoutCreditRepaymentsInput>
  }

  export type UserCreateWithoutCreditRepaymentsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreditRepaymentsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreditRepaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditRepaymentsInput, UserUncheckedCreateWithoutCreditRepaymentsInput>
  }

  export type BranchCreateWithoutCreditRepaymentInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCreditRepaymentInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCreditRepaymentInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCreditRepaymentInput, BranchUncheckedCreateWithoutCreditRepaymentInput>
  }

  export type TransactionUpsertWithoutCreditRepaymentsInput = {
    update: XOR<TransactionUpdateWithoutCreditRepaymentsInput, TransactionUncheckedUpdateWithoutCreditRepaymentsInput>
    create: XOR<TransactionCreateWithoutCreditRepaymentsInput, TransactionUncheckedCreateWithoutCreditRepaymentsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutCreditRepaymentsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutCreditRepaymentsInput, TransactionUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type TransactionUpdateWithoutCreditRepaymentsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreditRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentScheduleUpsertWithoutCreditRepaymentsInput = {
    update: XOR<PaymentScheduleUpdateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedUpdateWithoutCreditRepaymentsInput>
    create: XOR<PaymentScheduleCreateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedCreateWithoutCreditRepaymentsInput>
    where?: PaymentScheduleWhereInput
  }

  export type PaymentScheduleUpdateToOneWithWhereWithoutCreditRepaymentsInput = {
    where?: PaymentScheduleWhereInput
    data: XOR<PaymentScheduleUpdateWithoutCreditRepaymentsInput, PaymentScheduleUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type PaymentScheduleUpdateWithoutCreditRepaymentsInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: TransactionUpdateOneRequiredWithoutPaymentSchedulesNestedInput
    paidBy?: UserUpdateOneWithoutPaymentScheduleNestedInput
    repayments?: PaymentRepaymentUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutCreditRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    repayments?: PaymentRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type UserUpsertWithoutCreditRepaymentsInput = {
    update: XOR<UserUpdateWithoutCreditRepaymentsInput, UserUncheckedUpdateWithoutCreditRepaymentsInput>
    create: XOR<UserCreateWithoutCreditRepaymentsInput, UserUncheckedCreateWithoutCreditRepaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditRepaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditRepaymentsInput, UserUncheckedUpdateWithoutCreditRepaymentsInput>
  }

  export type UserUpdateWithoutCreditRepaymentsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditRepaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutCreditRepaymentInput = {
    update: XOR<BranchUpdateWithoutCreditRepaymentInput, BranchUncheckedUpdateWithoutCreditRepaymentInput>
    create: XOR<BranchCreateWithoutCreditRepaymentInput, BranchUncheckedCreateWithoutCreditRepaymentInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCreditRepaymentInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCreditRepaymentInput, BranchUncheckedUpdateWithoutCreditRepaymentInput>
  }

  export type BranchUpdateWithoutCreditRepaymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCreditRepaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutCashierReportsInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCashierReportsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCashierReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashierReportsInput, UserUncheckedCreateWithoutCashierReportsInput>
  }

  export type BranchCreateWithoutCashierReportsInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCashierReportsInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCashierReportsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCashierReportsInput, BranchUncheckedCreateWithoutCashierReportsInput>
  }

  export type UserUpsertWithoutCashierReportsInput = {
    update: XOR<UserUpdateWithoutCashierReportsInput, UserUncheckedUpdateWithoutCashierReportsInput>
    create: XOR<UserCreateWithoutCashierReportsInput, UserUncheckedCreateWithoutCashierReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashierReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashierReportsInput, UserUncheckedUpdateWithoutCashierReportsInput>
  }

  export type UserUpdateWithoutCashierReportsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCashierReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutCashierReportsInput = {
    update: XOR<BranchUpdateWithoutCashierReportsInput, BranchUncheckedUpdateWithoutCashierReportsInput>
    create: XOR<BranchCreateWithoutCashierReportsInput, BranchUncheckedCreateWithoutCashierReportsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCashierReportsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCashierReportsInput, BranchUncheckedUpdateWithoutCashierReportsInput>
  }

  export type BranchUpdateWithoutCashierReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCashierReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutExchangeRatesInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    bonuses?: BonusCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutExchangeRatesInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutExchangeRatesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutExchangeRatesInput, BranchUncheckedCreateWithoutExchangeRatesInput>
  }

  export type UserCreateWithoutExchangeRatesInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutExchangeRatesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutExchangeRatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExchangeRatesInput, UserUncheckedCreateWithoutExchangeRatesInput>
  }

  export type BranchUpsertWithoutExchangeRatesInput = {
    update: XOR<BranchUpdateWithoutExchangeRatesInput, BranchUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<BranchCreateWithoutExchangeRatesInput, BranchUncheckedCreateWithoutExchangeRatesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutExchangeRatesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutExchangeRatesInput, BranchUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type BranchUpdateWithoutExchangeRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutExchangeRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutExchangeRatesInput = {
    update: XOR<UserUpdateWithoutExchangeRatesInput, UserUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<UserCreateWithoutExchangeRatesInput, UserUncheckedCreateWithoutExchangeRatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExchangeRatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExchangeRatesInput, UserUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type UserUpdateWithoutExchangeRatesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutExchangeRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutBonusesInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutBonusesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
  }

  export type UserCreateWithoutCreatedBonusesInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedBonusesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    faceTemplates?: FaceTemplateUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBonusesInput, UserUncheckedCreateWithoutCreatedBonusesInput>
  }

  export type BranchCreateWithoutBonusesInput = {
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionCreateNestedManyWithoutToBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessCreateNestedManyWithoutBranchInput
    categories?: CategoryCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBonusesInput = {
    id?: number
    name: string
    address?: string | null
    type?: $Enums.BranchType
    cashBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    status?: $Enums.BranchStatus
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFromBranchInput
    toTransactions?: TransactionUncheckedCreateNestedManyWithoutToBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    allowedUsers?: UserBranchAccessUncheckedCreateNestedManyWithoutBranchInput
    categories?: CategoryUncheckedCreateNestedManyWithoutBranchInput
    fromTransfers?: ProductTransferUncheckedCreateNestedManyWithoutFromBranchInput
    toTransfers?: ProductTransferUncheckedCreateNestedManyWithoutToBranchInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutBranchInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutBranchInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutBranchInput
    DailyRepayment?: DailyRepaymentUncheckedCreateNestedManyWithoutBranchInput
    CreditRepayment?: CreditRepaymentUncheckedCreateNestedManyWithoutBranchInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutBranchInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBonusesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBonusesInput, BranchUncheckedCreateWithoutBonusesInput>
  }

  export type TransactionCreateWithoutBonusesInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBonusesInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonusProducts?: TransactionBonusProductUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBonusesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBonusesInput, TransactionUncheckedCreateWithoutBonusesInput>
  }

  export type UserUpsertWithoutBonusesInput = {
    update: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type UserUpdateWithoutBonusesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutCreatedBonusesInput = {
    update: XOR<UserUpdateWithoutCreatedBonusesInput, UserUncheckedUpdateWithoutCreatedBonusesInput>
    create: XOR<UserCreateWithoutCreatedBonusesInput, UserUncheckedCreateWithoutCreatedBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBonusesInput, UserUncheckedUpdateWithoutCreatedBonusesInput>
  }

  export type UserUpdateWithoutCreatedBonusesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutBonusesInput = {
    update: XOR<BranchUpdateWithoutBonusesInput, BranchUncheckedUpdateWithoutBonusesInput>
    create: XOR<BranchCreateWithoutBonusesInput, BranchUncheckedCreateWithoutBonusesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBonusesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBonusesInput, BranchUncheckedUpdateWithoutBonusesInput>
  }

  export type BranchUpdateWithoutBonusesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUpdateManyWithoutToBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUpdateManyWithoutBranchNestedInput
    categories?: CategoryUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    cashBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBranchStatusFieldUpdateOperationsInput | $Enums.BranchStatus
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransactions?: TransactionUncheckedUpdateManyWithoutToBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    allowedUsers?: UserBranchAccessUncheckedUpdateManyWithoutBranchNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutBranchNestedInput
    fromTransfers?: ProductTransferUncheckedUpdateManyWithoutFromBranchNestedInput
    toTransfers?: ProductTransferUncheckedUpdateManyWithoutToBranchNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutBranchNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutBranchNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutBranchNestedInput
    DailyRepayment?: DailyRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    CreditRepayment?: CreditRepaymentUncheckedUpdateManyWithoutBranchNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutBranchNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TransactionUpsertWithoutBonusesInput = {
    update: XOR<TransactionUpdateWithoutBonusesInput, TransactionUncheckedUpdateWithoutBonusesInput>
    create: XOR<TransactionCreateWithoutBonusesInput, TransactionUncheckedCreateWithoutBonusesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutBonusesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutBonusesInput, TransactionUncheckedUpdateWithoutBonusesInput>
  }

  export type TransactionUpdateWithoutBonusesInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateWithoutBonusProductsInput = {
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    user?: UserCreateNestedOneWithoutCreatedTransactionsInput
    soldBy?: UserCreateNestedOneWithoutSoldTransactionsInput
    fromBranch?: BranchCreateNestedOneWithoutTransactionsInput
    toBranch?: BranchCreateNestedOneWithoutToTransactionsInput
    updatedBy?: UserCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutTransactionInput
    bonuses?: BonusCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBonusProductsInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentSchedules?: PaymentScheduleUncheckedCreateNestedManyWithoutTransactionInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutTransactionInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBonusProductsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBonusProductsInput, TransactionUncheckedCreateWithoutBonusProductsInput>
  }

  export type ProductCreateWithoutBonusProductsInput = {
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    branch: BranchCreateNestedOneWithoutProductsInput
    category: CategoryCreateNestedOneWithoutProductsInput
    transactions?: TransactionItemCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBonusProductsInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
    transactions?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    DefectiveLog?: DefectiveLogUncheckedCreateNestedManyWithoutProductInput
    ProductTransfer?: ProductTransferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBonusProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBonusProductsInput, ProductUncheckedCreateWithoutBonusProductsInput>
  }

  export type TransactionUpsertWithoutBonusProductsInput = {
    update: XOR<TransactionUpdateWithoutBonusProductsInput, TransactionUncheckedUpdateWithoutBonusProductsInput>
    create: XOR<TransactionCreateWithoutBonusProductsInput, TransactionUncheckedCreateWithoutBonusProductsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutBonusProductsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutBonusProductsInput, TransactionUncheckedUpdateWithoutBonusProductsInput>
  }

  export type TransactionUpdateWithoutBonusProductsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBonusProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ProductUpsertWithoutBonusProductsInput = {
    update: XOR<ProductUpdateWithoutBonusProductsInput, ProductUncheckedUpdateWithoutBonusProductsInput>
    create: XOR<ProductCreateWithoutBonusProductsInput, ProductUncheckedCreateWithoutBonusProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBonusProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBonusProductsInput, ProductUncheckedUpdateWithoutBonusProductsInput>
  }

  export type ProductUpdateWithoutBonusProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBonusProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutFaceTemplatesInput = {
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdTransactions?: TransactionCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateCreateNestedManyWithoutUserInput
    bonuses?: BonusCreateNestedManyWithoutUserInput
    createdBonuses?: BonusCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutFaceTemplatesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
    allowedBranches?: UserBranchAccessUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    soldTransactions?: TransactionUncheckedCreateNestedManyWithoutSoldByInput
    initiatedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutInitiatedByInput
    approvedTransfers?: ProductTransferUncheckedCreateNestedManyWithoutApprovedByInput
    userLocations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    defectiveLogs?: DefectiveLogUncheckedCreateNestedManyWithoutUserInput
    PaymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutPaidByInput
    PaymentRepayment?: PaymentRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    dailyRepayments?: DailyRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    creditRepayments?: CreditRepaymentUncheckedCreateNestedManyWithoutPaidByInput
    cashierReports?: CashierReportUncheckedCreateNestedManyWithoutCashierInput
    exchangeRates?: CurrencyExchangeRateUncheckedCreateNestedManyWithoutUserInput
    bonuses?: BonusUncheckedCreateNestedManyWithoutUserInput
    createdBonuses?: BonusUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutFaceTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFaceTemplatesInput, UserUncheckedCreateWithoutFaceTemplatesInput>
  }

  export type UserUpsertWithoutFaceTemplatesInput = {
    update: XOR<UserUpdateWithoutFaceTemplatesInput, UserUncheckedUpdateWithoutFaceTemplatesInput>
    create: XOR<UserCreateWithoutFaceTemplatesInput, UserUncheckedCreateWithoutFaceTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFaceTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFaceTemplatesInput, UserUncheckedUpdateWithoutFaceTemplatesInput>
  }

  export type UserUpdateWithoutFaceTemplatesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFaceTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AttendanceEventCreateManyDayInput = {
    id?: number
    userId: number
    branchId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttendanceEventUpdateWithoutDayInput = {
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceEventsNestedInput
    branch?: BranchUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyWithoutDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyBranchInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    categoryId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
  }

  export type TransactionCreateManyFromBranchInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyToBranchInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    username: string
    password?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    workStartTime?: string | null
    workEndTime?: string | null
    workShift?: string | null
  }

  export type UserBranchAccessCreateManyBranchInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyBranchInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateManyFromBranchInput = {
    id?: number
    productId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateManyToBranchInput = {
    id?: number
    productId: number
    fromBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectiveLogCreateManyBranchInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    userId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type CurrencyExchangeRateCreateManyBranchInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierReportCreateManyBranchInput = {
    id?: number
    cashierId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRepaymentCreateManyBranchInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateManyBranchInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type BonusCreateManyBranchInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceDayCreateManyBranchInput = {
    id?: number
    userId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceEventCreateManyBranchInput = {
    id?: number
    userId: number
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionUpdateWithoutFromBranchInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFromBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutFromBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutToBranchInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutToBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutToBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUpdateManyWithoutUserNestedInput
    bonuses?: BonusUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
    allowedBranches?: UserBranchAccessUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    soldTransactions?: TransactionUncheckedUpdateManyWithoutSoldByNestedInput
    initiatedTransfers?: ProductTransferUncheckedUpdateManyWithoutInitiatedByNestedInput
    approvedTransfers?: ProductTransferUncheckedUpdateManyWithoutApprovedByNestedInput
    userLocations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    defectiveLogs?: DefectiveLogUncheckedUpdateManyWithoutUserNestedInput
    PaymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutPaidByNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutPaidByNestedInput
    cashierReports?: CashierReportUncheckedUpdateManyWithoutCashierNestedInput
    exchangeRates?: CurrencyExchangeRateUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutUserNestedInput
    createdBonuses?: BonusUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutUserNestedInput
    faceTemplates?: FaceTemplateUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    workStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    workEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    workShift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBranchAccessUpdateWithoutBranchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllowedBranchesNestedInput
  }

  export type UserBranchAccessUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBranchAccessUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUpdateWithoutFromBranchInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductTransferNestedInput
    toBranch?: BranchUpdateOneRequiredWithoutToTransfersNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateWithoutFromBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyWithoutFromBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUpdateWithoutToBranchInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductTransferNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutFromTransfersNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateWithoutToBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyWithoutToBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectiveLogUpdateWithoutBranchInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutDefectiveLogNestedInput
    user?: UserUpdateOneWithoutDefectiveLogsNestedInput
  }

  export type DefectiveLogUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CurrencyExchangeRateUpdateWithoutBranchInput = {
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExchangeRatesNestedInput
  }

  export type CurrencyExchangeRateUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportUpdateWithoutBranchInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutCashierReportsNestedInput
  }

  export type CashierReportUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUpdateWithoutBranchInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDailyRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutDailyRepaymentsNestedInput
  }

  export type DailyRepaymentUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUpdateWithoutBranchInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutCreditRepaymentsNestedInput
    schedule?: PaymentScheduleUpdateOneWithoutCreditRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutCreditRepaymentsNestedInput
  }

  export type CreditRepaymentUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUpdateWithoutBranchInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBonusesNestedInput
    transaction?: TransactionUpdateOneWithoutBonusesNestedInput
  }

  export type BonusUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceDaysNestedInput
    events?: AttendanceEventUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: AttendanceEventUncheckedUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUpdateWithoutBranchInput = {
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceEventsNestedInput
    day?: AttendanceDayUpdateOneWithoutEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBranchAccessCreateManyUserInput = {
    id?: number
    branchId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    customerId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySoldByInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateManyInitiatedByInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductTransferCreateManyApprovedByInput = {
    id?: number
    productId: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLocationCreateManyUserInput = {
    latitude: number
    longitude: number
    address?: string | null
    isOnline?: boolean
    lastSeen: Date | string
    updatedAt?: Date | string
  }

  export type DefectiveLogCreateManyUserInput = {
    id?: number
    productId: number
    quantity: number
    description: string
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type PaymentScheduleCreateManyPaidByInput = {
    id?: number
    transactionId: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
  }

  export type PaymentRepaymentCreateManyPaidByInput = {
    id?: number
    transactionId: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    createdAt?: Date | string
  }

  export type DailyRepaymentCreateManyPaidByInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateManyPaidByInput = {
    id?: number
    transactionId: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CashierReportCreateManyCashierInput = {
    id?: number
    branchId: number
    reportDate: Date | string
    cashTotal?: number
    cardTotal?: number
    creditTotal?: number
    installmentTotal?: number
    upfrontTotal?: number
    upfrontCash?: number
    upfrontCard?: number
    soldQuantity?: number
    soldAmount?: number
    repaymentTotal?: number
    defectivePlus?: number
    defectiveMinus?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyExchangeRateCreateManyUserInput = {
    id?: number
    fromCurrency?: string
    toCurrency?: string
    rate: number
    isActive?: boolean
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateManyUserInput = {
    id?: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateManyCreatedByInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    branchId?: number | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceDayCreateManyUserInput = {
    id?: number
    branchId?: number | null
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    totalMinutes?: number | null
    status?: $Enums.AttendanceStatus | null
    deviceId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceEventCreateManyUserInput = {
    id?: number
    branchId?: number | null
    dayId?: number | null
    eventType: $Enums.AttendanceEventType
    occurredAt?: Date | string
    deviceId?: string | null
    similarity?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FaceTemplateCreateManyUserInput = {
    id?: number
    deviceId?: string | null
    template?: string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUpdatedByInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBranchAccessUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAllowedUsersNestedInput
  }

  export type UserBranchAccessUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBranchAccessUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSoldByInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSoldByInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutSoldByInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUpdateWithoutInitiatedByInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductTransferNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutFromTransfersNestedInput
    toBranch?: BranchUpdateOneRequiredWithoutToTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUpdateWithoutApprovedByInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductTransferNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutFromTransfersNestedInput
    toBranch?: BranchUpdateOneRequiredWithoutToTransfersNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateManyWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectiveLogUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutDefectiveLogNestedInput
    branch?: BranchUpdateOneWithoutDefectiveLogsNestedInput
  }

  export type DefectiveLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentScheduleUpdateWithoutPaidByInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: TransactionUpdateOneRequiredWithoutPaymentSchedulesNestedInput
    repayments?: PaymentRepaymentUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    repayments?: PaymentRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentRepaymentUpdateWithoutPaidByInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutPaymentRepaymentNestedInput
    schedule?: PaymentScheduleUpdateOneRequiredWithoutRepaymentsNestedInput
  }

  export type PaymentRepaymentUncheckedUpdateWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUpdateWithoutPaidByInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDailyRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutDailyRepaymentNestedInput
  }

  export type DailyRepaymentUncheckedUpdateWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUpdateWithoutPaidByInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutCreditRepaymentsNestedInput
    schedule?: PaymentScheduleUpdateOneWithoutCreditRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutCreditRepaymentNestedInput
  }

  export type CreditRepaymentUncheckedUpdateWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutPaidByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportUpdateWithoutCashierInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutCashierReportsNestedInput
  }

  export type CashierReportUncheckedUpdateWithoutCashierInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierReportUncheckedUpdateManyWithoutCashierInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTotal?: FloatFieldUpdateOperationsInput | number
    cardTotal?: FloatFieldUpdateOperationsInput | number
    creditTotal?: FloatFieldUpdateOperationsInput | number
    installmentTotal?: FloatFieldUpdateOperationsInput | number
    upfrontTotal?: FloatFieldUpdateOperationsInput | number
    upfrontCash?: FloatFieldUpdateOperationsInput | number
    upfrontCard?: FloatFieldUpdateOperationsInput | number
    soldQuantity?: IntFieldUpdateOperationsInput | number
    soldAmount?: FloatFieldUpdateOperationsInput | number
    repaymentTotal?: FloatFieldUpdateOperationsInput | number
    defectivePlus?: FloatFieldUpdateOperationsInput | number
    defectiveMinus?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateUpdateWithoutUserInput = {
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutExchangeRatesNestedInput
  }

  export type CurrencyExchangeRateUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyExchangeRateUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedBonusesNestedInput
    branch?: BranchUpdateOneWithoutBonusesNestedInput
    transaction?: TransactionUpdateOneWithoutBonusesNestedInput
  }

  export type BonusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUpdateWithoutCreatedByInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    branch?: BranchUpdateOneWithoutBonusesNestedInput
    transaction?: TransactionUpdateOneWithoutBonusesNestedInput
  }

  export type BonusUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAttendanceDaysNestedInput
    events?: AttendanceEventUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: AttendanceEventUncheckedUpdateManyWithoutDayNestedInput
  }

  export type AttendanceDayUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUpdateWithoutUserInput = {
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAttendanceEventsNestedInput
    day?: AttendanceDayUpdateOneWithoutEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumAttendanceEventTypeFieldUpdateOperationsInput | $Enums.AttendanceEventType
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    similarity?: NullableFloatFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateUpdateWithoutUserInput = {
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaceTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    vector?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUpdatedByInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    name: string
    barcode?: string | null
    model?: string | null
    price: number
    quantity: number
    defectiveQuantity?: number
    returnedQuantity?: number
    exchangedQuantity?: number
    initialQuantity?: number
    status?: $Enums.ProductStatus
    branchId: number
    marketPrice?: number | null
    bonusPercentage?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sizeType?: $Enums.ProductSizeType
    sizeLabel?: string | null
    sizeNumber?: number | null
    areaSqm?: number | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    transactions?: TransactionItemUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
    transactions?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    DefectiveLog?: DefectiveLogUncheckedUpdateManyWithoutProductNestedInput
    ProductTransfer?: ProductTransferUncheckedUpdateManyWithoutProductNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    defectiveQuantity?: IntFieldUpdateOperationsInput | number
    returnedQuantity?: IntFieldUpdateOperationsInput | number
    exchangedQuantity?: IntFieldUpdateOperationsInput | number
    initialQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    branchId?: IntFieldUpdateOperationsInput | number
    marketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizeType?: EnumProductSizeTypeFieldUpdateOperationsInput | $Enums.ProductSizeType
    sizeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sizeNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    areaSqm?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionItemCreateManyProductInput = {
    id?: number
    transactionId: number
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectiveLogCreateManyProductInput = {
    id?: number
    quantity: number
    description: string
    userId?: number | null
    branchId?: number | null
    cashAmount?: number
    actionType?: string
    createdAt?: Date | string
    exchangeWithProductId?: number | null
    replacementQuantity?: number | null
    replacementUnitPrice?: number | null
    replacementTransactionId?: number | null
  }

  export type ProductTransferCreateManyProductInput = {
    id?: number
    fromBranchId: number
    toBranchId: number
    quantity: number
    status?: $Enums.TransferStatus
    initiatedById: number
    approvedById?: number | null
    transferDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionBonusProductCreateManyProductInput = {
    id?: number
    transactionId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectiveLogUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutDefectiveLogsNestedInput
    branch?: BranchUpdateOneWithoutDefectiveLogsNestedInput
  }

  export type DefectiveLogUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefectiveLogUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    cashAmount?: FloatFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeWithProductId?: NullableIntFieldUpdateOperationsInput | number | null
    replacementQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    replacementUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    replacementTransactionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductTransferUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromBranch?: BranchUpdateOneRequiredWithoutFromTransfersNestedInput
    toBranch?: BranchUpdateOneRequiredWithoutToTransfersNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type ProductTransferUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransferUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromBranchId?: IntFieldUpdateOperationsInput | number
    toBranchId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    initiatedById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutBonusProductsNestedInput
  }

  export type TransactionBonusProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCustomerInput = {
    id?: number
    userId?: number | null
    soldByUserId?: number | null
    fromBranchId?: number | null
    toBranchId?: number | null
    type: $Enums.TransactionType
    transactionType?: string | null
    status?: $Enums.TransactionStatus
    discount?: number
    total: number
    finalTotal: number
    paymentType?: $Enums.PaymentType | null
    upfrontPaymentType?: string | null
    termUnit?: string | null
    deliveryMethod?: string | null
    deliveryType?: string | null
    deliveryAddress?: string | null
    amountPaid?: number | null
    downPayment?: number | null
    remainingBalance?: number | null
    receiptId?: string | null
    description?: string | null
    updatedById?: number | null
    creditRepaymentAmount?: number | null
    lastRepaymentDate?: Date | string | null
    extraProfit?: number | null
    days?: number | null
    months?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCreatedTransactionsNestedInput
    soldBy?: UserUpdateOneWithoutSoldTransactionsNestedInput
    fromBranch?: BranchUpdateOneWithoutTransactionsNestedInput
    toBranch?: BranchUpdateOneWithoutToTransactionsNestedInput
    updatedBy?: UserUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentSchedules?: PaymentScheduleUncheckedUpdateManyWithoutTransactionNestedInput
    PaymentRepayment?: PaymentRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    dailyRepayments?: DailyRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutTransactionNestedInput
    bonusProducts?: TransactionBonusProductUncheckedUpdateManyWithoutTransactionNestedInput
    bonuses?: BonusUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    soldByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    fromBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    toBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transactionType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    finalTotal?: FloatFieldUpdateOperationsInput | number
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    upfrontPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    termUnit?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryType?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    downPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    lastRepaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    months?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemCreateManyTransactionInput = {
    id?: number
    productId?: number | null
    quantity: number
    price: number
    sellingPrice?: number | null
    originalPrice?: number | null
    total: number
    creditMonth?: number | null
    creditPercent?: number | null
    monthlyPayment?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentScheduleCreateManyTransactionInput = {
    id?: number
    month: number
    payment: number
    remainingBalance: number
    isPaid?: boolean
    paidAmount?: number
    paidAt?: Date | string | null
    paidChannel?: string | null
    paidByUserId?: number | null
    createdAt?: Date | string
    creditRepaymentAmount?: number | null
    repaymentDate?: Date | string | null
    rating?: string | null
    dueDate?: Date | string | null
    isDailyInstallment?: boolean
    daysCount?: number | null
    installmentType?: string | null
    totalDays?: number | null
    remainingDays?: number | null
    totalMonths?: number | null
    remainingMonths?: number | null
  }

  export type PaymentRepaymentCreateManyTransactionInput = {
    id?: number
    scheduleId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type DailyRepaymentCreateManyTransactionInput = {
    id?: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateManyTransactionInput = {
    id?: number
    scheduleId?: number | null
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type TransactionBonusProductCreateManyTransactionInput = {
    id?: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonusCreateManyTransactionInput = {
    id?: number
    userId: number
    amount: number
    reason: string
    description?: string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: Date | string
    createdById: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemUpdateWithoutTransactionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    creditMonth?: NullableIntFieldUpdateOperationsInput | number | null
    creditPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentScheduleUpdateWithoutTransactionInput = {
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    paidBy?: UserUpdateOneWithoutPaymentScheduleNestedInput
    repayments?: PaymentRepaymentUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    repayments?: PaymentRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
    creditRepayments?: CreditRepaymentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    payment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidChannel?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditRepaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    repaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDailyInstallment?: BoolFieldUpdateOperationsInput | boolean
    daysCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: NullableIntFieldUpdateOperationsInput | number | null
    remainingDays?: NullableIntFieldUpdateOperationsInput | number | null
    totalMonths?: NullableIntFieldUpdateOperationsInput | number | null
    remainingMonths?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentRepaymentUpdateWithoutTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: PaymentScheduleUpdateOneRequiredWithoutRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutPaymentRepaymentNestedInput
  }

  export type PaymentRepaymentUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUpdateWithoutTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidBy?: UserUpdateOneWithoutDailyRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutDailyRepaymentNestedInput
  }

  export type DailyRepaymentUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRepaymentUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUpdateWithoutTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: PaymentScheduleUpdateOneWithoutCreditRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutCreditRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutCreditRepaymentNestedInput
  }

  export type CreditRepaymentUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductUpdateWithoutTransactionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutBonusProductsNestedInput
  }

  export type TransactionBonusProductUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionBonusProductUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUpdateWithoutTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBonusesNestedInput
    branch?: BranchUpdateOneWithoutBonusesNestedInput
  }

  export type BonusUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bonusProducts?: NullableJsonNullValueInput | InputJsonValue
    bonusDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentCreateManyScheduleInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    paidAt?: Date | string
    paidByUserId?: number | null
    createdAt?: Date | string
  }

  export type CreditRepaymentCreateManyScheduleInput = {
    id?: number
    transactionId: number
    amount: number
    channel?: string
    month?: string | null
    monthNumber?: number | null
    paidAt?: Date | string
    paidByUserId?: number | null
    branchId?: number | null
    createdAt?: Date | string
  }

  export type PaymentRepaymentUpdateWithoutScheduleInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutPaymentRepaymentNestedInput
    paidBy?: UserUpdateOneWithoutPaymentRepaymentNestedInput
  }

  export type PaymentRepaymentUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRepaymentUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUpdateWithoutScheduleInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutCreditRepaymentsNestedInput
    paidBy?: UserUpdateOneWithoutCreditRepaymentsNestedInput
    branch?: BranchUpdateOneWithoutCreditRepaymentNestedInput
  }

  export type CreditRepaymentUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRepaymentUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    month?: NullableStringFieldUpdateOperationsInput | string | null
    monthNumber?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}